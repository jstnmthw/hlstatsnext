/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  DateTime: { input: any; output: any; }
  Decimal: { input: any; output: any; }
  Json: { input: any; output: any; }
};

export type Account = {
  __typename?: 'Account';
  accessToken?: Maybe<Scalars['String']['output']>;
  accessTokenExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  accountId: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  idToken?: Maybe<Scalars['String']['output']>;
  password?: Maybe<Scalars['String']['output']>;
  providerId: Scalars['String']['output'];
  refreshToken?: Maybe<Scalars['String']['output']>;
  refreshTokenExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  scope?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  user: User;
  userId: Scalars['String']['output'];
};

export type AccountCountOrderByAggregateInput = {
  accessToken?: InputMaybe<SortOrder>;
  accessTokenExpiresAt?: InputMaybe<SortOrder>;
  accountId?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idToken?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  providerId?: InputMaybe<SortOrder>;
  refreshToken?: InputMaybe<SortOrder>;
  refreshTokenExpiresAt?: InputMaybe<SortOrder>;
  scope?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type AccountCreateInput = {
  accessToken?: InputMaybe<Scalars['String']['input']>;
  accessTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  accountId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id: Scalars['String']['input'];
  idToken?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  providerId: Scalars['String']['input'];
  refreshToken?: InputMaybe<Scalars['String']['input']>;
  refreshTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  scope?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user: UserCreateNestedOneWithoutAccountsInput;
};

export type AccountCreateManyInput = {
  accessToken?: InputMaybe<Scalars['String']['input']>;
  accessTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  accountId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id: Scalars['String']['input'];
  idToken?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  providerId: Scalars['String']['input'];
  refreshToken?: InputMaybe<Scalars['String']['input']>;
  refreshTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  scope?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  userId: Scalars['String']['input'];
};

export type AccountCreateManyUserInput = {
  accessToken?: InputMaybe<Scalars['String']['input']>;
  accessTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  accountId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id: Scalars['String']['input'];
  idToken?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  providerId: Scalars['String']['input'];
  refreshToken?: InputMaybe<Scalars['String']['input']>;
  refreshTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  scope?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AccountCreateManyUserInputEnvelope = {
  data: Array<AccountCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AccountCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<AccountWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AccountCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<AccountCreateWithoutUserInput>>;
  createMany?: InputMaybe<AccountCreateManyUserInputEnvelope>;
};

export type AccountCreateOrConnectWithoutUserInput = {
  create: AccountCreateWithoutUserInput;
  where: AccountWhereUniqueInput;
};

export type AccountCreateWithoutUserInput = {
  accessToken?: InputMaybe<Scalars['String']['input']>;
  accessTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  accountId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id: Scalars['String']['input'];
  idToken?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  providerId: Scalars['String']['input'];
  refreshToken?: InputMaybe<Scalars['String']['input']>;
  refreshTokenExpiresAt?: InputMaybe<Scalars['DateTime']['input']>;
  scope?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AccountListRelationFilter = {
  every?: InputMaybe<AccountWhereInput>;
  none?: InputMaybe<AccountWhereInput>;
  some?: InputMaybe<AccountWhereInput>;
};

export type AccountMaxOrderByAggregateInput = {
  accessToken?: InputMaybe<SortOrder>;
  accessTokenExpiresAt?: InputMaybe<SortOrder>;
  accountId?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idToken?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  providerId?: InputMaybe<SortOrder>;
  refreshToken?: InputMaybe<SortOrder>;
  refreshTokenExpiresAt?: InputMaybe<SortOrder>;
  scope?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type AccountMinOrderByAggregateInput = {
  accessToken?: InputMaybe<SortOrder>;
  accessTokenExpiresAt?: InputMaybe<SortOrder>;
  accountId?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idToken?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  providerId?: InputMaybe<SortOrder>;
  refreshToken?: InputMaybe<SortOrder>;
  refreshTokenExpiresAt?: InputMaybe<SortOrder>;
  scope?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type AccountOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum AccountOrderByRelevanceFieldEnum {
  AccessToken = 'accessToken',
  AccountId = 'accountId',
  Id = 'id',
  IdToken = 'idToken',
  Password = 'password',
  ProviderId = 'providerId',
  RefreshToken = 'refreshToken',
  Scope = 'scope',
  UserId = 'userId'
}

export type AccountOrderByRelevanceInput = {
  fields: Array<AccountOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type AccountOrderByWithAggregationInput = {
  _count?: InputMaybe<AccountCountOrderByAggregateInput>;
  _max?: InputMaybe<AccountMaxOrderByAggregateInput>;
  _min?: InputMaybe<AccountMinOrderByAggregateInput>;
  accessToken?: InputMaybe<SortOrder>;
  accessTokenExpiresAt?: InputMaybe<SortOrder>;
  accountId?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idToken?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  providerId?: InputMaybe<SortOrder>;
  refreshToken?: InputMaybe<SortOrder>;
  refreshTokenExpiresAt?: InputMaybe<SortOrder>;
  scope?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type AccountOrderByWithRelationInput = {
  _relevance?: InputMaybe<AccountOrderByRelevanceInput>;
  accessToken?: InputMaybe<SortOrder>;
  accessTokenExpiresAt?: InputMaybe<SortOrder>;
  accountId?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  idToken?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  providerId?: InputMaybe<SortOrder>;
  refreshToken?: InputMaybe<SortOrder>;
  refreshTokenExpiresAt?: InputMaybe<SortOrder>;
  scope?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userId?: InputMaybe<SortOrder>;
};

export enum AccountScalarFieldEnum {
  AccessToken = 'accessToken',
  AccessTokenExpiresAt = 'accessTokenExpiresAt',
  AccountId = 'accountId',
  CreatedAt = 'createdAt',
  Id = 'id',
  IdToken = 'idToken',
  Password = 'password',
  ProviderId = 'providerId',
  RefreshToken = 'refreshToken',
  RefreshTokenExpiresAt = 'refreshTokenExpiresAt',
  Scope = 'scope',
  UpdatedAt = 'updatedAt',
  UserId = 'userId'
}

export type AccountScalarWhereInput = {
  AND?: InputMaybe<Array<AccountScalarWhereInput>>;
  NOT?: InputMaybe<Array<AccountScalarWhereInput>>;
  OR?: InputMaybe<Array<AccountScalarWhereInput>>;
  accessToken?: InputMaybe<StringNullableFilter>;
  accessTokenExpiresAt?: InputMaybe<DateTimeNullableFilter>;
  accountId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  idToken?: InputMaybe<StringNullableFilter>;
  password?: InputMaybe<StringNullableFilter>;
  providerId?: InputMaybe<StringFilter>;
  refreshToken?: InputMaybe<StringNullableFilter>;
  refreshTokenExpiresAt?: InputMaybe<DateTimeNullableFilter>;
  scope?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type AccountScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<AccountScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<AccountScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<AccountScalarWhereWithAggregatesInput>>;
  accessToken?: InputMaybe<StringNullableWithAggregatesFilter>;
  accessTokenExpiresAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  accountId?: InputMaybe<StringWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  idToken?: InputMaybe<StringNullableWithAggregatesFilter>;
  password?: InputMaybe<StringNullableWithAggregatesFilter>;
  providerId?: InputMaybe<StringWithAggregatesFilter>;
  refreshToken?: InputMaybe<StringNullableWithAggregatesFilter>;
  refreshTokenExpiresAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  scope?: InputMaybe<StringNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  userId?: InputMaybe<StringWithAggregatesFilter>;
};

export type AccountUpdateInput = {
  accessToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  accessTokenExpiresAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  accountId?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  idToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  password?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  providerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  refreshToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  refreshTokenExpiresAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  scope?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutAccountsNestedInput>;
};

export type AccountUpdateManyMutationInput = {
  accessToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  accessTokenExpiresAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  accountId?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  idToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  password?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  providerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  refreshToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  refreshTokenExpiresAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  scope?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type AccountUpdateManyWithWhereWithoutUserInput = {
  data: AccountUpdateManyMutationInput;
  where: AccountScalarWhereInput;
};

export type AccountUpdateManyWithoutUserNestedInput = {
  connect?: InputMaybe<Array<AccountWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AccountCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<AccountCreateWithoutUserInput>>;
  createMany?: InputMaybe<AccountCreateManyUserInputEnvelope>;
  delete?: InputMaybe<Array<AccountWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<AccountScalarWhereInput>>;
  disconnect?: InputMaybe<Array<AccountWhereUniqueInput>>;
  set?: InputMaybe<Array<AccountWhereUniqueInput>>;
  update?: InputMaybe<Array<AccountUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: InputMaybe<Array<AccountUpdateManyWithWhereWithoutUserInput>>;
  upsert?: InputMaybe<Array<AccountUpsertWithWhereUniqueWithoutUserInput>>;
};

export type AccountUpdateWithWhereUniqueWithoutUserInput = {
  data: AccountUpdateWithoutUserInput;
  where: AccountWhereUniqueInput;
};

export type AccountUpdateWithoutUserInput = {
  accessToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  accessTokenExpiresAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  accountId?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  idToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  password?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  providerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  refreshToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  refreshTokenExpiresAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  scope?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type AccountUpsertWithWhereUniqueWithoutUserInput = {
  create: AccountCreateWithoutUserInput;
  update: AccountUpdateWithoutUserInput;
  where: AccountWhereUniqueInput;
};

export type AccountWhereInput = {
  AND?: InputMaybe<Array<AccountWhereInput>>;
  NOT?: InputMaybe<Array<AccountWhereInput>>;
  OR?: InputMaybe<Array<AccountWhereInput>>;
  accessToken?: InputMaybe<StringNullableFilter>;
  accessTokenExpiresAt?: InputMaybe<DateTimeNullableFilter>;
  accountId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  idToken?: InputMaybe<StringNullableFilter>;
  password?: InputMaybe<StringNullableFilter>;
  providerId?: InputMaybe<StringFilter>;
  refreshToken?: InputMaybe<StringNullableFilter>;
  refreshTokenExpiresAt?: InputMaybe<DateTimeNullableFilter>;
  scope?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<StringFilter>;
};

export type AccountWhereUniqueInput = {
  AND?: InputMaybe<Array<AccountWhereInput>>;
  NOT?: InputMaybe<Array<AccountWhereInput>>;
  OR?: InputMaybe<Array<AccountWhereInput>>;
  accessToken?: InputMaybe<StringNullableFilter>;
  accessTokenExpiresAt?: InputMaybe<DateTimeNullableFilter>;
  accountId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  idToken?: InputMaybe<StringNullableFilter>;
  password?: InputMaybe<StringNullableFilter>;
  providerId?: InputMaybe<StringFilter>;
  refreshToken?: InputMaybe<StringNullableFilter>;
  refreshTokenExpiresAt?: InputMaybe<DateTimeNullableFilter>;
  scope?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<StringFilter>;
};

export type Action = {
  __typename?: 'Action';
  code: Scalars['String']['output'];
  count: Scalars['Int']['output'];
  description?: Maybe<Scalars['String']['output']>;
  eventPlayerActions: Array<EventPlayerAction>;
  eventPlayerPlayerActions: Array<EventPlayerPlayerAction>;
  eventTeamBonuses: Array<EventTeamBonus>;
  eventWorldActions: Array<EventWorldAction>;
  forPlayerActions: Scalars['String']['output'];
  forPlayerPlayerActions: Scalars['String']['output'];
  forTeamActions: Scalars['String']['output'];
  forWorldActions: Scalars['String']['output'];
  game: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  rewardPlayer: Scalars['Int']['output'];
  rewardTeam: Scalars['Int']['output'];
  team: Scalars['String']['output'];
};


export type ActionEventPlayerActionsArgs = {
  cursor?: InputMaybe<EventPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerActionWhereInput>;
};


export type ActionEventPlayerPlayerActionsArgs = {
  cursor?: InputMaybe<EventPlayerPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type ActionEventTeamBonusesArgs = {
  cursor?: InputMaybe<EventTeamBonusWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamBonusScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamBonusOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamBonusWhereInput>;
};


export type ActionEventWorldActionsArgs = {
  cursor?: InputMaybe<EventWorldActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventWorldActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventWorldActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventWorldActionWhereInput>;
};

export type ActionAvgOrderByAggregateInput = {
  count?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  rewardPlayer?: InputMaybe<SortOrder>;
  rewardTeam?: InputMaybe<SortOrder>;
};

export type ActionCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  forPlayerActions?: InputMaybe<SortOrder>;
  forPlayerPlayerActions?: InputMaybe<SortOrder>;
  forTeamActions?: InputMaybe<SortOrder>;
  forWorldActions?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  rewardPlayer?: InputMaybe<SortOrder>;
  rewardTeam?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export type ActionCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  count?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventPlayerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutActionInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutActionInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutActionInput>;
  eventWorldActions?: InputMaybe<EventWorldActionCreateNestedManyWithoutActionInput>;
  forPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forPlayerPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forTeamActions?: InputMaybe<Scalars['String']['input']>;
  forWorldActions?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  rewardPlayer?: InputMaybe<Scalars['Int']['input']>;
  rewardTeam?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type ActionCreateManyInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  count?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  forPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forPlayerPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forTeamActions?: InputMaybe<Scalars['String']['input']>;
  forWorldActions?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  rewardPlayer?: InputMaybe<Scalars['Int']['input']>;
  rewardTeam?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type ActionCreateNestedOneWithoutEventPlayerActionsInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventPlayerActionsInput>;
  create?: InputMaybe<ActionCreateWithoutEventPlayerActionsInput>;
};

export type ActionCreateNestedOneWithoutEventPlayerPlayerActionsInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventPlayerPlayerActionsInput>;
  create?: InputMaybe<ActionCreateWithoutEventPlayerPlayerActionsInput>;
};

export type ActionCreateNestedOneWithoutEventTeamBonusesInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventTeamBonusesInput>;
  create?: InputMaybe<ActionCreateWithoutEventTeamBonusesInput>;
};

export type ActionCreateNestedOneWithoutEventWorldActionsInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventWorldActionsInput>;
  create?: InputMaybe<ActionCreateWithoutEventWorldActionsInput>;
};

export type ActionCreateOrConnectWithoutEventPlayerActionsInput = {
  create: ActionCreateWithoutEventPlayerActionsInput;
  where: ActionWhereUniqueInput;
};

export type ActionCreateOrConnectWithoutEventPlayerPlayerActionsInput = {
  create: ActionCreateWithoutEventPlayerPlayerActionsInput;
  where: ActionWhereUniqueInput;
};

export type ActionCreateOrConnectWithoutEventTeamBonusesInput = {
  create: ActionCreateWithoutEventTeamBonusesInput;
  where: ActionWhereUniqueInput;
};

export type ActionCreateOrConnectWithoutEventWorldActionsInput = {
  create: ActionCreateWithoutEventWorldActionsInput;
  where: ActionWhereUniqueInput;
};

export type ActionCreateWithoutEventPlayerActionsInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  count?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutActionInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutActionInput>;
  eventWorldActions?: InputMaybe<EventWorldActionCreateNestedManyWithoutActionInput>;
  forPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forPlayerPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forTeamActions?: InputMaybe<Scalars['String']['input']>;
  forWorldActions?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  rewardPlayer?: InputMaybe<Scalars['Int']['input']>;
  rewardTeam?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type ActionCreateWithoutEventPlayerPlayerActionsInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  count?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventPlayerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutActionInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutActionInput>;
  eventWorldActions?: InputMaybe<EventWorldActionCreateNestedManyWithoutActionInput>;
  forPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forPlayerPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forTeamActions?: InputMaybe<Scalars['String']['input']>;
  forWorldActions?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  rewardPlayer?: InputMaybe<Scalars['Int']['input']>;
  rewardTeam?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type ActionCreateWithoutEventTeamBonusesInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  count?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventPlayerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutActionInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutActionInput>;
  eventWorldActions?: InputMaybe<EventWorldActionCreateNestedManyWithoutActionInput>;
  forPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forPlayerPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forTeamActions?: InputMaybe<Scalars['String']['input']>;
  forWorldActions?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  rewardPlayer?: InputMaybe<Scalars['Int']['input']>;
  rewardTeam?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type ActionCreateWithoutEventWorldActionsInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  count?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventPlayerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutActionInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutActionInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutActionInput>;
  forPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forPlayerPlayerActions?: InputMaybe<Scalars['String']['input']>;
  forTeamActions?: InputMaybe<Scalars['String']['input']>;
  forWorldActions?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  rewardPlayer?: InputMaybe<Scalars['Int']['input']>;
  rewardTeam?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type ActionGamecodeCompoundUniqueInput = {
  code: Scalars['String']['input'];
  game: Scalars['String']['input'];
  team: Scalars['String']['input'];
};

export type ActionMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  forPlayerActions?: InputMaybe<SortOrder>;
  forPlayerPlayerActions?: InputMaybe<SortOrder>;
  forTeamActions?: InputMaybe<SortOrder>;
  forWorldActions?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  rewardPlayer?: InputMaybe<SortOrder>;
  rewardTeam?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export type ActionMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  forPlayerActions?: InputMaybe<SortOrder>;
  forPlayerPlayerActions?: InputMaybe<SortOrder>;
  forTeamActions?: InputMaybe<SortOrder>;
  forWorldActions?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  rewardPlayer?: InputMaybe<SortOrder>;
  rewardTeam?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export enum ActionOrderByRelevanceFieldEnum {
  Code = 'code',
  Description = 'description',
  ForPlayerActions = 'forPlayerActions',
  ForPlayerPlayerActions = 'forPlayerPlayerActions',
  ForTeamActions = 'forTeamActions',
  ForWorldActions = 'forWorldActions',
  Game = 'game',
  Team = 'team'
}

export type ActionOrderByRelevanceInput = {
  fields: Array<ActionOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ActionOrderByWithAggregationInput = {
  _avg?: InputMaybe<ActionAvgOrderByAggregateInput>;
  _count?: InputMaybe<ActionCountOrderByAggregateInput>;
  _max?: InputMaybe<ActionMaxOrderByAggregateInput>;
  _min?: InputMaybe<ActionMinOrderByAggregateInput>;
  _sum?: InputMaybe<ActionSumOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  forPlayerActions?: InputMaybe<SortOrder>;
  forPlayerPlayerActions?: InputMaybe<SortOrder>;
  forTeamActions?: InputMaybe<SortOrder>;
  forWorldActions?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  rewardPlayer?: InputMaybe<SortOrder>;
  rewardTeam?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export type ActionOrderByWithRelationInput = {
  _relevance?: InputMaybe<ActionOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  eventPlayerActions?: InputMaybe<EventPlayerActionOrderByRelationAggregateInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionOrderByRelationAggregateInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusOrderByRelationAggregateInput>;
  eventWorldActions?: InputMaybe<EventWorldActionOrderByRelationAggregateInput>;
  forPlayerActions?: InputMaybe<SortOrder>;
  forPlayerPlayerActions?: InputMaybe<SortOrder>;
  forTeamActions?: InputMaybe<SortOrder>;
  forWorldActions?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  rewardPlayer?: InputMaybe<SortOrder>;
  rewardTeam?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export enum ActionScalarFieldEnum {
  Code = 'code',
  Count = 'count',
  Description = 'description',
  ForPlayerActions = 'forPlayerActions',
  ForPlayerPlayerActions = 'forPlayerPlayerActions',
  ForTeamActions = 'forTeamActions',
  ForWorldActions = 'forWorldActions',
  Game = 'game',
  Id = 'id',
  RewardPlayer = 'rewardPlayer',
  RewardTeam = 'rewardTeam',
  Team = 'team'
}

export type ActionScalarRelationFilter = {
  is?: InputMaybe<ActionWhereInput>;
  isNot?: InputMaybe<ActionWhereInput>;
};

export type ActionScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ActionScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ActionScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ActionScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  count?: InputMaybe<IntWithAggregatesFilter>;
  description?: InputMaybe<StringNullableWithAggregatesFilter>;
  forPlayerActions?: InputMaybe<StringWithAggregatesFilter>;
  forPlayerPlayerActions?: InputMaybe<StringWithAggregatesFilter>;
  forTeamActions?: InputMaybe<StringWithAggregatesFilter>;
  forWorldActions?: InputMaybe<StringWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  rewardPlayer?: InputMaybe<IntWithAggregatesFilter>;
  rewardTeam?: InputMaybe<IntWithAggregatesFilter>;
  team?: InputMaybe<StringWithAggregatesFilter>;
};

export type ActionSumOrderByAggregateInput = {
  count?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  rewardPlayer?: InputMaybe<SortOrder>;
  rewardTeam?: InputMaybe<SortOrder>;
};

export type ActionUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventPlayerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutActionNestedInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutActionNestedInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutActionNestedInput>;
  eventWorldActions?: InputMaybe<EventWorldActionUpdateManyWithoutActionNestedInput>;
  forPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forPlayerPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forTeamActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forWorldActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  rewardPlayer?: InputMaybe<IntFieldUpdateOperationsInput>;
  rewardTeam?: InputMaybe<IntFieldUpdateOperationsInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ActionUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  forPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forPlayerPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forTeamActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forWorldActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  rewardPlayer?: InputMaybe<IntFieldUpdateOperationsInput>;
  rewardTeam?: InputMaybe<IntFieldUpdateOperationsInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ActionUpdateOneRequiredWithoutEventPlayerActionsNestedInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventPlayerActionsInput>;
  create?: InputMaybe<ActionCreateWithoutEventPlayerActionsInput>;
  update?: InputMaybe<ActionUpdateToOneWithWhereWithoutEventPlayerActionsInput>;
  upsert?: InputMaybe<ActionUpsertWithoutEventPlayerActionsInput>;
};

export type ActionUpdateOneRequiredWithoutEventPlayerPlayerActionsNestedInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventPlayerPlayerActionsInput>;
  create?: InputMaybe<ActionCreateWithoutEventPlayerPlayerActionsInput>;
  update?: InputMaybe<ActionUpdateToOneWithWhereWithoutEventPlayerPlayerActionsInput>;
  upsert?: InputMaybe<ActionUpsertWithoutEventPlayerPlayerActionsInput>;
};

export type ActionUpdateOneRequiredWithoutEventTeamBonusesNestedInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventTeamBonusesInput>;
  create?: InputMaybe<ActionCreateWithoutEventTeamBonusesInput>;
  update?: InputMaybe<ActionUpdateToOneWithWhereWithoutEventTeamBonusesInput>;
  upsert?: InputMaybe<ActionUpsertWithoutEventTeamBonusesInput>;
};

export type ActionUpdateOneRequiredWithoutEventWorldActionsNestedInput = {
  connect?: InputMaybe<ActionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ActionCreateOrConnectWithoutEventWorldActionsInput>;
  create?: InputMaybe<ActionCreateWithoutEventWorldActionsInput>;
  update?: InputMaybe<ActionUpdateToOneWithWhereWithoutEventWorldActionsInput>;
  upsert?: InputMaybe<ActionUpsertWithoutEventWorldActionsInput>;
};

export type ActionUpdateToOneWithWhereWithoutEventPlayerActionsInput = {
  data: ActionUpdateWithoutEventPlayerActionsInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionUpdateToOneWithWhereWithoutEventPlayerPlayerActionsInput = {
  data: ActionUpdateWithoutEventPlayerPlayerActionsInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionUpdateToOneWithWhereWithoutEventTeamBonusesInput = {
  data: ActionUpdateWithoutEventTeamBonusesInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionUpdateToOneWithWhereWithoutEventWorldActionsInput = {
  data: ActionUpdateWithoutEventWorldActionsInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionUpdateWithoutEventPlayerActionsInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutActionNestedInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutActionNestedInput>;
  eventWorldActions?: InputMaybe<EventWorldActionUpdateManyWithoutActionNestedInput>;
  forPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forPlayerPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forTeamActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forWorldActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  rewardPlayer?: InputMaybe<IntFieldUpdateOperationsInput>;
  rewardTeam?: InputMaybe<IntFieldUpdateOperationsInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ActionUpdateWithoutEventPlayerPlayerActionsInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventPlayerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutActionNestedInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutActionNestedInput>;
  eventWorldActions?: InputMaybe<EventWorldActionUpdateManyWithoutActionNestedInput>;
  forPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forPlayerPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forTeamActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forWorldActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  rewardPlayer?: InputMaybe<IntFieldUpdateOperationsInput>;
  rewardTeam?: InputMaybe<IntFieldUpdateOperationsInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ActionUpdateWithoutEventTeamBonusesInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventPlayerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutActionNestedInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutActionNestedInput>;
  eventWorldActions?: InputMaybe<EventWorldActionUpdateManyWithoutActionNestedInput>;
  forPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forPlayerPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forTeamActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forWorldActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  rewardPlayer?: InputMaybe<IntFieldUpdateOperationsInput>;
  rewardTeam?: InputMaybe<IntFieldUpdateOperationsInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ActionUpdateWithoutEventWorldActionsInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventPlayerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutActionNestedInput>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutActionNestedInput>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutActionNestedInput>;
  forPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forPlayerPlayerActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forTeamActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  forWorldActions?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  rewardPlayer?: InputMaybe<IntFieldUpdateOperationsInput>;
  rewardTeam?: InputMaybe<IntFieldUpdateOperationsInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ActionUpsertWithoutEventPlayerActionsInput = {
  create: ActionCreateWithoutEventPlayerActionsInput;
  update: ActionUpdateWithoutEventPlayerActionsInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionUpsertWithoutEventPlayerPlayerActionsInput = {
  create: ActionCreateWithoutEventPlayerPlayerActionsInput;
  update: ActionUpdateWithoutEventPlayerPlayerActionsInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionUpsertWithoutEventTeamBonusesInput = {
  create: ActionCreateWithoutEventTeamBonusesInput;
  update: ActionUpdateWithoutEventTeamBonusesInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionUpsertWithoutEventWorldActionsInput = {
  create: ActionCreateWithoutEventWorldActionsInput;
  update: ActionUpdateWithoutEventWorldActionsInput;
  where?: InputMaybe<ActionWhereInput>;
};

export type ActionWhereInput = {
  AND?: InputMaybe<Array<ActionWhereInput>>;
  NOT?: InputMaybe<Array<ActionWhereInput>>;
  OR?: InputMaybe<Array<ActionWhereInput>>;
  code?: InputMaybe<StringFilter>;
  count?: InputMaybe<IntFilter>;
  description?: InputMaybe<StringNullableFilter>;
  eventPlayerActions?: InputMaybe<EventPlayerActionListRelationFilter>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusListRelationFilter>;
  eventWorldActions?: InputMaybe<EventWorldActionListRelationFilter>;
  forPlayerActions?: InputMaybe<StringFilter>;
  forPlayerPlayerActions?: InputMaybe<StringFilter>;
  forTeamActions?: InputMaybe<StringFilter>;
  forWorldActions?: InputMaybe<StringFilter>;
  game?: InputMaybe<StringFilter>;
  id?: InputMaybe<IntFilter>;
  rewardPlayer?: InputMaybe<IntFilter>;
  rewardTeam?: InputMaybe<IntFilter>;
  team?: InputMaybe<StringFilter>;
};

export type ActionWhereUniqueInput = {
  AND?: InputMaybe<Array<ActionWhereInput>>;
  NOT?: InputMaybe<Array<ActionWhereInput>>;
  OR?: InputMaybe<Array<ActionWhereInput>>;
  code?: InputMaybe<StringFilter>;
  count?: InputMaybe<IntFilter>;
  description?: InputMaybe<StringNullableFilter>;
  eventPlayerActions?: InputMaybe<EventPlayerActionListRelationFilter>;
  eventPlayerPlayerActions?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  eventTeamBonuses?: InputMaybe<EventTeamBonusListRelationFilter>;
  eventWorldActions?: InputMaybe<EventWorldActionListRelationFilter>;
  forPlayerActions?: InputMaybe<StringFilter>;
  forPlayerPlayerActions?: InputMaybe<StringFilter>;
  forTeamActions?: InputMaybe<StringFilter>;
  forWorldActions?: InputMaybe<StringFilter>;
  game?: InputMaybe<StringFilter>;
  gamecode?: InputMaybe<ActionGamecodeCompoundUniqueInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  rewardPlayer?: InputMaybe<IntFilter>;
  rewardTeam?: InputMaybe<IntFilter>;
  team?: InputMaybe<StringFilter>;
};

export type Award = {
  __typename?: 'Award';
  awardId: Scalars['ID']['output'];
  awardType: Scalars['String']['output'];
  code: Scalars['String']['output'];
  dWinner?: Maybe<Player>;
  dWinnerCount?: Maybe<Scalars['Int']['output']>;
  dWinnerId?: Maybe<Scalars['Int']['output']>;
  gWinner?: Maybe<Player>;
  gWinnerCount?: Maybe<Scalars['Int']['output']>;
  gWinnerId?: Maybe<Scalars['Int']['output']>;
  game: Scalars['String']['output'];
  name: Scalars['String']['output'];
  playerAwards: Array<PlayerAward>;
  verb: Scalars['String']['output'];
};


export type AwardPlayerAwardsArgs = {
  cursor?: InputMaybe<PlayerAwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerAwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerAwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerAwardWhereInput>;
};

export type AwardAvgOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  dWinnerCount?: InputMaybe<SortOrder>;
  dWinnerId?: InputMaybe<SortOrder>;
  gWinnerCount?: InputMaybe<SortOrder>;
  gWinnerId?: InputMaybe<SortOrder>;
};

export type AwardCountOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  awardType?: InputMaybe<SortOrder>;
  code?: InputMaybe<SortOrder>;
  dWinnerCount?: InputMaybe<SortOrder>;
  dWinnerId?: InputMaybe<SortOrder>;
  gWinnerCount?: InputMaybe<SortOrder>;
  gWinnerId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  verb?: InputMaybe<SortOrder>;
};

export type AwardCreateInput = {
  awardType?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dWinner?: InputMaybe<PlayerCreateNestedOneWithoutAwardsWonAsDWinnerInput>;
  dWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  gWinner?: InputMaybe<PlayerCreateNestedOneWithoutAwardsWonAsGWinnerInput>;
  gWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  playerAwards?: InputMaybe<PlayerAwardCreateNestedManyWithoutAwardInput>;
  verb?: InputMaybe<Scalars['String']['input']>;
};

export type AwardCreateManyDWinnerInput = {
  awardId?: InputMaybe<Scalars['Int']['input']>;
  awardType?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  gWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  gWinnerId?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  verb?: InputMaybe<Scalars['String']['input']>;
};

export type AwardCreateManyDWinnerInputEnvelope = {
  data: Array<AwardCreateManyDWinnerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AwardCreateManyGWinnerInput = {
  awardId?: InputMaybe<Scalars['Int']['input']>;
  awardType?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  dWinnerId?: InputMaybe<Scalars['Int']['input']>;
  gWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  verb?: InputMaybe<Scalars['String']['input']>;
};

export type AwardCreateManyGWinnerInputEnvelope = {
  data: Array<AwardCreateManyGWinnerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AwardCreateManyInput = {
  awardId?: InputMaybe<Scalars['Int']['input']>;
  awardType?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  dWinnerId?: InputMaybe<Scalars['Int']['input']>;
  gWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  gWinnerId?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  verb?: InputMaybe<Scalars['String']['input']>;
};

export type AwardCreateNestedManyWithoutDWinnerInput = {
  connect?: InputMaybe<Array<AwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AwardCreateOrConnectWithoutDWinnerInput>>;
  create?: InputMaybe<Array<AwardCreateWithoutDWinnerInput>>;
  createMany?: InputMaybe<AwardCreateManyDWinnerInputEnvelope>;
};

export type AwardCreateNestedManyWithoutGWinnerInput = {
  connect?: InputMaybe<Array<AwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AwardCreateOrConnectWithoutGWinnerInput>>;
  create?: InputMaybe<Array<AwardCreateWithoutGWinnerInput>>;
  createMany?: InputMaybe<AwardCreateManyGWinnerInputEnvelope>;
};

export type AwardCreateNestedOneWithoutPlayerAwardsInput = {
  connect?: InputMaybe<AwardWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AwardCreateOrConnectWithoutPlayerAwardsInput>;
  create?: InputMaybe<AwardCreateWithoutPlayerAwardsInput>;
};

export type AwardCreateOrConnectWithoutDWinnerInput = {
  create: AwardCreateWithoutDWinnerInput;
  where: AwardWhereUniqueInput;
};

export type AwardCreateOrConnectWithoutGWinnerInput = {
  create: AwardCreateWithoutGWinnerInput;
  where: AwardWhereUniqueInput;
};

export type AwardCreateOrConnectWithoutPlayerAwardsInput = {
  create: AwardCreateWithoutPlayerAwardsInput;
  where: AwardWhereUniqueInput;
};

export type AwardCreateWithoutDWinnerInput = {
  awardType?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  gWinner?: InputMaybe<PlayerCreateNestedOneWithoutAwardsWonAsGWinnerInput>;
  gWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  playerAwards?: InputMaybe<PlayerAwardCreateNestedManyWithoutAwardInput>;
  verb?: InputMaybe<Scalars['String']['input']>;
};

export type AwardCreateWithoutGWinnerInput = {
  awardType?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dWinner?: InputMaybe<PlayerCreateNestedOneWithoutAwardsWonAsDWinnerInput>;
  dWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  gWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  playerAwards?: InputMaybe<PlayerAwardCreateNestedManyWithoutAwardInput>;
  verb?: InputMaybe<Scalars['String']['input']>;
};

export type AwardCreateWithoutPlayerAwardsInput = {
  awardType?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dWinner?: InputMaybe<PlayerCreateNestedOneWithoutAwardsWonAsDWinnerInput>;
  dWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  gWinner?: InputMaybe<PlayerCreateNestedOneWithoutAwardsWonAsGWinnerInput>;
  gWinnerCount?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  verb?: InputMaybe<Scalars['String']['input']>;
};

export type AwardGame_AwardType_CodeCompoundUniqueInput = {
  awardType: Scalars['String']['input'];
  code: Scalars['String']['input'];
  game: Scalars['String']['input'];
};

export type AwardListRelationFilter = {
  every?: InputMaybe<AwardWhereInput>;
  none?: InputMaybe<AwardWhereInput>;
  some?: InputMaybe<AwardWhereInput>;
};

export type AwardMaxOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  awardType?: InputMaybe<SortOrder>;
  code?: InputMaybe<SortOrder>;
  dWinnerCount?: InputMaybe<SortOrder>;
  dWinnerId?: InputMaybe<SortOrder>;
  gWinnerCount?: InputMaybe<SortOrder>;
  gWinnerId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  verb?: InputMaybe<SortOrder>;
};

export type AwardMinOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  awardType?: InputMaybe<SortOrder>;
  code?: InputMaybe<SortOrder>;
  dWinnerCount?: InputMaybe<SortOrder>;
  dWinnerId?: InputMaybe<SortOrder>;
  gWinnerCount?: InputMaybe<SortOrder>;
  gWinnerId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  verb?: InputMaybe<SortOrder>;
};

export type AwardOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum AwardOrderByRelevanceFieldEnum {
  AwardType = 'awardType',
  Code = 'code',
  Game = 'game',
  Name = 'name',
  Verb = 'verb'
}

export type AwardOrderByRelevanceInput = {
  fields: Array<AwardOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type AwardOrderByWithAggregationInput = {
  _avg?: InputMaybe<AwardAvgOrderByAggregateInput>;
  _count?: InputMaybe<AwardCountOrderByAggregateInput>;
  _max?: InputMaybe<AwardMaxOrderByAggregateInput>;
  _min?: InputMaybe<AwardMinOrderByAggregateInput>;
  _sum?: InputMaybe<AwardSumOrderByAggregateInput>;
  awardId?: InputMaybe<SortOrder>;
  awardType?: InputMaybe<SortOrder>;
  code?: InputMaybe<SortOrder>;
  dWinnerCount?: InputMaybe<SortOrder>;
  dWinnerId?: InputMaybe<SortOrder>;
  gWinnerCount?: InputMaybe<SortOrder>;
  gWinnerId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  verb?: InputMaybe<SortOrder>;
};

export type AwardOrderByWithRelationInput = {
  _relevance?: InputMaybe<AwardOrderByRelevanceInput>;
  awardId?: InputMaybe<SortOrder>;
  awardType?: InputMaybe<SortOrder>;
  code?: InputMaybe<SortOrder>;
  dWinner?: InputMaybe<PlayerOrderByWithRelationInput>;
  dWinnerCount?: InputMaybe<SortOrder>;
  dWinnerId?: InputMaybe<SortOrder>;
  gWinner?: InputMaybe<PlayerOrderByWithRelationInput>;
  gWinnerCount?: InputMaybe<SortOrder>;
  gWinnerId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  playerAwards?: InputMaybe<PlayerAwardOrderByRelationAggregateInput>;
  verb?: InputMaybe<SortOrder>;
};

export enum AwardScalarFieldEnum {
  AwardId = 'awardId',
  AwardType = 'awardType',
  Code = 'code',
  DWinnerCount = 'dWinnerCount',
  DWinnerId = 'dWinnerId',
  GWinnerCount = 'gWinnerCount',
  GWinnerId = 'gWinnerId',
  Game = 'game',
  Name = 'name',
  Verb = 'verb'
}

export type AwardScalarRelationFilter = {
  is?: InputMaybe<AwardWhereInput>;
  isNot?: InputMaybe<AwardWhereInput>;
};

export type AwardScalarWhereInput = {
  AND?: InputMaybe<Array<AwardScalarWhereInput>>;
  NOT?: InputMaybe<Array<AwardScalarWhereInput>>;
  OR?: InputMaybe<Array<AwardScalarWhereInput>>;
  awardId?: InputMaybe<IntFilter>;
  awardType?: InputMaybe<StringFilter>;
  code?: InputMaybe<StringFilter>;
  dWinnerCount?: InputMaybe<IntNullableFilter>;
  dWinnerId?: InputMaybe<IntNullableFilter>;
  gWinnerCount?: InputMaybe<IntNullableFilter>;
  gWinnerId?: InputMaybe<IntNullableFilter>;
  game?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  verb?: InputMaybe<StringFilter>;
};

export type AwardScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<AwardScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<AwardScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<AwardScalarWhereWithAggregatesInput>>;
  awardId?: InputMaybe<IntWithAggregatesFilter>;
  awardType?: InputMaybe<StringWithAggregatesFilter>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  dWinnerCount?: InputMaybe<IntNullableWithAggregatesFilter>;
  dWinnerId?: InputMaybe<IntNullableWithAggregatesFilter>;
  gWinnerCount?: InputMaybe<IntNullableWithAggregatesFilter>;
  gWinnerId?: InputMaybe<IntNullableWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  verb?: InputMaybe<StringWithAggregatesFilter>;
};

export type AwardSumOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  dWinnerCount?: InputMaybe<SortOrder>;
  dWinnerId?: InputMaybe<SortOrder>;
  gWinnerCount?: InputMaybe<SortOrder>;
  gWinnerId?: InputMaybe<SortOrder>;
};

export type AwardUpdateInput = {
  awardType?: InputMaybe<StringFieldUpdateOperationsInput>;
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  dWinner?: InputMaybe<PlayerUpdateOneWithoutAwardsWonAsDWinnerNestedInput>;
  dWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  gWinner?: InputMaybe<PlayerUpdateOneWithoutAwardsWonAsGWinnerNestedInput>;
  gWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerAwards?: InputMaybe<PlayerAwardUpdateManyWithoutAwardNestedInput>;
  verb?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type AwardUpdateManyMutationInput = {
  awardType?: InputMaybe<StringFieldUpdateOperationsInput>;
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  dWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  gWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  verb?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type AwardUpdateManyWithWhereWithoutDWinnerInput = {
  data: AwardUpdateManyMutationInput;
  where: AwardScalarWhereInput;
};

export type AwardUpdateManyWithWhereWithoutGWinnerInput = {
  data: AwardUpdateManyMutationInput;
  where: AwardScalarWhereInput;
};

export type AwardUpdateManyWithoutDWinnerNestedInput = {
  connect?: InputMaybe<Array<AwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AwardCreateOrConnectWithoutDWinnerInput>>;
  create?: InputMaybe<Array<AwardCreateWithoutDWinnerInput>>;
  createMany?: InputMaybe<AwardCreateManyDWinnerInputEnvelope>;
  delete?: InputMaybe<Array<AwardWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<AwardScalarWhereInput>>;
  disconnect?: InputMaybe<Array<AwardWhereUniqueInput>>;
  set?: InputMaybe<Array<AwardWhereUniqueInput>>;
  update?: InputMaybe<Array<AwardUpdateWithWhereUniqueWithoutDWinnerInput>>;
  updateMany?: InputMaybe<Array<AwardUpdateManyWithWhereWithoutDWinnerInput>>;
  upsert?: InputMaybe<Array<AwardUpsertWithWhereUniqueWithoutDWinnerInput>>;
};

export type AwardUpdateManyWithoutGWinnerNestedInput = {
  connect?: InputMaybe<Array<AwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AwardCreateOrConnectWithoutGWinnerInput>>;
  create?: InputMaybe<Array<AwardCreateWithoutGWinnerInput>>;
  createMany?: InputMaybe<AwardCreateManyGWinnerInputEnvelope>;
  delete?: InputMaybe<Array<AwardWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<AwardScalarWhereInput>>;
  disconnect?: InputMaybe<Array<AwardWhereUniqueInput>>;
  set?: InputMaybe<Array<AwardWhereUniqueInput>>;
  update?: InputMaybe<Array<AwardUpdateWithWhereUniqueWithoutGWinnerInput>>;
  updateMany?: InputMaybe<Array<AwardUpdateManyWithWhereWithoutGWinnerInput>>;
  upsert?: InputMaybe<Array<AwardUpsertWithWhereUniqueWithoutGWinnerInput>>;
};

export type AwardUpdateOneRequiredWithoutPlayerAwardsNestedInput = {
  connect?: InputMaybe<AwardWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AwardCreateOrConnectWithoutPlayerAwardsInput>;
  create?: InputMaybe<AwardCreateWithoutPlayerAwardsInput>;
  update?: InputMaybe<AwardUpdateToOneWithWhereWithoutPlayerAwardsInput>;
  upsert?: InputMaybe<AwardUpsertWithoutPlayerAwardsInput>;
};

export type AwardUpdateToOneWithWhereWithoutPlayerAwardsInput = {
  data: AwardUpdateWithoutPlayerAwardsInput;
  where?: InputMaybe<AwardWhereInput>;
};

export type AwardUpdateWithWhereUniqueWithoutDWinnerInput = {
  data: AwardUpdateWithoutDWinnerInput;
  where: AwardWhereUniqueInput;
};

export type AwardUpdateWithWhereUniqueWithoutGWinnerInput = {
  data: AwardUpdateWithoutGWinnerInput;
  where: AwardWhereUniqueInput;
};

export type AwardUpdateWithoutDWinnerInput = {
  awardType?: InputMaybe<StringFieldUpdateOperationsInput>;
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  dWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  gWinner?: InputMaybe<PlayerUpdateOneWithoutAwardsWonAsGWinnerNestedInput>;
  gWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerAwards?: InputMaybe<PlayerAwardUpdateManyWithoutAwardNestedInput>;
  verb?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type AwardUpdateWithoutGWinnerInput = {
  awardType?: InputMaybe<StringFieldUpdateOperationsInput>;
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  dWinner?: InputMaybe<PlayerUpdateOneWithoutAwardsWonAsDWinnerNestedInput>;
  dWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  gWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerAwards?: InputMaybe<PlayerAwardUpdateManyWithoutAwardNestedInput>;
  verb?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type AwardUpdateWithoutPlayerAwardsInput = {
  awardType?: InputMaybe<StringFieldUpdateOperationsInput>;
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  dWinner?: InputMaybe<PlayerUpdateOneWithoutAwardsWonAsDWinnerNestedInput>;
  dWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  gWinner?: InputMaybe<PlayerUpdateOneWithoutAwardsWonAsGWinnerNestedInput>;
  gWinnerCount?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  verb?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type AwardUpsertWithWhereUniqueWithoutDWinnerInput = {
  create: AwardCreateWithoutDWinnerInput;
  update: AwardUpdateWithoutDWinnerInput;
  where: AwardWhereUniqueInput;
};

export type AwardUpsertWithWhereUniqueWithoutGWinnerInput = {
  create: AwardCreateWithoutGWinnerInput;
  update: AwardUpdateWithoutGWinnerInput;
  where: AwardWhereUniqueInput;
};

export type AwardUpsertWithoutPlayerAwardsInput = {
  create: AwardCreateWithoutPlayerAwardsInput;
  update: AwardUpdateWithoutPlayerAwardsInput;
  where?: InputMaybe<AwardWhereInput>;
};

export type AwardWhereInput = {
  AND?: InputMaybe<Array<AwardWhereInput>>;
  NOT?: InputMaybe<Array<AwardWhereInput>>;
  OR?: InputMaybe<Array<AwardWhereInput>>;
  awardId?: InputMaybe<IntFilter>;
  awardType?: InputMaybe<StringFilter>;
  code?: InputMaybe<StringFilter>;
  dWinner?: InputMaybe<PlayerWhereInput>;
  dWinnerCount?: InputMaybe<IntNullableFilter>;
  dWinnerId?: InputMaybe<IntNullableFilter>;
  gWinner?: InputMaybe<PlayerWhereInput>;
  gWinnerCount?: InputMaybe<IntNullableFilter>;
  gWinnerId?: InputMaybe<IntNullableFilter>;
  game?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  playerAwards?: InputMaybe<PlayerAwardListRelationFilter>;
  verb?: InputMaybe<StringFilter>;
};

export type AwardWhereUniqueInput = {
  AND?: InputMaybe<Array<AwardWhereInput>>;
  NOT?: InputMaybe<Array<AwardWhereInput>>;
  OR?: InputMaybe<Array<AwardWhereInput>>;
  awardId?: InputMaybe<Scalars['Int']['input']>;
  awardType?: InputMaybe<StringFilter>;
  code?: InputMaybe<StringFilter>;
  dWinner?: InputMaybe<PlayerWhereInput>;
  dWinnerCount?: InputMaybe<IntNullableFilter>;
  dWinnerId?: InputMaybe<IntNullableFilter>;
  gWinner?: InputMaybe<PlayerWhereInput>;
  gWinnerCount?: InputMaybe<IntNullableFilter>;
  gWinnerId?: InputMaybe<IntNullableFilter>;
  game?: InputMaybe<StringFilter>;
  game_awardType_code?: InputMaybe<AwardGame_AwardType_CodeCompoundUniqueInput>;
  name?: InputMaybe<StringFilter>;
  playerAwards?: InputMaybe<PlayerAwardListRelationFilter>;
  verb?: InputMaybe<StringFilter>;
};

/** Batch payloads from prisma. */
export type BatchPayload = {
  __typename?: 'BatchPayload';
  /** Prisma Batch Payload */
  count: Scalars['Int']['output'];
};

export type BigIntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['BigInt']['input']>;
  divide?: InputMaybe<Scalars['BigInt']['input']>;
  increment?: InputMaybe<Scalars['BigInt']['input']>;
  multiply?: InputMaybe<Scalars['BigInt']['input']>;
  set?: InputMaybe<Scalars['BigInt']['input']>;
};

export type BigIntFilter = {
  equals?: InputMaybe<Scalars['BigInt']['input']>;
  gt?: InputMaybe<Scalars['BigInt']['input']>;
  gte?: InputMaybe<Scalars['BigInt']['input']>;
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  lt?: InputMaybe<Scalars['BigInt']['input']>;
  lte?: InputMaybe<Scalars['BigInt']['input']>;
  not?: InputMaybe<NestedBigIntFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export type BigIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBigIntFilter>;
  _min?: InputMaybe<NestedBigIntFilter>;
  _sum?: InputMaybe<NestedBigIntFilter>;
  equals?: InputMaybe<Scalars['BigInt']['input']>;
  gt?: InputMaybe<Scalars['BigInt']['input']>;
  gte?: InputMaybe<Scalars['BigInt']['input']>;
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  lt?: InputMaybe<Scalars['BigInt']['input']>;
  lte?: InputMaybe<Scalars['BigInt']['input']>;
  not?: InputMaybe<NestedBigIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export type BoolFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type BoolNullableFilter = {
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolNullableFilter>;
};

export type BoolNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBoolNullableFilter>;
  _min?: InputMaybe<NestedBoolNullableFilter>;
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolNullableWithAggregatesFilter>;
};

export type BoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type Clan = {
  __typename?: 'Clan';
  clanId: Scalars['ID']['output'];
  game: Scalars['String']['output'];
  gameData: Game;
  hidden: Scalars['Int']['output'];
  homepage: Scalars['String']['output'];
  mapregion: Scalars['String']['output'];
  name: Scalars['String']['output'];
  players: Array<Player>;
  tag: Scalars['String']['output'];
};


export type ClanPlayersArgs = {
  cursor?: InputMaybe<PlayerWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerWhereInput>;
};

export type ClanAvgOrderByAggregateInput = {
  clanId?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
};

export type ClanCountOrderByAggregateInput = {
  clanId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  homepage?: InputMaybe<SortOrder>;
  mapregion?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  tag?: InputMaybe<SortOrder>;
};

export type ClanCreateInput = {
  gameData?: InputMaybe<GameCreateNestedOneWithoutClansInput>;
  hidden?: InputMaybe<Scalars['Int']['input']>;
  homepage?: InputMaybe<Scalars['String']['input']>;
  mapregion?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  players?: InputMaybe<PlayerCreateNestedManyWithoutClanInput>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

export type ClanCreateManyGameDataInput = {
  clanId?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Int']['input']>;
  homepage?: InputMaybe<Scalars['String']['input']>;
  mapregion?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

export type ClanCreateManyGameDataInputEnvelope = {
  data: Array<ClanCreateManyGameDataInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ClanCreateManyInput = {
  clanId?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<Scalars['Int']['input']>;
  homepage?: InputMaybe<Scalars['String']['input']>;
  mapregion?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

export type ClanCreateNestedManyWithoutGameDataInput = {
  connect?: InputMaybe<Array<ClanWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ClanCreateOrConnectWithoutGameDataInput>>;
  create?: InputMaybe<Array<ClanCreateWithoutGameDataInput>>;
  createMany?: InputMaybe<ClanCreateManyGameDataInputEnvelope>;
};

export type ClanCreateNestedOneWithoutPlayersInput = {
  connect?: InputMaybe<ClanWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ClanCreateOrConnectWithoutPlayersInput>;
  create?: InputMaybe<ClanCreateWithoutPlayersInput>;
};

export type ClanCreateOrConnectWithoutGameDataInput = {
  create: ClanCreateWithoutGameDataInput;
  where: ClanWhereUniqueInput;
};

export type ClanCreateOrConnectWithoutPlayersInput = {
  create: ClanCreateWithoutPlayersInput;
  where: ClanWhereUniqueInput;
};

export type ClanCreateWithoutGameDataInput = {
  hidden?: InputMaybe<Scalars['Int']['input']>;
  homepage?: InputMaybe<Scalars['String']['input']>;
  mapregion?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  players?: InputMaybe<PlayerCreateNestedManyWithoutClanInput>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

export type ClanCreateWithoutPlayersInput = {
  gameData?: InputMaybe<GameCreateNestedOneWithoutClansInput>;
  hidden?: InputMaybe<Scalars['Int']['input']>;
  homepage?: InputMaybe<Scalars['String']['input']>;
  mapregion?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

export type ClanGame_TagCompoundUniqueInput = {
  game: Scalars['String']['input'];
  tag: Scalars['String']['input'];
};

export type ClanListRelationFilter = {
  every?: InputMaybe<ClanWhereInput>;
  none?: InputMaybe<ClanWhereInput>;
  some?: InputMaybe<ClanWhereInput>;
};

export type ClanMaxOrderByAggregateInput = {
  clanId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  homepage?: InputMaybe<SortOrder>;
  mapregion?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  tag?: InputMaybe<SortOrder>;
};

export type ClanMinOrderByAggregateInput = {
  clanId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  homepage?: InputMaybe<SortOrder>;
  mapregion?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  tag?: InputMaybe<SortOrder>;
};

export type ClanNullableScalarRelationFilter = {
  is?: InputMaybe<ClanWhereInput>;
  isNot?: InputMaybe<ClanWhereInput>;
};

export type ClanOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum ClanOrderByRelevanceFieldEnum {
  Game = 'game',
  Homepage = 'homepage',
  Mapregion = 'mapregion',
  Name = 'name',
  Tag = 'tag'
}

export type ClanOrderByRelevanceInput = {
  fields: Array<ClanOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ClanOrderByWithAggregationInput = {
  _avg?: InputMaybe<ClanAvgOrderByAggregateInput>;
  _count?: InputMaybe<ClanCountOrderByAggregateInput>;
  _max?: InputMaybe<ClanMaxOrderByAggregateInput>;
  _min?: InputMaybe<ClanMinOrderByAggregateInput>;
  _sum?: InputMaybe<ClanSumOrderByAggregateInput>;
  clanId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  homepage?: InputMaybe<SortOrder>;
  mapregion?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  tag?: InputMaybe<SortOrder>;
};

export type ClanOrderByWithRelationInput = {
  _relevance?: InputMaybe<ClanOrderByRelevanceInput>;
  clanId?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  gameData?: InputMaybe<GameOrderByWithRelationInput>;
  hidden?: InputMaybe<SortOrder>;
  homepage?: InputMaybe<SortOrder>;
  mapregion?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  players?: InputMaybe<PlayerOrderByRelationAggregateInput>;
  tag?: InputMaybe<SortOrder>;
};

export enum ClanScalarFieldEnum {
  ClanId = 'clanId',
  Game = 'game',
  Hidden = 'hidden',
  Homepage = 'homepage',
  Mapregion = 'mapregion',
  Name = 'name',
  Tag = 'tag'
}

export type ClanScalarWhereInput = {
  AND?: InputMaybe<Array<ClanScalarWhereInput>>;
  NOT?: InputMaybe<Array<ClanScalarWhereInput>>;
  OR?: InputMaybe<Array<ClanScalarWhereInput>>;
  clanId?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  hidden?: InputMaybe<IntFilter>;
  homepage?: InputMaybe<StringFilter>;
  mapregion?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  tag?: InputMaybe<StringFilter>;
};

export type ClanScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ClanScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ClanScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ClanScalarWhereWithAggregatesInput>>;
  clanId?: InputMaybe<IntWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  hidden?: InputMaybe<IntWithAggregatesFilter>;
  homepage?: InputMaybe<StringWithAggregatesFilter>;
  mapregion?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  tag?: InputMaybe<StringWithAggregatesFilter>;
};

export type ClanSumOrderByAggregateInput = {
  clanId?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
};

export type ClanTag = {
  __typename?: 'ClanTag';
  id: Scalars['ID']['output'];
  pattern: Scalars['String']['output'];
  position: ClanTagPosition;
};

export type ClanTagAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
};

export type ClanTagCountOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  pattern?: InputMaybe<SortOrder>;
  position?: InputMaybe<SortOrder>;
};

export type ClanTagCreateInput = {
  pattern: Scalars['String']['input'];
  position?: InputMaybe<ClanTagPosition>;
};

export type ClanTagCreateManyInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  pattern: Scalars['String']['input'];
  position?: InputMaybe<ClanTagPosition>;
};

export type ClanTagMaxOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  pattern?: InputMaybe<SortOrder>;
  position?: InputMaybe<SortOrder>;
};

export type ClanTagMinOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  pattern?: InputMaybe<SortOrder>;
  position?: InputMaybe<SortOrder>;
};

export enum ClanTagOrderByRelevanceFieldEnum {
  Pattern = 'pattern'
}

export type ClanTagOrderByRelevanceInput = {
  fields: Array<ClanTagOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ClanTagOrderByWithAggregationInput = {
  _avg?: InputMaybe<ClanTagAvgOrderByAggregateInput>;
  _count?: InputMaybe<ClanTagCountOrderByAggregateInput>;
  _max?: InputMaybe<ClanTagMaxOrderByAggregateInput>;
  _min?: InputMaybe<ClanTagMinOrderByAggregateInput>;
  _sum?: InputMaybe<ClanTagSumOrderByAggregateInput>;
  id?: InputMaybe<SortOrder>;
  pattern?: InputMaybe<SortOrder>;
  position?: InputMaybe<SortOrder>;
};

export type ClanTagOrderByWithRelationInput = {
  _relevance?: InputMaybe<ClanTagOrderByRelevanceInput>;
  id?: InputMaybe<SortOrder>;
  pattern?: InputMaybe<SortOrder>;
  position?: InputMaybe<SortOrder>;
};

export enum ClanTagPosition {
  Either = 'EITHER',
  End = 'END',
  Start = 'START'
}

export enum ClanTagScalarFieldEnum {
  Id = 'id',
  Pattern = 'pattern',
  Position = 'position'
}

export type ClanTagScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ClanTagScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ClanTagScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ClanTagScalarWhereWithAggregatesInput>>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  pattern?: InputMaybe<StringWithAggregatesFilter>;
  position?: InputMaybe<EnumClanTagPositionWithAggregatesFilter>;
};

export type ClanTagSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
};

export type ClanTagUpdateInput = {
  pattern?: InputMaybe<StringFieldUpdateOperationsInput>;
  position?: InputMaybe<EnumClanTagPositionFieldUpdateOperationsInput>;
};

export type ClanTagUpdateManyMutationInput = {
  pattern?: InputMaybe<StringFieldUpdateOperationsInput>;
  position?: InputMaybe<EnumClanTagPositionFieldUpdateOperationsInput>;
};

export type ClanTagWhereInput = {
  AND?: InputMaybe<Array<ClanTagWhereInput>>;
  NOT?: InputMaybe<Array<ClanTagWhereInput>>;
  OR?: InputMaybe<Array<ClanTagWhereInput>>;
  id?: InputMaybe<IntFilter>;
  pattern?: InputMaybe<StringFilter>;
  position?: InputMaybe<EnumClanTagPositionFilter>;
};

export type ClanTagWhereUniqueInput = {
  AND?: InputMaybe<Array<ClanTagWhereInput>>;
  NOT?: InputMaybe<Array<ClanTagWhereInput>>;
  OR?: InputMaybe<Array<ClanTagWhereInput>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  pattern?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<EnumClanTagPositionFilter>;
};

export type ClanUpdateInput = {
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutClansNestedInput>;
  hidden?: InputMaybe<IntFieldUpdateOperationsInput>;
  homepage?: InputMaybe<StringFieldUpdateOperationsInput>;
  mapregion?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  players?: InputMaybe<PlayerUpdateManyWithoutClanNestedInput>;
  tag?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ClanUpdateManyMutationInput = {
  hidden?: InputMaybe<IntFieldUpdateOperationsInput>;
  homepage?: InputMaybe<StringFieldUpdateOperationsInput>;
  mapregion?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  tag?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ClanUpdateManyWithWhereWithoutGameDataInput = {
  data: ClanUpdateManyMutationInput;
  where: ClanScalarWhereInput;
};

export type ClanUpdateManyWithoutGameDataNestedInput = {
  connect?: InputMaybe<Array<ClanWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ClanCreateOrConnectWithoutGameDataInput>>;
  create?: InputMaybe<Array<ClanCreateWithoutGameDataInput>>;
  createMany?: InputMaybe<ClanCreateManyGameDataInputEnvelope>;
  delete?: InputMaybe<Array<ClanWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ClanScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ClanWhereUniqueInput>>;
  set?: InputMaybe<Array<ClanWhereUniqueInput>>;
  update?: InputMaybe<Array<ClanUpdateWithWhereUniqueWithoutGameDataInput>>;
  updateMany?: InputMaybe<Array<ClanUpdateManyWithWhereWithoutGameDataInput>>;
  upsert?: InputMaybe<Array<ClanUpsertWithWhereUniqueWithoutGameDataInput>>;
};

export type ClanUpdateOneWithoutPlayersNestedInput = {
  connect?: InputMaybe<ClanWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ClanCreateOrConnectWithoutPlayersInput>;
  create?: InputMaybe<ClanCreateWithoutPlayersInput>;
  delete?: InputMaybe<ClanWhereInput>;
  disconnect?: InputMaybe<ClanWhereInput>;
  update?: InputMaybe<ClanUpdateToOneWithWhereWithoutPlayersInput>;
  upsert?: InputMaybe<ClanUpsertWithoutPlayersInput>;
};

export type ClanUpdateToOneWithWhereWithoutPlayersInput = {
  data: ClanUpdateWithoutPlayersInput;
  where?: InputMaybe<ClanWhereInput>;
};

export type ClanUpdateWithWhereUniqueWithoutGameDataInput = {
  data: ClanUpdateWithoutGameDataInput;
  where: ClanWhereUniqueInput;
};

export type ClanUpdateWithoutGameDataInput = {
  hidden?: InputMaybe<IntFieldUpdateOperationsInput>;
  homepage?: InputMaybe<StringFieldUpdateOperationsInput>;
  mapregion?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  players?: InputMaybe<PlayerUpdateManyWithoutClanNestedInput>;
  tag?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ClanUpdateWithoutPlayersInput = {
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutClansNestedInput>;
  hidden?: InputMaybe<IntFieldUpdateOperationsInput>;
  homepage?: InputMaybe<StringFieldUpdateOperationsInput>;
  mapregion?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  tag?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ClanUpsertWithWhereUniqueWithoutGameDataInput = {
  create: ClanCreateWithoutGameDataInput;
  update: ClanUpdateWithoutGameDataInput;
  where: ClanWhereUniqueInput;
};

export type ClanUpsertWithoutPlayersInput = {
  create: ClanCreateWithoutPlayersInput;
  update: ClanUpdateWithoutPlayersInput;
  where?: InputMaybe<ClanWhereInput>;
};

export type ClanWhereInput = {
  AND?: InputMaybe<Array<ClanWhereInput>>;
  NOT?: InputMaybe<Array<ClanWhereInput>>;
  OR?: InputMaybe<Array<ClanWhereInput>>;
  clanId?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  gameData?: InputMaybe<GameWhereInput>;
  hidden?: InputMaybe<IntFilter>;
  homepage?: InputMaybe<StringFilter>;
  mapregion?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  players?: InputMaybe<PlayerListRelationFilter>;
  tag?: InputMaybe<StringFilter>;
};

export type ClanWhereUniqueInput = {
  AND?: InputMaybe<Array<ClanWhereInput>>;
  NOT?: InputMaybe<Array<ClanWhereInput>>;
  OR?: InputMaybe<Array<ClanWhereInput>>;
  clanId?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<StringFilter>;
  gameData?: InputMaybe<GameWhereInput>;
  game_tag?: InputMaybe<ClanGame_TagCompoundUniqueInput>;
  hidden?: InputMaybe<IntFilter>;
  homepage?: InputMaybe<StringFilter>;
  mapregion?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  players?: InputMaybe<PlayerListRelationFilter>;
  tag?: InputMaybe<StringFilter>;
};

export type Country = {
  __typename?: 'Country';
  flag: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  players: Array<Player>;
};


export type CountryPlayersArgs = {
  cursor?: InputMaybe<PlayerWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerWhereInput>;
};

export type CountryCountOrderByAggregateInput = {
  flag?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type CountryCreateInput = {
  flag: Scalars['String']['input'];
  name: Scalars['String']['input'];
  players?: InputMaybe<PlayerCreateNestedManyWithoutCountryDataInput>;
};

export type CountryCreateManyInput = {
  flag: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type CountryCreateNestedOneWithoutPlayersInput = {
  connect?: InputMaybe<CountryWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CountryCreateOrConnectWithoutPlayersInput>;
  create?: InputMaybe<CountryCreateWithoutPlayersInput>;
};

export type CountryCreateOrConnectWithoutPlayersInput = {
  create: CountryCreateWithoutPlayersInput;
  where: CountryWhereUniqueInput;
};

export type CountryCreateWithoutPlayersInput = {
  flag: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type CountryMaxOrderByAggregateInput = {
  flag?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type CountryMinOrderByAggregateInput = {
  flag?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type CountryNullableScalarRelationFilter = {
  is?: InputMaybe<CountryWhereInput>;
  isNot?: InputMaybe<CountryWhereInput>;
};

export enum CountryOrderByRelevanceFieldEnum {
  Flag = 'flag',
  Name = 'name'
}

export type CountryOrderByRelevanceInput = {
  fields: Array<CountryOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type CountryOrderByWithAggregationInput = {
  _count?: InputMaybe<CountryCountOrderByAggregateInput>;
  _max?: InputMaybe<CountryMaxOrderByAggregateInput>;
  _min?: InputMaybe<CountryMinOrderByAggregateInput>;
  flag?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type CountryOrderByWithRelationInput = {
  _relevance?: InputMaybe<CountryOrderByRelevanceInput>;
  flag?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  players?: InputMaybe<PlayerOrderByRelationAggregateInput>;
};

export enum CountryScalarFieldEnum {
  Flag = 'flag',
  Name = 'name'
}

export type CountryScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<CountryScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<CountryScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<CountryScalarWhereWithAggregatesInput>>;
  flag?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
};

export type CountryUpdateInput = {
  flag?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  players?: InputMaybe<PlayerUpdateManyWithoutCountryDataNestedInput>;
};

export type CountryUpdateManyMutationInput = {
  flag?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type CountryUpdateOneWithoutPlayersNestedInput = {
  connect?: InputMaybe<CountryWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CountryCreateOrConnectWithoutPlayersInput>;
  create?: InputMaybe<CountryCreateWithoutPlayersInput>;
  delete?: InputMaybe<CountryWhereInput>;
  disconnect?: InputMaybe<CountryWhereInput>;
  update?: InputMaybe<CountryUpdateToOneWithWhereWithoutPlayersInput>;
  upsert?: InputMaybe<CountryUpsertWithoutPlayersInput>;
};

export type CountryUpdateToOneWithWhereWithoutPlayersInput = {
  data: CountryUpdateWithoutPlayersInput;
  where?: InputMaybe<CountryWhereInput>;
};

export type CountryUpdateWithoutPlayersInput = {
  flag?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type CountryUpsertWithoutPlayersInput = {
  create: CountryCreateWithoutPlayersInput;
  update: CountryUpdateWithoutPlayersInput;
  where?: InputMaybe<CountryWhereInput>;
};

export type CountryWhereInput = {
  AND?: InputMaybe<Array<CountryWhereInput>>;
  NOT?: InputMaybe<Array<CountryWhereInput>>;
  OR?: InputMaybe<Array<CountryWhereInput>>;
  flag?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  players?: InputMaybe<PlayerListRelationFilter>;
};

export type CountryWhereUniqueInput = {
  AND?: InputMaybe<Array<CountryWhereInput>>;
  NOT?: InputMaybe<Array<CountryWhereInput>>;
  OR?: InputMaybe<Array<CountryWhereInput>>;
  flag?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<StringFilter>;
  players?: InputMaybe<PlayerListRelationFilter>;
};

export type CreateServerInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  mod?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  port: Scalars['Int']['input'];
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword: Scalars['String']['input'];
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
};

export type DateTimeFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['DateTime']['input']>;
};

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DecimalNullableFilter = {
  equals?: InputMaybe<Scalars['Decimal']['input']>;
  gt?: InputMaybe<Scalars['Decimal']['input']>;
  gte?: InputMaybe<Scalars['Decimal']['input']>;
  in?: InputMaybe<Array<Scalars['Decimal']['input']>>;
  lt?: InputMaybe<Scalars['Decimal']['input']>;
  lte?: InputMaybe<Scalars['Decimal']['input']>;
  not?: InputMaybe<NestedDecimalNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']['input']>>;
};

export type DecimalNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDecimalNullableFilter>;
  _min?: InputMaybe<NestedDecimalNullableFilter>;
  _sum?: InputMaybe<NestedDecimalNullableFilter>;
  equals?: InputMaybe<Scalars['Decimal']['input']>;
  gt?: InputMaybe<Scalars['Decimal']['input']>;
  gte?: InputMaybe<Scalars['Decimal']['input']>;
  in?: InputMaybe<Array<Scalars['Decimal']['input']>>;
  lt?: InputMaybe<Scalars['Decimal']['input']>;
  lte?: InputMaybe<Scalars['Decimal']['input']>;
  not?: InputMaybe<NestedDecimalNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']['input']>>;
};

export type EnumClanTagPositionFieldUpdateOperationsInput = {
  set?: InputMaybe<ClanTagPosition>;
};

export type EnumClanTagPositionFilter = {
  equals?: InputMaybe<ClanTagPosition>;
  in?: InputMaybe<Array<ClanTagPosition>>;
  not?: InputMaybe<ClanTagPosition>;
  notIn?: InputMaybe<Array<ClanTagPosition>>;
};

export type EnumClanTagPositionWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedEnumClanTagPositionFilter>;
  _min?: InputMaybe<NestedEnumClanTagPositionFilter>;
  equals?: InputMaybe<ClanTagPosition>;
  in?: InputMaybe<Array<ClanTagPosition>>;
  not?: InputMaybe<ClanTagPosition>;
  notIn?: InputMaybe<Array<ClanTagPosition>>;
};

export type EventAdmin = {
  __typename?: 'EventAdmin';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  message: Scalars['String']['output'];
  playerName: Scalars['String']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type EventAdminAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventAdminCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  playerName?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventAdminCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  playerName?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsAdminInput>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventAdminCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  playerName?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventAdminCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  playerName?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventAdminCreateManyServerInputEnvelope = {
  data: Array<EventAdminCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventAdminCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventAdminWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventAdminCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventAdminCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventAdminCreateManyServerInputEnvelope>;
};

export type EventAdminCreateOrConnectWithoutServerInput = {
  create: EventAdminCreateWithoutServerInput;
  where: EventAdminWhereUniqueInput;
};

export type EventAdminCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  playerName?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventAdminListRelationFilter = {
  every?: InputMaybe<EventAdminWhereInput>;
  none?: InputMaybe<EventAdminWhereInput>;
  some?: InputMaybe<EventAdminWhereInput>;
};

export type EventAdminMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  playerName?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventAdminMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  playerName?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventAdminOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventAdminOrderByRelevanceFieldEnum {
  Map = 'map',
  Message = 'message',
  PlayerName = 'playerName',
  Type = 'type'
}

export type EventAdminOrderByRelevanceInput = {
  fields: Array<EventAdminOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventAdminOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventAdminAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventAdminCountOrderByAggregateInput>;
  _max?: InputMaybe<EventAdminMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventAdminMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventAdminSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  playerName?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventAdminOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventAdminOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  playerName?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export enum EventAdminScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  Message = 'message',
  PlayerName = 'playerName',
  ServerId = 'serverId',
  Type = 'type'
}

export type EventAdminScalarWhereInput = {
  AND?: InputMaybe<Array<EventAdminScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventAdminScalarWhereInput>>;
  OR?: InputMaybe<Array<EventAdminScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringFilter>;
  playerName?: InputMaybe<StringFilter>;
  serverId?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
};

export type EventAdminScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventAdminScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventAdminScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventAdminScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  message?: InputMaybe<StringWithAggregatesFilter>;
  playerName?: InputMaybe<StringWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
};

export type EventAdminSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventAdminUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerName?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsAdminNestedInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventAdminUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerName?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventAdminUpdateManyWithWhereWithoutServerInput = {
  data: EventAdminUpdateManyMutationInput;
  where: EventAdminScalarWhereInput;
};

export type EventAdminUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventAdminWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventAdminCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventAdminCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventAdminCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventAdminWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventAdminScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventAdminWhereUniqueInput>>;
  set?: InputMaybe<Array<EventAdminWhereUniqueInput>>;
  update?: InputMaybe<Array<EventAdminUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventAdminUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventAdminUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventAdminUpdateWithWhereUniqueWithoutServerInput = {
  data: EventAdminUpdateWithoutServerInput;
  where: EventAdminWhereUniqueInput;
};

export type EventAdminUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerName?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventAdminUpsertWithWhereUniqueWithoutServerInput = {
  create: EventAdminCreateWithoutServerInput;
  update: EventAdminUpdateWithoutServerInput;
  where: EventAdminWhereUniqueInput;
};

export type EventAdminWhereInput = {
  AND?: InputMaybe<Array<EventAdminWhereInput>>;
  NOT?: InputMaybe<Array<EventAdminWhereInput>>;
  OR?: InputMaybe<Array<EventAdminWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringFilter>;
  playerName?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
};

export type EventAdminWhereUniqueInput = {
  AND?: InputMaybe<Array<EventAdminWhereInput>>;
  NOT?: InputMaybe<Array<EventAdminWhereInput>>;
  OR?: InputMaybe<Array<EventAdminWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringFilter>;
  playerName?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
};

export type EventChangeName = {
  __typename?: 'EventChangeName';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  newName: Scalars['String']['output'];
  oldName: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventChangeNameAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeNameCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  newName?: InputMaybe<SortOrder>;
  oldName?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeNameCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  newName?: InputMaybe<Scalars['String']['input']>;
  oldName?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutNameChangesInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChangeNameInput>;
};

export type EventChangeNameCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  newName?: InputMaybe<Scalars['String']['input']>;
  oldName?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChangeNameCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  newName?: InputMaybe<Scalars['String']['input']>;
  oldName?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChangeNameCreateManyPlayerInputEnvelope = {
  data: Array<EventChangeNameCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChangeNameCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  newName?: InputMaybe<Scalars['String']['input']>;
  oldName?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChangeNameCreateManyServerInputEnvelope = {
  data: Array<EventChangeNameCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChangeNameCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeNameCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChangeNameCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChangeNameCreateManyPlayerInputEnvelope>;
};

export type EventChangeNameCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeNameCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChangeNameCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChangeNameCreateManyServerInputEnvelope>;
};

export type EventChangeNameCreateOrConnectWithoutPlayerInput = {
  create: EventChangeNameCreateWithoutPlayerInput;
  where: EventChangeNameWhereUniqueInput;
};

export type EventChangeNameCreateOrConnectWithoutServerInput = {
  create: EventChangeNameCreateWithoutServerInput;
  where: EventChangeNameWhereUniqueInput;
};

export type EventChangeNameCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  newName?: InputMaybe<Scalars['String']['input']>;
  oldName?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChangeNameInput>;
};

export type EventChangeNameCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  newName?: InputMaybe<Scalars['String']['input']>;
  oldName?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutNameChangesInput>;
};

export type EventChangeNameListRelationFilter = {
  every?: InputMaybe<EventChangeNameWhereInput>;
  none?: InputMaybe<EventChangeNameWhereInput>;
  some?: InputMaybe<EventChangeNameWhereInput>;
};

export type EventChangeNameMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  newName?: InputMaybe<SortOrder>;
  oldName?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeNameMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  newName?: InputMaybe<SortOrder>;
  oldName?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeNameOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventChangeNameOrderByRelevanceFieldEnum {
  Map = 'map',
  NewName = 'newName',
  OldName = 'oldName'
}

export type EventChangeNameOrderByRelevanceInput = {
  fields: Array<EventChangeNameOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventChangeNameOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventChangeNameAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventChangeNameCountOrderByAggregateInput>;
  _max?: InputMaybe<EventChangeNameMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventChangeNameMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventChangeNameSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  newName?: InputMaybe<SortOrder>;
  oldName?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeNameOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventChangeNameOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  newName?: InputMaybe<SortOrder>;
  oldName?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventChangeNameScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  NewName = 'newName',
  OldName = 'oldName',
  PlayerId = 'playerId',
  ServerId = 'serverId'
}

export type EventChangeNameScalarWhereInput = {
  AND?: InputMaybe<Array<EventChangeNameScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeNameScalarWhereInput>>;
  OR?: InputMaybe<Array<EventChangeNameScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  newName?: InputMaybe<StringFilter>;
  oldName?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChangeNameScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventChangeNameScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventChangeNameScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventChangeNameScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  newName?: InputMaybe<StringWithAggregatesFilter>;
  oldName?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventChangeNameSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeNameUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  newName?: InputMaybe<StringFieldUpdateOperationsInput>;
  oldName?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutNameChangesNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChangeNameNestedInput>;
};

export type EventChangeNameUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  newName?: InputMaybe<StringFieldUpdateOperationsInput>;
  oldName?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventChangeNameUpdateManyWithWhereWithoutPlayerInput = {
  data: EventChangeNameUpdateManyMutationInput;
  where: EventChangeNameScalarWhereInput;
};

export type EventChangeNameUpdateManyWithWhereWithoutServerInput = {
  data: EventChangeNameUpdateManyMutationInput;
  where: EventChangeNameScalarWhereInput;
};

export type EventChangeNameUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeNameCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChangeNameCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChangeNameCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChangeNameScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChangeNameUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventChangeNameUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventChangeNameUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventChangeNameUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeNameCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChangeNameCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChangeNameCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChangeNameScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChangeNameWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChangeNameUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventChangeNameUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventChangeNameUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventChangeNameUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventChangeNameUpdateWithoutPlayerInput;
  where: EventChangeNameWhereUniqueInput;
};

export type EventChangeNameUpdateWithWhereUniqueWithoutServerInput = {
  data: EventChangeNameUpdateWithoutServerInput;
  where: EventChangeNameWhereUniqueInput;
};

export type EventChangeNameUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  newName?: InputMaybe<StringFieldUpdateOperationsInput>;
  oldName?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChangeNameNestedInput>;
};

export type EventChangeNameUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  newName?: InputMaybe<StringFieldUpdateOperationsInput>;
  oldName?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutNameChangesNestedInput>;
};

export type EventChangeNameUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventChangeNameCreateWithoutPlayerInput;
  update: EventChangeNameUpdateWithoutPlayerInput;
  where: EventChangeNameWhereUniqueInput;
};

export type EventChangeNameUpsertWithWhereUniqueWithoutServerInput = {
  create: EventChangeNameCreateWithoutServerInput;
  update: EventChangeNameUpdateWithoutServerInput;
  where: EventChangeNameWhereUniqueInput;
};

export type EventChangeNameWhereInput = {
  AND?: InputMaybe<Array<EventChangeNameWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeNameWhereInput>>;
  OR?: InputMaybe<Array<EventChangeNameWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  newName?: InputMaybe<StringFilter>;
  oldName?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChangeNameWhereUniqueInput = {
  AND?: InputMaybe<Array<EventChangeNameWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeNameWhereInput>>;
  OR?: InputMaybe<Array<EventChangeNameWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  newName?: InputMaybe<StringFilter>;
  oldName?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChangeRole = {
  __typename?: 'EventChangeRole';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  role: Scalars['String']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventChangeRoleAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeRoleCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeRoleCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutRoleChangesInput>;
  role?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChangeRoleInput>;
};

export type EventChangeRoleCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChangeRoleCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChangeRoleCreateManyPlayerInputEnvelope = {
  data: Array<EventChangeRoleCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChangeRoleCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeRoleCreateManyServerInputEnvelope = {
  data: Array<EventChangeRoleCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChangeRoleCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeRoleCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChangeRoleCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChangeRoleCreateManyPlayerInputEnvelope>;
};

export type EventChangeRoleCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeRoleCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChangeRoleCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChangeRoleCreateManyServerInputEnvelope>;
};

export type EventChangeRoleCreateOrConnectWithoutPlayerInput = {
  create: EventChangeRoleCreateWithoutPlayerInput;
  where: EventChangeRoleWhereUniqueInput;
};

export type EventChangeRoleCreateOrConnectWithoutServerInput = {
  create: EventChangeRoleCreateWithoutServerInput;
  where: EventChangeRoleWhereUniqueInput;
};

export type EventChangeRoleCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChangeRoleInput>;
};

export type EventChangeRoleCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutRoleChangesInput>;
  role?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeRoleListRelationFilter = {
  every?: InputMaybe<EventChangeRoleWhereInput>;
  none?: InputMaybe<EventChangeRoleWhereInput>;
  some?: InputMaybe<EventChangeRoleWhereInput>;
};

export type EventChangeRoleMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeRoleMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeRoleOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventChangeRoleOrderByRelevanceFieldEnum {
  Map = 'map',
  Role = 'role'
}

export type EventChangeRoleOrderByRelevanceInput = {
  fields: Array<EventChangeRoleOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventChangeRoleOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventChangeRoleAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventChangeRoleCountOrderByAggregateInput>;
  _max?: InputMaybe<EventChangeRoleMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventChangeRoleMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventChangeRoleSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeRoleOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventChangeRoleOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventChangeRoleScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  Role = 'role',
  ServerId = 'serverId'
}

export type EventChangeRoleScalarWhereInput = {
  AND?: InputMaybe<Array<EventChangeRoleScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeRoleScalarWhereInput>>;
  OR?: InputMaybe<Array<EventChangeRoleScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  role?: InputMaybe<StringFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChangeRoleScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventChangeRoleScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventChangeRoleScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventChangeRoleScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  role?: InputMaybe<StringWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventChangeRoleSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeRoleUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutRoleChangesNestedInput>;
  role?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChangeRoleNestedInput>;
};

export type EventChangeRoleUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  role?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventChangeRoleUpdateManyWithWhereWithoutPlayerInput = {
  data: EventChangeRoleUpdateManyMutationInput;
  where: EventChangeRoleScalarWhereInput;
};

export type EventChangeRoleUpdateManyWithWhereWithoutServerInput = {
  data: EventChangeRoleUpdateManyMutationInput;
  where: EventChangeRoleScalarWhereInput;
};

export type EventChangeRoleUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeRoleCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChangeRoleCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChangeRoleCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChangeRoleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChangeRoleUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventChangeRoleUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventChangeRoleUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventChangeRoleUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeRoleCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChangeRoleCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChangeRoleCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChangeRoleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChangeRoleWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChangeRoleUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventChangeRoleUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventChangeRoleUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventChangeRoleUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventChangeRoleUpdateWithoutPlayerInput;
  where: EventChangeRoleWhereUniqueInput;
};

export type EventChangeRoleUpdateWithWhereUniqueWithoutServerInput = {
  data: EventChangeRoleUpdateWithoutServerInput;
  where: EventChangeRoleWhereUniqueInput;
};

export type EventChangeRoleUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  role?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChangeRoleNestedInput>;
};

export type EventChangeRoleUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutRoleChangesNestedInput>;
  role?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventChangeRoleUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventChangeRoleCreateWithoutPlayerInput;
  update: EventChangeRoleUpdateWithoutPlayerInput;
  where: EventChangeRoleWhereUniqueInput;
};

export type EventChangeRoleUpsertWithWhereUniqueWithoutServerInput = {
  create: EventChangeRoleCreateWithoutServerInput;
  update: EventChangeRoleUpdateWithoutServerInput;
  where: EventChangeRoleWhereUniqueInput;
};

export type EventChangeRoleWhereInput = {
  AND?: InputMaybe<Array<EventChangeRoleWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeRoleWhereInput>>;
  OR?: InputMaybe<Array<EventChangeRoleWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  role?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChangeRoleWhereUniqueInput = {
  AND?: InputMaybe<Array<EventChangeRoleWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeRoleWhereInput>>;
  OR?: InputMaybe<Array<EventChangeRoleWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  role?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChangeTeam = {
  __typename?: 'EventChangeTeam';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
  team: Scalars['String']['output'];
};

export type EventChangeTeamAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeTeamCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export type EventChangeTeamCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutTeamChangesInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChangeTeamInput>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeTeamCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeTeamCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeTeamCreateManyPlayerInputEnvelope = {
  data: Array<EventChangeTeamCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChangeTeamCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeTeamCreateManyServerInputEnvelope = {
  data: Array<EventChangeTeamCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChangeTeamCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeTeamCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChangeTeamCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChangeTeamCreateManyPlayerInputEnvelope>;
};

export type EventChangeTeamCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeTeamCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChangeTeamCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChangeTeamCreateManyServerInputEnvelope>;
};

export type EventChangeTeamCreateOrConnectWithoutPlayerInput = {
  create: EventChangeTeamCreateWithoutPlayerInput;
  where: EventChangeTeamWhereUniqueInput;
};

export type EventChangeTeamCreateOrConnectWithoutServerInput = {
  create: EventChangeTeamCreateWithoutServerInput;
  where: EventChangeTeamWhereUniqueInput;
};

export type EventChangeTeamCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChangeTeamInput>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeTeamCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutTeamChangesInput>;
  team?: InputMaybe<Scalars['String']['input']>;
};

export type EventChangeTeamListRelationFilter = {
  every?: InputMaybe<EventChangeTeamWhereInput>;
  none?: InputMaybe<EventChangeTeamWhereInput>;
  some?: InputMaybe<EventChangeTeamWhereInput>;
};

export type EventChangeTeamMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export type EventChangeTeamMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export type EventChangeTeamOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventChangeTeamOrderByRelevanceFieldEnum {
  Map = 'map',
  Team = 'team'
}

export type EventChangeTeamOrderByRelevanceInput = {
  fields: Array<EventChangeTeamOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventChangeTeamOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventChangeTeamAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventChangeTeamCountOrderByAggregateInput>;
  _max?: InputMaybe<EventChangeTeamMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventChangeTeamMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventChangeTeamSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export type EventChangeTeamOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventChangeTeamOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  team?: InputMaybe<SortOrder>;
};

export enum EventChangeTeamScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  ServerId = 'serverId',
  Team = 'team'
}

export type EventChangeTeamScalarWhereInput = {
  AND?: InputMaybe<Array<EventChangeTeamScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeTeamScalarWhereInput>>;
  OR?: InputMaybe<Array<EventChangeTeamScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
  team?: InputMaybe<StringFilter>;
};

export type EventChangeTeamScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventChangeTeamScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventChangeTeamScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventChangeTeamScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  team?: InputMaybe<StringWithAggregatesFilter>;
};

export type EventChangeTeamSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChangeTeamUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamChangesNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChangeTeamNestedInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventChangeTeamUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventChangeTeamUpdateManyWithWhereWithoutPlayerInput = {
  data: EventChangeTeamUpdateManyMutationInput;
  where: EventChangeTeamScalarWhereInput;
};

export type EventChangeTeamUpdateManyWithWhereWithoutServerInput = {
  data: EventChangeTeamUpdateManyMutationInput;
  where: EventChangeTeamScalarWhereInput;
};

export type EventChangeTeamUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeTeamCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChangeTeamCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChangeTeamCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChangeTeamScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChangeTeamUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventChangeTeamUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventChangeTeamUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventChangeTeamUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChangeTeamCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChangeTeamCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChangeTeamCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChangeTeamScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChangeTeamWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChangeTeamUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventChangeTeamUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventChangeTeamUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventChangeTeamUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventChangeTeamUpdateWithoutPlayerInput;
  where: EventChangeTeamWhereUniqueInput;
};

export type EventChangeTeamUpdateWithWhereUniqueWithoutServerInput = {
  data: EventChangeTeamUpdateWithoutServerInput;
  where: EventChangeTeamWhereUniqueInput;
};

export type EventChangeTeamUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChangeTeamNestedInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventChangeTeamUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamChangesNestedInput>;
  team?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventChangeTeamUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventChangeTeamCreateWithoutPlayerInput;
  update: EventChangeTeamUpdateWithoutPlayerInput;
  where: EventChangeTeamWhereUniqueInput;
};

export type EventChangeTeamUpsertWithWhereUniqueWithoutServerInput = {
  create: EventChangeTeamCreateWithoutServerInput;
  update: EventChangeTeamUpdateWithoutServerInput;
  where: EventChangeTeamWhereUniqueInput;
};

export type EventChangeTeamWhereInput = {
  AND?: InputMaybe<Array<EventChangeTeamWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeTeamWhereInput>>;
  OR?: InputMaybe<Array<EventChangeTeamWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  team?: InputMaybe<StringFilter>;
};

export type EventChangeTeamWhereUniqueInput = {
  AND?: InputMaybe<Array<EventChangeTeamWhereInput>>;
  NOT?: InputMaybe<Array<EventChangeTeamWhereInput>>;
  OR?: InputMaybe<Array<EventChangeTeamWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  team?: InputMaybe<StringFilter>;
};

export type EventChat = {
  __typename?: 'EventChat';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  message: Scalars['String']['output'];
  messageMode: Scalars['Int']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventChatAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  messageMode?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChatCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  messageMode?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChatCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  messageMode?: InputMaybe<Scalars['Int']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutChatsInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChatInput>;
};

export type EventChatCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  messageMode?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChatCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  messageMode?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChatCreateManyPlayerInputEnvelope = {
  data: Array<EventChatCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChatCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  messageMode?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventChatCreateManyServerInputEnvelope = {
  data: Array<EventChatCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventChatCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChatCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChatCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChatCreateManyPlayerInputEnvelope>;
};

export type EventChatCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChatCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChatCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChatCreateManyServerInputEnvelope>;
};

export type EventChatCreateOrConnectWithoutPlayerInput = {
  create: EventChatCreateWithoutPlayerInput;
  where: EventChatWhereUniqueInput;
};

export type EventChatCreateOrConnectWithoutServerInput = {
  create: EventChatCreateWithoutServerInput;
  where: EventChatWhereUniqueInput;
};

export type EventChatCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  messageMode?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsChatInput>;
};

export type EventChatCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  messageMode?: InputMaybe<Scalars['Int']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutChatsInput>;
};

export type EventChatListRelationFilter = {
  every?: InputMaybe<EventChatWhereInput>;
  none?: InputMaybe<EventChatWhereInput>;
  some?: InputMaybe<EventChatWhereInput>;
};

export type EventChatMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  messageMode?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChatMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  messageMode?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChatOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventChatOrderByRelevanceFieldEnum {
  Map = 'map',
  Message = 'message'
}

export type EventChatOrderByRelevanceInput = {
  fields: Array<EventChatOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventChatOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventChatAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventChatCountOrderByAggregateInput>;
  _max?: InputMaybe<EventChatMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventChatMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventChatSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  messageMode?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChatOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventChatOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  message?: InputMaybe<SortOrder>;
  messageMode?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventChatScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  Message = 'message',
  MessageMode = 'messageMode',
  PlayerId = 'playerId',
  ServerId = 'serverId'
}

export type EventChatScalarWhereInput = {
  AND?: InputMaybe<Array<EventChatScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventChatScalarWhereInput>>;
  OR?: InputMaybe<Array<EventChatScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringFilter>;
  messageMode?: InputMaybe<IntFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChatScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventChatScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventChatScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventChatScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  message?: InputMaybe<StringWithAggregatesFilter>;
  messageMode?: InputMaybe<IntWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventChatSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  messageMode?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventChatUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  messageMode?: InputMaybe<IntFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutChatsNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChatNestedInput>;
};

export type EventChatUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  messageMode?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type EventChatUpdateManyWithWhereWithoutPlayerInput = {
  data: EventChatUpdateManyMutationInput;
  where: EventChatScalarWhereInput;
};

export type EventChatUpdateManyWithWhereWithoutServerInput = {
  data: EventChatUpdateManyMutationInput;
  where: EventChatScalarWhereInput;
};

export type EventChatUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChatCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventChatCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventChatCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChatScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChatUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventChatUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventChatUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventChatUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventChatCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventChatCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventChatCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventChatScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  set?: InputMaybe<Array<EventChatWhereUniqueInput>>;
  update?: InputMaybe<Array<EventChatUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventChatUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventChatUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventChatUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventChatUpdateWithoutPlayerInput;
  where: EventChatWhereUniqueInput;
};

export type EventChatUpdateWithWhereUniqueWithoutServerInput = {
  data: EventChatUpdateWithoutServerInput;
  where: EventChatWhereUniqueInput;
};

export type EventChatUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  messageMode?: InputMaybe<IntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsChatNestedInput>;
};

export type EventChatUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  messageMode?: InputMaybe<IntFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutChatsNestedInput>;
};

export type EventChatUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventChatCreateWithoutPlayerInput;
  update: EventChatUpdateWithoutPlayerInput;
  where: EventChatWhereUniqueInput;
};

export type EventChatUpsertWithWhereUniqueWithoutServerInput = {
  create: EventChatCreateWithoutServerInput;
  update: EventChatUpdateWithoutServerInput;
  where: EventChatWhereUniqueInput;
};

export type EventChatWhereInput = {
  AND?: InputMaybe<Array<EventChatWhereInput>>;
  NOT?: InputMaybe<Array<EventChatWhereInput>>;
  OR?: InputMaybe<Array<EventChatWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringFilter>;
  messageMode?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventChatWhereUniqueInput = {
  AND?: InputMaybe<Array<EventChatWhereInput>>;
  NOT?: InputMaybe<Array<EventChatWhereInput>>;
  OR?: InputMaybe<Array<EventChatWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringFilter>;
  messageMode?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventConnect = {
  __typename?: 'EventConnect';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  eventTimeDisconnect?: Maybe<Scalars['DateTime']['output']>;
  hostgroup: Scalars['String']['output'];
  hostname: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  ipAddress: Scalars['String']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventConnectAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventConnectCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  eventTimeDisconnect?: InputMaybe<SortOrder>;
  hostgroup?: InputMaybe<SortOrder>;
  hostname?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventConnectCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  eventTimeDisconnect?: InputMaybe<Scalars['DateTime']['input']>;
  hostgroup?: InputMaybe<Scalars['String']['input']>;
  hostname?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutConnectsInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsConnectInput>;
};

export type EventConnectCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  eventTimeDisconnect?: InputMaybe<Scalars['DateTime']['input']>;
  hostgroup?: InputMaybe<Scalars['String']['input']>;
  hostname?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventConnectCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  eventTimeDisconnect?: InputMaybe<Scalars['DateTime']['input']>;
  hostgroup?: InputMaybe<Scalars['String']['input']>;
  hostname?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventConnectCreateManyPlayerInputEnvelope = {
  data: Array<EventConnectCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventConnectCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  eventTimeDisconnect?: InputMaybe<Scalars['DateTime']['input']>;
  hostgroup?: InputMaybe<Scalars['String']['input']>;
  hostname?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventConnectCreateManyServerInputEnvelope = {
  data: Array<EventConnectCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventConnectCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventConnectCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventConnectCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventConnectCreateManyPlayerInputEnvelope>;
};

export type EventConnectCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventConnectCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventConnectCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventConnectCreateManyServerInputEnvelope>;
};

export type EventConnectCreateOrConnectWithoutPlayerInput = {
  create: EventConnectCreateWithoutPlayerInput;
  where: EventConnectWhereUniqueInput;
};

export type EventConnectCreateOrConnectWithoutServerInput = {
  create: EventConnectCreateWithoutServerInput;
  where: EventConnectWhereUniqueInput;
};

export type EventConnectCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  eventTimeDisconnect?: InputMaybe<Scalars['DateTime']['input']>;
  hostgroup?: InputMaybe<Scalars['String']['input']>;
  hostname?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsConnectInput>;
};

export type EventConnectCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  eventTimeDisconnect?: InputMaybe<Scalars['DateTime']['input']>;
  hostgroup?: InputMaybe<Scalars['String']['input']>;
  hostname?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutConnectsInput>;
};

export type EventConnectListRelationFilter = {
  every?: InputMaybe<EventConnectWhereInput>;
  none?: InputMaybe<EventConnectWhereInput>;
  some?: InputMaybe<EventConnectWhereInput>;
};

export type EventConnectMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  eventTimeDisconnect?: InputMaybe<SortOrder>;
  hostgroup?: InputMaybe<SortOrder>;
  hostname?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventConnectMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  eventTimeDisconnect?: InputMaybe<SortOrder>;
  hostgroup?: InputMaybe<SortOrder>;
  hostname?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventConnectOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventConnectOrderByRelevanceFieldEnum {
  Hostgroup = 'hostgroup',
  Hostname = 'hostname',
  IpAddress = 'ipAddress',
  Map = 'map'
}

export type EventConnectOrderByRelevanceInput = {
  fields: Array<EventConnectOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventConnectOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventConnectAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventConnectCountOrderByAggregateInput>;
  _max?: InputMaybe<EventConnectMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventConnectMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventConnectSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  eventTimeDisconnect?: InputMaybe<SortOrder>;
  hostgroup?: InputMaybe<SortOrder>;
  hostname?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventConnectOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventConnectOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  eventTimeDisconnect?: InputMaybe<SortOrder>;
  hostgroup?: InputMaybe<SortOrder>;
  hostname?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventConnectScalarFieldEnum {
  EventTime = 'eventTime',
  EventTimeDisconnect = 'eventTimeDisconnect',
  Hostgroup = 'hostgroup',
  Hostname = 'hostname',
  Id = 'id',
  IpAddress = 'ipAddress',
  Map = 'map',
  PlayerId = 'playerId',
  ServerId = 'serverId'
}

export type EventConnectScalarWhereInput = {
  AND?: InputMaybe<Array<EventConnectScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventConnectScalarWhereInput>>;
  OR?: InputMaybe<Array<EventConnectScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  eventTimeDisconnect?: InputMaybe<DateTimeNullableFilter>;
  hostgroup?: InputMaybe<StringFilter>;
  hostname?: InputMaybe<StringFilter>;
  id?: InputMaybe<IntFilter>;
  ipAddress?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventConnectScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventConnectScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventConnectScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventConnectScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  eventTimeDisconnect?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  hostgroup?: InputMaybe<StringWithAggregatesFilter>;
  hostname?: InputMaybe<StringWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  ipAddress?: InputMaybe<StringWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventConnectSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventConnectUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  eventTimeDisconnect?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  hostgroup?: InputMaybe<StringFieldUpdateOperationsInput>;
  hostname?: InputMaybe<StringFieldUpdateOperationsInput>;
  ipAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutConnectsNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsConnectNestedInput>;
};

export type EventConnectUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  eventTimeDisconnect?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  hostgroup?: InputMaybe<StringFieldUpdateOperationsInput>;
  hostname?: InputMaybe<StringFieldUpdateOperationsInput>;
  ipAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventConnectUpdateManyWithWhereWithoutPlayerInput = {
  data: EventConnectUpdateManyMutationInput;
  where: EventConnectScalarWhereInput;
};

export type EventConnectUpdateManyWithWhereWithoutServerInput = {
  data: EventConnectUpdateManyMutationInput;
  where: EventConnectScalarWhereInput;
};

export type EventConnectUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventConnectCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventConnectCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventConnectCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventConnectScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  set?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  update?: InputMaybe<Array<EventConnectUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventConnectUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventConnectUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventConnectUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventConnectCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventConnectCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventConnectCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventConnectScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  set?: InputMaybe<Array<EventConnectWhereUniqueInput>>;
  update?: InputMaybe<Array<EventConnectUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventConnectUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventConnectUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventConnectUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventConnectUpdateWithoutPlayerInput;
  where: EventConnectWhereUniqueInput;
};

export type EventConnectUpdateWithWhereUniqueWithoutServerInput = {
  data: EventConnectUpdateWithoutServerInput;
  where: EventConnectWhereUniqueInput;
};

export type EventConnectUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  eventTimeDisconnect?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  hostgroup?: InputMaybe<StringFieldUpdateOperationsInput>;
  hostname?: InputMaybe<StringFieldUpdateOperationsInput>;
  ipAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsConnectNestedInput>;
};

export type EventConnectUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  eventTimeDisconnect?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  hostgroup?: InputMaybe<StringFieldUpdateOperationsInput>;
  hostname?: InputMaybe<StringFieldUpdateOperationsInput>;
  ipAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutConnectsNestedInput>;
};

export type EventConnectUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventConnectCreateWithoutPlayerInput;
  update: EventConnectUpdateWithoutPlayerInput;
  where: EventConnectWhereUniqueInput;
};

export type EventConnectUpsertWithWhereUniqueWithoutServerInput = {
  create: EventConnectCreateWithoutServerInput;
  update: EventConnectUpdateWithoutServerInput;
  where: EventConnectWhereUniqueInput;
};

export type EventConnectWhereInput = {
  AND?: InputMaybe<Array<EventConnectWhereInput>>;
  NOT?: InputMaybe<Array<EventConnectWhereInput>>;
  OR?: InputMaybe<Array<EventConnectWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  eventTimeDisconnect?: InputMaybe<DateTimeNullableFilter>;
  hostgroup?: InputMaybe<StringFilter>;
  hostname?: InputMaybe<StringFilter>;
  id?: InputMaybe<IntFilter>;
  ipAddress?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventConnectWhereUniqueInput = {
  AND?: InputMaybe<Array<EventConnectWhereInput>>;
  NOT?: InputMaybe<Array<EventConnectWhereInput>>;
  OR?: InputMaybe<Array<EventConnectWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  eventTimeDisconnect?: InputMaybe<DateTimeNullableFilter>;
  hostgroup?: InputMaybe<StringFilter>;
  hostname?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventDisconnect = {
  __typename?: 'EventDisconnect';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventDisconnectAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventDisconnectCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventDisconnectCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutDisconnectsInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsDisconnectInput>;
};

export type EventDisconnectCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventDisconnectCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventDisconnectCreateManyPlayerInputEnvelope = {
  data: Array<EventDisconnectCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventDisconnectCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventDisconnectCreateManyServerInputEnvelope = {
  data: Array<EventDisconnectCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventDisconnectCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventDisconnectCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventDisconnectCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventDisconnectCreateManyPlayerInputEnvelope>;
};

export type EventDisconnectCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventDisconnectCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventDisconnectCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventDisconnectCreateManyServerInputEnvelope>;
};

export type EventDisconnectCreateOrConnectWithoutPlayerInput = {
  create: EventDisconnectCreateWithoutPlayerInput;
  where: EventDisconnectWhereUniqueInput;
};

export type EventDisconnectCreateOrConnectWithoutServerInput = {
  create: EventDisconnectCreateWithoutServerInput;
  where: EventDisconnectWhereUniqueInput;
};

export type EventDisconnectCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsDisconnectInput>;
};

export type EventDisconnectCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutDisconnectsInput>;
};

export type EventDisconnectListRelationFilter = {
  every?: InputMaybe<EventDisconnectWhereInput>;
  none?: InputMaybe<EventDisconnectWhereInput>;
  some?: InputMaybe<EventDisconnectWhereInput>;
};

export type EventDisconnectMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventDisconnectMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventDisconnectOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventDisconnectOrderByRelevanceFieldEnum {
  Map = 'map'
}

export type EventDisconnectOrderByRelevanceInput = {
  fields: Array<EventDisconnectOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventDisconnectOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventDisconnectAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventDisconnectCountOrderByAggregateInput>;
  _max?: InputMaybe<EventDisconnectMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventDisconnectMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventDisconnectSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventDisconnectOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventDisconnectOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventDisconnectScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  ServerId = 'serverId'
}

export type EventDisconnectScalarWhereInput = {
  AND?: InputMaybe<Array<EventDisconnectScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventDisconnectScalarWhereInput>>;
  OR?: InputMaybe<Array<EventDisconnectScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventDisconnectScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventDisconnectScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventDisconnectScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventDisconnectScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventDisconnectSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventDisconnectUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutDisconnectsNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsDisconnectNestedInput>;
};

export type EventDisconnectUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventDisconnectUpdateManyWithWhereWithoutPlayerInput = {
  data: EventDisconnectUpdateManyMutationInput;
  where: EventDisconnectScalarWhereInput;
};

export type EventDisconnectUpdateManyWithWhereWithoutServerInput = {
  data: EventDisconnectUpdateManyMutationInput;
  where: EventDisconnectScalarWhereInput;
};

export type EventDisconnectUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventDisconnectCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventDisconnectCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventDisconnectCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventDisconnectScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  set?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  update?: InputMaybe<Array<EventDisconnectUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventDisconnectUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventDisconnectUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventDisconnectUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventDisconnectCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventDisconnectCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventDisconnectCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventDisconnectScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  set?: InputMaybe<Array<EventDisconnectWhereUniqueInput>>;
  update?: InputMaybe<Array<EventDisconnectUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventDisconnectUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventDisconnectUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventDisconnectUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventDisconnectUpdateWithoutPlayerInput;
  where: EventDisconnectWhereUniqueInput;
};

export type EventDisconnectUpdateWithWhereUniqueWithoutServerInput = {
  data: EventDisconnectUpdateWithoutServerInput;
  where: EventDisconnectWhereUniqueInput;
};

export type EventDisconnectUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsDisconnectNestedInput>;
};

export type EventDisconnectUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutDisconnectsNestedInput>;
};

export type EventDisconnectUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventDisconnectCreateWithoutPlayerInput;
  update: EventDisconnectUpdateWithoutPlayerInput;
  where: EventDisconnectWhereUniqueInput;
};

export type EventDisconnectUpsertWithWhereUniqueWithoutServerInput = {
  create: EventDisconnectCreateWithoutServerInput;
  update: EventDisconnectUpdateWithoutServerInput;
  where: EventDisconnectWhereUniqueInput;
};

export type EventDisconnectWhereInput = {
  AND?: InputMaybe<Array<EventDisconnectWhereInput>>;
  NOT?: InputMaybe<Array<EventDisconnectWhereInput>>;
  OR?: InputMaybe<Array<EventDisconnectWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventDisconnectWhereUniqueInput = {
  AND?: InputMaybe<Array<EventDisconnectWhereInput>>;
  NOT?: InputMaybe<Array<EventDisconnectWhereInput>>;
  OR?: InputMaybe<Array<EventDisconnectWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventEntry = {
  __typename?: 'EventEntry';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventEntryAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventEntryCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventEntryCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutEntriesInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsEntryInput>;
};

export type EventEntryCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventEntryCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventEntryCreateManyPlayerInputEnvelope = {
  data: Array<EventEntryCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventEntryCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventEntryCreateManyServerInputEnvelope = {
  data: Array<EventEntryCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventEntryCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventEntryCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventEntryCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventEntryCreateManyPlayerInputEnvelope>;
};

export type EventEntryCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventEntryCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventEntryCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventEntryCreateManyServerInputEnvelope>;
};

export type EventEntryCreateOrConnectWithoutPlayerInput = {
  create: EventEntryCreateWithoutPlayerInput;
  where: EventEntryWhereUniqueInput;
};

export type EventEntryCreateOrConnectWithoutServerInput = {
  create: EventEntryCreateWithoutServerInput;
  where: EventEntryWhereUniqueInput;
};

export type EventEntryCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsEntryInput>;
};

export type EventEntryCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutEntriesInput>;
};

export type EventEntryListRelationFilter = {
  every?: InputMaybe<EventEntryWhereInput>;
  none?: InputMaybe<EventEntryWhereInput>;
  some?: InputMaybe<EventEntryWhereInput>;
};

export type EventEntryMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventEntryMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventEntryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventEntryOrderByRelevanceFieldEnum {
  Map = 'map'
}

export type EventEntryOrderByRelevanceInput = {
  fields: Array<EventEntryOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventEntryOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventEntryAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventEntryCountOrderByAggregateInput>;
  _max?: InputMaybe<EventEntryMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventEntryMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventEntrySumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventEntryOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventEntryOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventEntryScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  ServerId = 'serverId'
}

export type EventEntryScalarWhereInput = {
  AND?: InputMaybe<Array<EventEntryScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventEntryScalarWhereInput>>;
  OR?: InputMaybe<Array<EventEntryScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventEntryScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventEntryScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventEntryScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventEntryScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventEntrySumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventEntryUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutEntriesNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsEntryNestedInput>;
};

export type EventEntryUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventEntryUpdateManyWithWhereWithoutPlayerInput = {
  data: EventEntryUpdateManyMutationInput;
  where: EventEntryScalarWhereInput;
};

export type EventEntryUpdateManyWithWhereWithoutServerInput = {
  data: EventEntryUpdateManyMutationInput;
  where: EventEntryScalarWhereInput;
};

export type EventEntryUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventEntryCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventEntryCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventEntryCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventEntryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  set?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  update?: InputMaybe<Array<EventEntryUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventEntryUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventEntryUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventEntryUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventEntryCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventEntryCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventEntryCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventEntryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  set?: InputMaybe<Array<EventEntryWhereUniqueInput>>;
  update?: InputMaybe<Array<EventEntryUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventEntryUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventEntryUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventEntryUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventEntryUpdateWithoutPlayerInput;
  where: EventEntryWhereUniqueInput;
};

export type EventEntryUpdateWithWhereUniqueWithoutServerInput = {
  data: EventEntryUpdateWithoutServerInput;
  where: EventEntryWhereUniqueInput;
};

export type EventEntryUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsEntryNestedInput>;
};

export type EventEntryUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutEntriesNestedInput>;
};

export type EventEntryUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventEntryCreateWithoutPlayerInput;
  update: EventEntryUpdateWithoutPlayerInput;
  where: EventEntryWhereUniqueInput;
};

export type EventEntryUpsertWithWhereUniqueWithoutServerInput = {
  create: EventEntryCreateWithoutServerInput;
  update: EventEntryUpdateWithoutServerInput;
  where: EventEntryWhereUniqueInput;
};

export type EventEntryWhereInput = {
  AND?: InputMaybe<Array<EventEntryWhereInput>>;
  NOT?: InputMaybe<Array<EventEntryWhereInput>>;
  OR?: InputMaybe<Array<EventEntryWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventEntryWhereUniqueInput = {
  AND?: InputMaybe<Array<EventEntryWhereInput>>;
  NOT?: InputMaybe<Array<EventEntryWhereInput>>;
  OR?: InputMaybe<Array<EventEntryWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventFrag = {
  __typename?: 'EventFrag';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  headshot: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  killer: Player;
  killerId: Scalars['Int']['output'];
  killerRole: Scalars['String']['output'];
  map: Scalars['String']['output'];
  posVictimX?: Maybe<Scalars['Int']['output']>;
  posVictimY?: Maybe<Scalars['Int']['output']>;
  posVictimZ?: Maybe<Scalars['Int']['output']>;
  posX?: Maybe<Scalars['Int']['output']>;
  posY?: Maybe<Scalars['Int']['output']>;
  posZ?: Maybe<Scalars['Int']['output']>;
  server: Server;
  serverId: Scalars['Int']['output'];
  victim: Player;
  victimId: Scalars['Int']['output'];
  victimRole: Scalars['String']['output'];
  weapon: Scalars['String']['output'];
};

export type EventFragAvgOrderByAggregateInput = {
  headshot?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventFragCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  headshot?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  killerRole?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  victimRole?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventFragCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  killer?: InputMaybe<PlayerCreateNestedOneWithoutFragsAsKillerInput>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsFragInput>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutFragsAsVictimInput>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killerId?: InputMaybe<Scalars['Int']['input']>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragCreateManyKillerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragCreateManyKillerInputEnvelope = {
  data: Array<EventFragCreateManyKillerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventFragCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killerId?: InputMaybe<Scalars['Int']['input']>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragCreateManyServerInputEnvelope = {
  data: Array<EventFragCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventFragCreateManyVictimInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killerId?: InputMaybe<Scalars['Int']['input']>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragCreateManyVictimInputEnvelope = {
  data: Array<EventFragCreateManyVictimInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventFragCreateNestedManyWithoutKillerInput = {
  connect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventFragCreateOrConnectWithoutKillerInput>>;
  create?: InputMaybe<Array<EventFragCreateWithoutKillerInput>>;
  createMany?: InputMaybe<EventFragCreateManyKillerInputEnvelope>;
};

export type EventFragCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventFragCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventFragCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventFragCreateManyServerInputEnvelope>;
};

export type EventFragCreateNestedManyWithoutVictimInput = {
  connect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventFragCreateOrConnectWithoutVictimInput>>;
  create?: InputMaybe<Array<EventFragCreateWithoutVictimInput>>;
  createMany?: InputMaybe<EventFragCreateManyVictimInputEnvelope>;
};

export type EventFragCreateOrConnectWithoutKillerInput = {
  create: EventFragCreateWithoutKillerInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragCreateOrConnectWithoutServerInput = {
  create: EventFragCreateWithoutServerInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragCreateOrConnectWithoutVictimInput = {
  create: EventFragCreateWithoutVictimInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragCreateWithoutKillerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsFragInput>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutFragsAsVictimInput>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  killer?: InputMaybe<PlayerCreateNestedOneWithoutFragsAsKillerInput>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutFragsAsVictimInput>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragCreateWithoutVictimInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  headshot?: InputMaybe<Scalars['Int']['input']>;
  killer?: InputMaybe<PlayerCreateNestedOneWithoutFragsAsKillerInput>;
  killerRole?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsFragInput>;
  victimRole?: InputMaybe<Scalars['String']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventFragListRelationFilter = {
  every?: InputMaybe<EventFragWhereInput>;
  none?: InputMaybe<EventFragWhereInput>;
  some?: InputMaybe<EventFragWhereInput>;
};

export type EventFragMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  headshot?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  killerRole?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  victimRole?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventFragMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  headshot?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  killerRole?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  victimRole?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventFragOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventFragOrderByRelevanceFieldEnum {
  KillerRole = 'killerRole',
  Map = 'map',
  VictimRole = 'victimRole',
  Weapon = 'weapon'
}

export type EventFragOrderByRelevanceInput = {
  fields: Array<EventFragOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventFragOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventFragAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventFragCountOrderByAggregateInput>;
  _max?: InputMaybe<EventFragMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventFragMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventFragSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  headshot?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  killerRole?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  victimRole?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventFragOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventFragOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  headshot?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killer?: InputMaybe<PlayerOrderByWithRelationInput>;
  killerId?: InputMaybe<SortOrder>;
  killerRole?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  victim?: InputMaybe<PlayerOrderByWithRelationInput>;
  victimId?: InputMaybe<SortOrder>;
  victimRole?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export enum EventFragScalarFieldEnum {
  EventTime = 'eventTime',
  Headshot = 'headshot',
  Id = 'id',
  KillerId = 'killerId',
  KillerRole = 'killerRole',
  Map = 'map',
  PosVictimX = 'posVictimX',
  PosVictimY = 'posVictimY',
  PosVictimZ = 'posVictimZ',
  PosX = 'posX',
  PosY = 'posY',
  PosZ = 'posZ',
  ServerId = 'serverId',
  VictimId = 'victimId',
  VictimRole = 'victimRole',
  Weapon = 'weapon'
}

export type EventFragScalarWhereInput = {
  AND?: InputMaybe<Array<EventFragScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventFragScalarWhereInput>>;
  OR?: InputMaybe<Array<EventFragScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  headshot?: InputMaybe<IntFilter>;
  id?: InputMaybe<IntFilter>;
  killerId?: InputMaybe<IntFilter>;
  killerRole?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  serverId?: InputMaybe<IntFilter>;
  victimId?: InputMaybe<IntFilter>;
  victimRole?: InputMaybe<StringFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventFragScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventFragScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventFragScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventFragScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  headshot?: InputMaybe<IntWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  killerId?: InputMaybe<IntWithAggregatesFilter>;
  killerRole?: InputMaybe<StringWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  posVictimX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posVictimY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posVictimZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  posX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  victimId?: InputMaybe<IntWithAggregatesFilter>;
  victimRole?: InputMaybe<StringWithAggregatesFilter>;
  weapon?: InputMaybe<StringWithAggregatesFilter>;
};

export type EventFragSumOrderByAggregateInput = {
  headshot?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventFragUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  headshot?: InputMaybe<IntFieldUpdateOperationsInput>;
  killer?: InputMaybe<PlayerUpdateOneRequiredWithoutFragsAsKillerNestedInput>;
  killerRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsFragNestedInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutFragsAsVictimNestedInput>;
  victimRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventFragUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  headshot?: InputMaybe<IntFieldUpdateOperationsInput>;
  killerRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  victimRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventFragUpdateManyWithWhereWithoutKillerInput = {
  data: EventFragUpdateManyMutationInput;
  where: EventFragScalarWhereInput;
};

export type EventFragUpdateManyWithWhereWithoutServerInput = {
  data: EventFragUpdateManyMutationInput;
  where: EventFragScalarWhereInput;
};

export type EventFragUpdateManyWithWhereWithoutVictimInput = {
  data: EventFragUpdateManyMutationInput;
  where: EventFragScalarWhereInput;
};

export type EventFragUpdateManyWithoutKillerNestedInput = {
  connect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventFragCreateOrConnectWithoutKillerInput>>;
  create?: InputMaybe<Array<EventFragCreateWithoutKillerInput>>;
  createMany?: InputMaybe<EventFragCreateManyKillerInputEnvelope>;
  delete?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventFragScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  set?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  update?: InputMaybe<Array<EventFragUpdateWithWhereUniqueWithoutKillerInput>>;
  updateMany?: InputMaybe<Array<EventFragUpdateManyWithWhereWithoutKillerInput>>;
  upsert?: InputMaybe<Array<EventFragUpsertWithWhereUniqueWithoutKillerInput>>;
};

export type EventFragUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventFragCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventFragCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventFragCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventFragScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  set?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  update?: InputMaybe<Array<EventFragUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventFragUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventFragUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventFragUpdateManyWithoutVictimNestedInput = {
  connect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventFragCreateOrConnectWithoutVictimInput>>;
  create?: InputMaybe<Array<EventFragCreateWithoutVictimInput>>;
  createMany?: InputMaybe<EventFragCreateManyVictimInputEnvelope>;
  delete?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventFragScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  set?: InputMaybe<Array<EventFragWhereUniqueInput>>;
  update?: InputMaybe<Array<EventFragUpdateWithWhereUniqueWithoutVictimInput>>;
  updateMany?: InputMaybe<Array<EventFragUpdateManyWithWhereWithoutVictimInput>>;
  upsert?: InputMaybe<Array<EventFragUpsertWithWhereUniqueWithoutVictimInput>>;
};

export type EventFragUpdateWithWhereUniqueWithoutKillerInput = {
  data: EventFragUpdateWithoutKillerInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragUpdateWithWhereUniqueWithoutServerInput = {
  data: EventFragUpdateWithoutServerInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragUpdateWithWhereUniqueWithoutVictimInput = {
  data: EventFragUpdateWithoutVictimInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragUpdateWithoutKillerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  headshot?: InputMaybe<IntFieldUpdateOperationsInput>;
  killerRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsFragNestedInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutFragsAsVictimNestedInput>;
  victimRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventFragUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  headshot?: InputMaybe<IntFieldUpdateOperationsInput>;
  killer?: InputMaybe<PlayerUpdateOneRequiredWithoutFragsAsKillerNestedInput>;
  killerRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutFragsAsVictimNestedInput>;
  victimRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventFragUpdateWithoutVictimInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  headshot?: InputMaybe<IntFieldUpdateOperationsInput>;
  killer?: InputMaybe<PlayerUpdateOneRequiredWithoutFragsAsKillerNestedInput>;
  killerRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsFragNestedInput>;
  victimRole?: InputMaybe<StringFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventFragUpsertWithWhereUniqueWithoutKillerInput = {
  create: EventFragCreateWithoutKillerInput;
  update: EventFragUpdateWithoutKillerInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragUpsertWithWhereUniqueWithoutServerInput = {
  create: EventFragCreateWithoutServerInput;
  update: EventFragUpdateWithoutServerInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragUpsertWithWhereUniqueWithoutVictimInput = {
  create: EventFragCreateWithoutVictimInput;
  update: EventFragUpdateWithoutVictimInput;
  where: EventFragWhereUniqueInput;
};

export type EventFragWhereInput = {
  AND?: InputMaybe<Array<EventFragWhereInput>>;
  NOT?: InputMaybe<Array<EventFragWhereInput>>;
  OR?: InputMaybe<Array<EventFragWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  headshot?: InputMaybe<IntFilter>;
  id?: InputMaybe<IntFilter>;
  killer?: InputMaybe<PlayerWhereInput>;
  killerId?: InputMaybe<IntFilter>;
  killerRole?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  victim?: InputMaybe<PlayerWhereInput>;
  victimId?: InputMaybe<IntFilter>;
  victimRole?: InputMaybe<StringFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventFragWhereUniqueInput = {
  AND?: InputMaybe<Array<EventFragWhereInput>>;
  NOT?: InputMaybe<Array<EventFragWhereInput>>;
  OR?: InputMaybe<Array<EventFragWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  headshot?: InputMaybe<IntFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killer?: InputMaybe<PlayerWhereInput>;
  killerId?: InputMaybe<IntFilter>;
  killerRole?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  victim?: InputMaybe<PlayerWhereInput>;
  victimId?: InputMaybe<IntFilter>;
  victimRole?: InputMaybe<StringFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventLatency = {
  __typename?: 'EventLatency';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  ping: Scalars['Int']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventLatencyAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  ping?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventLatencyCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  ping?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventLatencyCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  ping?: InputMaybe<Scalars['Int']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutLatencyEventsInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsLatencyInput>;
};

export type EventLatencyCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  ping?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventLatencyCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  ping?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventLatencyCreateManyPlayerInputEnvelope = {
  data: Array<EventLatencyCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventLatencyCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  ping?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventLatencyCreateManyServerInputEnvelope = {
  data: Array<EventLatencyCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventLatencyCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventLatencyCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventLatencyCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventLatencyCreateManyPlayerInputEnvelope>;
};

export type EventLatencyCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventLatencyCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventLatencyCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventLatencyCreateManyServerInputEnvelope>;
};

export type EventLatencyCreateOrConnectWithoutPlayerInput = {
  create: EventLatencyCreateWithoutPlayerInput;
  where: EventLatencyWhereUniqueInput;
};

export type EventLatencyCreateOrConnectWithoutServerInput = {
  create: EventLatencyCreateWithoutServerInput;
  where: EventLatencyWhereUniqueInput;
};

export type EventLatencyCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  ping?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsLatencyInput>;
};

export type EventLatencyCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  ping?: InputMaybe<Scalars['Int']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutLatencyEventsInput>;
};

export type EventLatencyListRelationFilter = {
  every?: InputMaybe<EventLatencyWhereInput>;
  none?: InputMaybe<EventLatencyWhereInput>;
  some?: InputMaybe<EventLatencyWhereInput>;
};

export type EventLatencyMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  ping?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventLatencyMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  ping?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventLatencyOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventLatencyOrderByRelevanceFieldEnum {
  Map = 'map'
}

export type EventLatencyOrderByRelevanceInput = {
  fields: Array<EventLatencyOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventLatencyOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventLatencyAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventLatencyCountOrderByAggregateInput>;
  _max?: InputMaybe<EventLatencyMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventLatencyMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventLatencySumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  ping?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventLatencyOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventLatencyOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  ping?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventLatencyScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  Ping = 'ping',
  PlayerId = 'playerId',
  ServerId = 'serverId'
}

export type EventLatencyScalarWhereInput = {
  AND?: InputMaybe<Array<EventLatencyScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventLatencyScalarWhereInput>>;
  OR?: InputMaybe<Array<EventLatencyScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  ping?: InputMaybe<IntFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventLatencyScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventLatencyScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventLatencyScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventLatencyScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  ping?: InputMaybe<IntWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventLatencySumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  ping?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventLatencyUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  ping?: InputMaybe<IntFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutLatencyEventsNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsLatencyNestedInput>;
};

export type EventLatencyUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  ping?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type EventLatencyUpdateManyWithWhereWithoutPlayerInput = {
  data: EventLatencyUpdateManyMutationInput;
  where: EventLatencyScalarWhereInput;
};

export type EventLatencyUpdateManyWithWhereWithoutServerInput = {
  data: EventLatencyUpdateManyMutationInput;
  where: EventLatencyScalarWhereInput;
};

export type EventLatencyUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventLatencyCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventLatencyCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventLatencyCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventLatencyScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  set?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  update?: InputMaybe<Array<EventLatencyUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventLatencyUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventLatencyUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventLatencyUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventLatencyCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventLatencyCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventLatencyCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventLatencyScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  set?: InputMaybe<Array<EventLatencyWhereUniqueInput>>;
  update?: InputMaybe<Array<EventLatencyUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventLatencyUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventLatencyUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventLatencyUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventLatencyUpdateWithoutPlayerInput;
  where: EventLatencyWhereUniqueInput;
};

export type EventLatencyUpdateWithWhereUniqueWithoutServerInput = {
  data: EventLatencyUpdateWithoutServerInput;
  where: EventLatencyWhereUniqueInput;
};

export type EventLatencyUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  ping?: InputMaybe<IntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsLatencyNestedInput>;
};

export type EventLatencyUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  ping?: InputMaybe<IntFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutLatencyEventsNestedInput>;
};

export type EventLatencyUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventLatencyCreateWithoutPlayerInput;
  update: EventLatencyUpdateWithoutPlayerInput;
  where: EventLatencyWhereUniqueInput;
};

export type EventLatencyUpsertWithWhereUniqueWithoutServerInput = {
  create: EventLatencyCreateWithoutServerInput;
  update: EventLatencyUpdateWithoutServerInput;
  where: EventLatencyWhereUniqueInput;
};

export type EventLatencyWhereInput = {
  AND?: InputMaybe<Array<EventLatencyWhereInput>>;
  NOT?: InputMaybe<Array<EventLatencyWhereInput>>;
  OR?: InputMaybe<Array<EventLatencyWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  ping?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventLatencyWhereUniqueInput = {
  AND?: InputMaybe<Array<EventLatencyWhereInput>>;
  NOT?: InputMaybe<Array<EventLatencyWhereInput>>;
  OR?: InputMaybe<Array<EventLatencyWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  ping?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventPlayerAction = {
  __typename?: 'EventPlayerAction';
  action: Action;
  actionId: Scalars['Int']['output'];
  bonus: Scalars['Int']['output'];
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  posX?: Maybe<Scalars['Int']['output']>;
  posY?: Maybe<Scalars['Int']['output']>;
  posZ?: Maybe<Scalars['Int']['output']>;
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventPlayerActionAvgOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventPlayerActionCountOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventPlayerActionCreateInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventPlayerActionsInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutPlayerActionsInput>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsPlayerActionInput>;
};

export type EventPlayerActionCreateManyActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerActionCreateManyActionInputEnvelope = {
  data: Array<EventPlayerActionCreateManyActionInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventPlayerActionCreateManyInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerActionCreateManyPlayerInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerActionCreateManyPlayerInputEnvelope = {
  data: Array<EventPlayerActionCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventPlayerActionCreateManyServerInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerActionCreateManyServerInputEnvelope = {
  data: Array<EventPlayerActionCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventPlayerActionCreateNestedManyWithoutActionInput = {
  connect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerActionCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventPlayerActionCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventPlayerActionCreateManyActionInputEnvelope>;
};

export type EventPlayerActionCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerActionCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventPlayerActionCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventPlayerActionCreateManyPlayerInputEnvelope>;
};

export type EventPlayerActionCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerActionCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventPlayerActionCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventPlayerActionCreateManyServerInputEnvelope>;
};

export type EventPlayerActionCreateOrConnectWithoutActionInput = {
  create: EventPlayerActionCreateWithoutActionInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionCreateOrConnectWithoutPlayerInput = {
  create: EventPlayerActionCreateWithoutPlayerInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionCreateOrConnectWithoutServerInput = {
  create: EventPlayerActionCreateWithoutServerInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionCreateWithoutActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutPlayerActionsInput>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsPlayerActionInput>;
};

export type EventPlayerActionCreateWithoutPlayerInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventPlayerActionsInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsPlayerActionInput>;
};

export type EventPlayerActionCreateWithoutServerInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventPlayerActionsInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutPlayerActionsInput>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerActionListRelationFilter = {
  every?: InputMaybe<EventPlayerActionWhereInput>;
  none?: InputMaybe<EventPlayerActionWhereInput>;
  some?: InputMaybe<EventPlayerActionWhereInput>;
};

export type EventPlayerActionMaxOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventPlayerActionMinOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventPlayerActionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventPlayerActionOrderByRelevanceFieldEnum {
  Map = 'map'
}

export type EventPlayerActionOrderByRelevanceInput = {
  fields: Array<EventPlayerActionOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventPlayerActionOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventPlayerActionAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventPlayerActionCountOrderByAggregateInput>;
  _max?: InputMaybe<EventPlayerActionMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventPlayerActionMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventPlayerActionSumOrderByAggregateInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventPlayerActionOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventPlayerActionOrderByRelevanceInput>;
  action?: InputMaybe<ActionOrderByWithRelationInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventPlayerActionScalarFieldEnum {
  ActionId = 'actionId',
  Bonus = 'bonus',
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  PosX = 'posX',
  PosY = 'posY',
  PosZ = 'posZ',
  ServerId = 'serverId'
}

export type EventPlayerActionScalarWhereInput = {
  AND?: InputMaybe<Array<EventPlayerActionScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventPlayerActionScalarWhereInput>>;
  OR?: InputMaybe<Array<EventPlayerActionScalarWhereInput>>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventPlayerActionScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventPlayerActionScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventPlayerActionScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventPlayerActionScalarWhereWithAggregatesInput>>;
  actionId?: InputMaybe<IntWithAggregatesFilter>;
  bonus?: InputMaybe<IntWithAggregatesFilter>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  posX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventPlayerActionSumOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventPlayerActionUpdateInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventPlayerActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerActionsNestedInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsPlayerActionNestedInput>;
};

export type EventPlayerActionUpdateManyMutationInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
};

export type EventPlayerActionUpdateManyWithWhereWithoutActionInput = {
  data: EventPlayerActionUpdateManyMutationInput;
  where: EventPlayerActionScalarWhereInput;
};

export type EventPlayerActionUpdateManyWithWhereWithoutPlayerInput = {
  data: EventPlayerActionUpdateManyMutationInput;
  where: EventPlayerActionScalarWhereInput;
};

export type EventPlayerActionUpdateManyWithWhereWithoutServerInput = {
  data: EventPlayerActionUpdateManyMutationInput;
  where: EventPlayerActionScalarWhereInput;
};

export type EventPlayerActionUpdateManyWithoutActionNestedInput = {
  connect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerActionCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventPlayerActionCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventPlayerActionCreateManyActionInputEnvelope>;
  delete?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventPlayerActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventPlayerActionUpdateWithWhereUniqueWithoutActionInput>>;
  updateMany?: InputMaybe<Array<EventPlayerActionUpdateManyWithWhereWithoutActionInput>>;
  upsert?: InputMaybe<Array<EventPlayerActionUpsertWithWhereUniqueWithoutActionInput>>;
};

export type EventPlayerActionUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerActionCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventPlayerActionCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventPlayerActionCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventPlayerActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventPlayerActionUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventPlayerActionUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventPlayerActionUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventPlayerActionUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerActionCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventPlayerActionCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventPlayerActionCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventPlayerActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventPlayerActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventPlayerActionUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventPlayerActionUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventPlayerActionUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventPlayerActionUpdateWithWhereUniqueWithoutActionInput = {
  data: EventPlayerActionUpdateWithoutActionInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventPlayerActionUpdateWithoutPlayerInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionUpdateWithWhereUniqueWithoutServerInput = {
  data: EventPlayerActionUpdateWithoutServerInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionUpdateWithoutActionInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerActionsNestedInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsPlayerActionNestedInput>;
};

export type EventPlayerActionUpdateWithoutPlayerInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventPlayerActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsPlayerActionNestedInput>;
};

export type EventPlayerActionUpdateWithoutServerInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventPlayerActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerActionsNestedInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
};

export type EventPlayerActionUpsertWithWhereUniqueWithoutActionInput = {
  create: EventPlayerActionCreateWithoutActionInput;
  update: EventPlayerActionUpdateWithoutActionInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventPlayerActionCreateWithoutPlayerInput;
  update: EventPlayerActionUpdateWithoutPlayerInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionUpsertWithWhereUniqueWithoutServerInput = {
  create: EventPlayerActionCreateWithoutServerInput;
  update: EventPlayerActionUpdateWithoutServerInput;
  where: EventPlayerActionWhereUniqueInput;
};

export type EventPlayerActionWhereInput = {
  AND?: InputMaybe<Array<EventPlayerActionWhereInput>>;
  NOT?: InputMaybe<Array<EventPlayerActionWhereInput>>;
  OR?: InputMaybe<Array<EventPlayerActionWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventPlayerActionWhereUniqueInput = {
  AND?: InputMaybe<Array<EventPlayerActionWhereInput>>;
  NOT?: InputMaybe<Array<EventPlayerActionWhereInput>>;
  OR?: InputMaybe<Array<EventPlayerActionWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventPlayerPlayerAction = {
  __typename?: 'EventPlayerPlayerAction';
  action: Action;
  actionId: Scalars['Int']['output'];
  bonus: Scalars['Int']['output'];
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  posVictimX?: Maybe<Scalars['Int']['output']>;
  posVictimY?: Maybe<Scalars['Int']['output']>;
  posVictimZ?: Maybe<Scalars['Int']['output']>;
  posX?: Maybe<Scalars['Int']['output']>;
  posY?: Maybe<Scalars['Int']['output']>;
  posZ?: Maybe<Scalars['Int']['output']>;
  server: Server;
  serverId: Scalars['Int']['output'];
  victim: Player;
  victimId: Scalars['Int']['output'];
};

export type EventPlayerPlayerActionAvgOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventPlayerPlayerActionCountOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventPlayerPlayerActionCreateInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventPlayerPlayerActionsInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsActorInput>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsPlayerPlayerActionInput>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsVictimInput>;
};

export type EventPlayerPlayerActionCreateManyActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerPlayerActionCreateManyActionInputEnvelope = {
  data: Array<EventPlayerPlayerActionCreateManyActionInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventPlayerPlayerActionCreateManyInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerPlayerActionCreateManyPlayerInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerPlayerActionCreateManyPlayerInputEnvelope = {
  data: Array<EventPlayerPlayerActionCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventPlayerPlayerActionCreateManyServerInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerPlayerActionCreateManyServerInputEnvelope = {
  data: Array<EventPlayerPlayerActionCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventPlayerPlayerActionCreateManyVictimInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventPlayerPlayerActionCreateManyVictimInputEnvelope = {
  data: Array<EventPlayerPlayerActionCreateManyVictimInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventPlayerPlayerActionCreateNestedManyWithoutActionInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyActionInputEnvelope>;
};

export type EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyPlayerInputEnvelope>;
};

export type EventPlayerPlayerActionCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyServerInputEnvelope>;
};

export type EventPlayerPlayerActionCreateNestedManyWithoutVictimInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutVictimInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutVictimInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyVictimInputEnvelope>;
};

export type EventPlayerPlayerActionCreateOrConnectWithoutActionInput = {
  create: EventPlayerPlayerActionCreateWithoutActionInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionCreateOrConnectWithoutPlayerInput = {
  create: EventPlayerPlayerActionCreateWithoutPlayerInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionCreateOrConnectWithoutServerInput = {
  create: EventPlayerPlayerActionCreateWithoutServerInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionCreateOrConnectWithoutVictimInput = {
  create: EventPlayerPlayerActionCreateWithoutVictimInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionCreateWithoutActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsActorInput>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsPlayerPlayerActionInput>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsVictimInput>;
};

export type EventPlayerPlayerActionCreateWithoutPlayerInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventPlayerPlayerActionsInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsPlayerPlayerActionInput>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsVictimInput>;
};

export type EventPlayerPlayerActionCreateWithoutServerInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventPlayerPlayerActionsInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsActorInput>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsVictimInput>;
};

export type EventPlayerPlayerActionCreateWithoutVictimInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventPlayerPlayerActionsInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutPlayerPlayerActionsAsActorInput>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsPlayerPlayerActionInput>;
};

export type EventPlayerPlayerActionListRelationFilter = {
  every?: InputMaybe<EventPlayerPlayerActionWhereInput>;
  none?: InputMaybe<EventPlayerPlayerActionWhereInput>;
  some?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};

export type EventPlayerPlayerActionMaxOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventPlayerPlayerActionMinOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventPlayerPlayerActionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventPlayerPlayerActionOrderByRelevanceFieldEnum {
  Map = 'map'
}

export type EventPlayerPlayerActionOrderByRelevanceInput = {
  fields: Array<EventPlayerPlayerActionOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventPlayerPlayerActionOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventPlayerPlayerActionAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventPlayerPlayerActionCountOrderByAggregateInput>;
  _max?: InputMaybe<EventPlayerPlayerActionMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventPlayerPlayerActionMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventPlayerPlayerActionSumOrderByAggregateInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventPlayerPlayerActionOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventPlayerPlayerActionOrderByRelevanceInput>;
  action?: InputMaybe<ActionOrderByWithRelationInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  victim?: InputMaybe<PlayerOrderByWithRelationInput>;
  victimId?: InputMaybe<SortOrder>;
};

export enum EventPlayerPlayerActionScalarFieldEnum {
  ActionId = 'actionId',
  Bonus = 'bonus',
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  PosVictimX = 'posVictimX',
  PosVictimY = 'posVictimY',
  PosVictimZ = 'posVictimZ',
  PosX = 'posX',
  PosY = 'posY',
  PosZ = 'posZ',
  ServerId = 'serverId',
  VictimId = 'victimId'
}

export type EventPlayerPlayerActionScalarWhereInput = {
  AND?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereInput>>;
  OR?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereInput>>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  serverId?: InputMaybe<IntFilter>;
  victimId?: InputMaybe<IntFilter>;
};

export type EventPlayerPlayerActionScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereWithAggregatesInput>>;
  actionId?: InputMaybe<IntWithAggregatesFilter>;
  bonus?: InputMaybe<IntWithAggregatesFilter>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  posVictimX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posVictimY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posVictimZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  posX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  victimId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventPlayerPlayerActionSumOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventPlayerPlayerActionUpdateInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventPlayerPlayerActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsActorNestedInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsPlayerPlayerActionNestedInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsVictimNestedInput>;
};

export type EventPlayerPlayerActionUpdateManyMutationInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
};

export type EventPlayerPlayerActionUpdateManyWithWhereWithoutActionInput = {
  data: EventPlayerPlayerActionUpdateManyMutationInput;
  where: EventPlayerPlayerActionScalarWhereInput;
};

export type EventPlayerPlayerActionUpdateManyWithWhereWithoutPlayerInput = {
  data: EventPlayerPlayerActionUpdateManyMutationInput;
  where: EventPlayerPlayerActionScalarWhereInput;
};

export type EventPlayerPlayerActionUpdateManyWithWhereWithoutServerInput = {
  data: EventPlayerPlayerActionUpdateManyMutationInput;
  where: EventPlayerPlayerActionScalarWhereInput;
};

export type EventPlayerPlayerActionUpdateManyWithWhereWithoutVictimInput = {
  data: EventPlayerPlayerActionUpdateManyMutationInput;
  where: EventPlayerPlayerActionScalarWhereInput;
};

export type EventPlayerPlayerActionUpdateManyWithoutActionNestedInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyActionInputEnvelope>;
  delete?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventPlayerPlayerActionUpdateWithWhereUniqueWithoutActionInput>>;
  updateMany?: InputMaybe<Array<EventPlayerPlayerActionUpdateManyWithWhereWithoutActionInput>>;
  upsert?: InputMaybe<Array<EventPlayerPlayerActionUpsertWithWhereUniqueWithoutActionInput>>;
};

export type EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventPlayerPlayerActionUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventPlayerPlayerActionUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventPlayerPlayerActionUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventPlayerPlayerActionUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventPlayerPlayerActionUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventPlayerPlayerActionUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventPlayerPlayerActionUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput = {
  connect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventPlayerPlayerActionCreateOrConnectWithoutVictimInput>>;
  create?: InputMaybe<Array<EventPlayerPlayerActionCreateWithoutVictimInput>>;
  createMany?: InputMaybe<EventPlayerPlayerActionCreateManyVictimInputEnvelope>;
  delete?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventPlayerPlayerActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventPlayerPlayerActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventPlayerPlayerActionUpdateWithWhereUniqueWithoutVictimInput>>;
  updateMany?: InputMaybe<Array<EventPlayerPlayerActionUpdateManyWithWhereWithoutVictimInput>>;
  upsert?: InputMaybe<Array<EventPlayerPlayerActionUpsertWithWhereUniqueWithoutVictimInput>>;
};

export type EventPlayerPlayerActionUpdateWithWhereUniqueWithoutActionInput = {
  data: EventPlayerPlayerActionUpdateWithoutActionInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventPlayerPlayerActionUpdateWithoutPlayerInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionUpdateWithWhereUniqueWithoutServerInput = {
  data: EventPlayerPlayerActionUpdateWithoutServerInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionUpdateWithWhereUniqueWithoutVictimInput = {
  data: EventPlayerPlayerActionUpdateWithoutVictimInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionUpdateWithoutActionInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsActorNestedInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsPlayerPlayerActionNestedInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsVictimNestedInput>;
};

export type EventPlayerPlayerActionUpdateWithoutPlayerInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventPlayerPlayerActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsPlayerPlayerActionNestedInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsVictimNestedInput>;
};

export type EventPlayerPlayerActionUpdateWithoutServerInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventPlayerPlayerActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsActorNestedInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsVictimNestedInput>;
};

export type EventPlayerPlayerActionUpdateWithoutVictimInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventPlayerPlayerActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsActorNestedInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsPlayerPlayerActionNestedInput>;
};

export type EventPlayerPlayerActionUpsertWithWhereUniqueWithoutActionInput = {
  create: EventPlayerPlayerActionCreateWithoutActionInput;
  update: EventPlayerPlayerActionUpdateWithoutActionInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventPlayerPlayerActionCreateWithoutPlayerInput;
  update: EventPlayerPlayerActionUpdateWithoutPlayerInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionUpsertWithWhereUniqueWithoutServerInput = {
  create: EventPlayerPlayerActionCreateWithoutServerInput;
  update: EventPlayerPlayerActionUpdateWithoutServerInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionUpsertWithWhereUniqueWithoutVictimInput = {
  create: EventPlayerPlayerActionCreateWithoutVictimInput;
  update: EventPlayerPlayerActionUpdateWithoutVictimInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};

export type EventPlayerPlayerActionWhereInput = {
  AND?: InputMaybe<Array<EventPlayerPlayerActionWhereInput>>;
  NOT?: InputMaybe<Array<EventPlayerPlayerActionWhereInput>>;
  OR?: InputMaybe<Array<EventPlayerPlayerActionWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  victim?: InputMaybe<PlayerWhereInput>;
  victimId?: InputMaybe<IntFilter>;
};

export type EventPlayerPlayerActionWhereUniqueInput = {
  AND?: InputMaybe<Array<EventPlayerPlayerActionWhereInput>>;
  NOT?: InputMaybe<Array<EventPlayerPlayerActionWhereInput>>;
  OR?: InputMaybe<Array<EventPlayerPlayerActionWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  victim?: InputMaybe<PlayerWhereInput>;
  victimId?: InputMaybe<IntFilter>;
};

export type EventRcon = {
  __typename?: 'EventRcon';
  command: Scalars['String']['output'];
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  password: Scalars['String']['output'];
  remoteIp: Scalars['String']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type EventRconAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventRconCountOrderByAggregateInput = {
  command?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  remoteIp?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventRconCreateInput = {
  command?: InputMaybe<Scalars['String']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  remoteIp?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsRconInput>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventRconCreateManyInput = {
  command?: InputMaybe<Scalars['String']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  remoteIp?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventRconCreateManyServerInput = {
  command?: InputMaybe<Scalars['String']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  remoteIp?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventRconCreateManyServerInputEnvelope = {
  data: Array<EventRconCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventRconCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventRconWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventRconCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventRconCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventRconCreateManyServerInputEnvelope>;
};

export type EventRconCreateOrConnectWithoutServerInput = {
  create: EventRconCreateWithoutServerInput;
  where: EventRconWhereUniqueInput;
};

export type EventRconCreateWithoutServerInput = {
  command?: InputMaybe<Scalars['String']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  remoteIp?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type EventRconListRelationFilter = {
  every?: InputMaybe<EventRconWhereInput>;
  none?: InputMaybe<EventRconWhereInput>;
  some?: InputMaybe<EventRconWhereInput>;
};

export type EventRconMaxOrderByAggregateInput = {
  command?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  remoteIp?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventRconMinOrderByAggregateInput = {
  command?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  remoteIp?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventRconOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventRconOrderByRelevanceFieldEnum {
  Command = 'command',
  Map = 'map',
  Password = 'password',
  RemoteIp = 'remoteIp',
  Type = 'type'
}

export type EventRconOrderByRelevanceInput = {
  fields: Array<EventRconOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventRconOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventRconAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventRconCountOrderByAggregateInput>;
  _max?: InputMaybe<EventRconMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventRconMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventRconSumOrderByAggregateInput>;
  command?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  remoteIp?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export type EventRconOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventRconOrderByRelevanceInput>;
  command?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  remoteIp?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  type?: InputMaybe<SortOrder>;
};

export enum EventRconScalarFieldEnum {
  Command = 'command',
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  Password = 'password',
  RemoteIp = 'remoteIp',
  ServerId = 'serverId',
  Type = 'type'
}

export type EventRconScalarWhereInput = {
  AND?: InputMaybe<Array<EventRconScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventRconScalarWhereInput>>;
  OR?: InputMaybe<Array<EventRconScalarWhereInput>>;
  command?: InputMaybe<StringFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  password?: InputMaybe<StringFilter>;
  remoteIp?: InputMaybe<StringFilter>;
  serverId?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
};

export type EventRconScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventRconScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventRconScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventRconScalarWhereWithAggregatesInput>>;
  command?: InputMaybe<StringWithAggregatesFilter>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  password?: InputMaybe<StringWithAggregatesFilter>;
  remoteIp?: InputMaybe<StringWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  type?: InputMaybe<StringWithAggregatesFilter>;
};

export type EventRconSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventRconUpdateInput = {
  command?: InputMaybe<StringFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  password?: InputMaybe<StringFieldUpdateOperationsInput>;
  remoteIp?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsRconNestedInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventRconUpdateManyMutationInput = {
  command?: InputMaybe<StringFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  password?: InputMaybe<StringFieldUpdateOperationsInput>;
  remoteIp?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventRconUpdateManyWithWhereWithoutServerInput = {
  data: EventRconUpdateManyMutationInput;
  where: EventRconScalarWhereInput;
};

export type EventRconUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventRconWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventRconCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventRconCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventRconCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventRconWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventRconScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventRconWhereUniqueInput>>;
  set?: InputMaybe<Array<EventRconWhereUniqueInput>>;
  update?: InputMaybe<Array<EventRconUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventRconUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventRconUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventRconUpdateWithWhereUniqueWithoutServerInput = {
  data: EventRconUpdateWithoutServerInput;
  where: EventRconWhereUniqueInput;
};

export type EventRconUpdateWithoutServerInput = {
  command?: InputMaybe<StringFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  password?: InputMaybe<StringFieldUpdateOperationsInput>;
  remoteIp?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventRconUpsertWithWhereUniqueWithoutServerInput = {
  create: EventRconCreateWithoutServerInput;
  update: EventRconUpdateWithoutServerInput;
  where: EventRconWhereUniqueInput;
};

export type EventRconWhereInput = {
  AND?: InputMaybe<Array<EventRconWhereInput>>;
  NOT?: InputMaybe<Array<EventRconWhereInput>>;
  OR?: InputMaybe<Array<EventRconWhereInput>>;
  command?: InputMaybe<StringFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  password?: InputMaybe<StringFilter>;
  remoteIp?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
};

export type EventRconWhereUniqueInput = {
  AND?: InputMaybe<Array<EventRconWhereInput>>;
  NOT?: InputMaybe<Array<EventRconWhereInput>>;
  OR?: InputMaybe<Array<EventRconWhereInput>>;
  command?: InputMaybe<StringFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  password?: InputMaybe<StringFilter>;
  remoteIp?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  type?: InputMaybe<StringFilter>;
};

export type EventSuicide = {
  __typename?: 'EventSuicide';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  posX?: Maybe<Scalars['Int']['output']>;
  posY?: Maybe<Scalars['Int']['output']>;
  posZ?: Maybe<Scalars['Int']['output']>;
  server: Server;
  serverId: Scalars['Int']['output'];
  weapon: Scalars['String']['output'];
};

export type EventSuicideAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventSuicideCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventSuicideCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutSuicideEventsInput>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsSuicideInput>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventSuicideCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventSuicideCreateManyPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventSuicideCreateManyPlayerInputEnvelope = {
  data: Array<EventSuicideCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventSuicideCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventSuicideCreateManyServerInputEnvelope = {
  data: Array<EventSuicideCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventSuicideCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventSuicideCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventSuicideCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventSuicideCreateManyPlayerInputEnvelope>;
};

export type EventSuicideCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventSuicideCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventSuicideCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventSuicideCreateManyServerInputEnvelope>;
};

export type EventSuicideCreateOrConnectWithoutPlayerInput = {
  create: EventSuicideCreateWithoutPlayerInput;
  where: EventSuicideWhereUniqueInput;
};

export type EventSuicideCreateOrConnectWithoutServerInput = {
  create: EventSuicideCreateWithoutServerInput;
  where: EventSuicideWhereUniqueInput;
};

export type EventSuicideCreateWithoutPlayerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsSuicideInput>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventSuicideCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutSuicideEventsInput>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventSuicideListRelationFilter = {
  every?: InputMaybe<EventSuicideWhereInput>;
  none?: InputMaybe<EventSuicideWhereInput>;
  some?: InputMaybe<EventSuicideWhereInput>;
};

export type EventSuicideMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventSuicideMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventSuicideOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventSuicideOrderByRelevanceFieldEnum {
  Map = 'map',
  Weapon = 'weapon'
}

export type EventSuicideOrderByRelevanceInput = {
  fields: Array<EventSuicideOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventSuicideOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventSuicideAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventSuicideCountOrderByAggregateInput>;
  _max?: InputMaybe<EventSuicideMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventSuicideMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventSuicideSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventSuicideOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventSuicideOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export enum EventSuicideScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  PosX = 'posX',
  PosY = 'posY',
  PosZ = 'posZ',
  ServerId = 'serverId',
  Weapon = 'weapon'
}

export type EventSuicideScalarWhereInput = {
  AND?: InputMaybe<Array<EventSuicideScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventSuicideScalarWhereInput>>;
  OR?: InputMaybe<Array<EventSuicideScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  serverId?: InputMaybe<IntFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventSuicideScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventSuicideScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventSuicideScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventSuicideScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  posX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  weapon?: InputMaybe<StringWithAggregatesFilter>;
};

export type EventSuicideSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventSuicideUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutSuicideEventsNestedInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsSuicideNestedInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventSuicideUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventSuicideUpdateManyWithWhereWithoutPlayerInput = {
  data: EventSuicideUpdateManyMutationInput;
  where: EventSuicideScalarWhereInput;
};

export type EventSuicideUpdateManyWithWhereWithoutServerInput = {
  data: EventSuicideUpdateManyMutationInput;
  where: EventSuicideScalarWhereInput;
};

export type EventSuicideUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventSuicideCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventSuicideCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventSuicideCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventSuicideScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  set?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  update?: InputMaybe<Array<EventSuicideUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventSuicideUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventSuicideUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventSuicideUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventSuicideCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventSuicideCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventSuicideCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventSuicideScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  set?: InputMaybe<Array<EventSuicideWhereUniqueInput>>;
  update?: InputMaybe<Array<EventSuicideUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventSuicideUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventSuicideUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventSuicideUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventSuicideUpdateWithoutPlayerInput;
  where: EventSuicideWhereUniqueInput;
};

export type EventSuicideUpdateWithWhereUniqueWithoutServerInput = {
  data: EventSuicideUpdateWithoutServerInput;
  where: EventSuicideWhereUniqueInput;
};

export type EventSuicideUpdateWithoutPlayerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsSuicideNestedInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventSuicideUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutSuicideEventsNestedInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventSuicideUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventSuicideCreateWithoutPlayerInput;
  update: EventSuicideUpdateWithoutPlayerInput;
  where: EventSuicideWhereUniqueInput;
};

export type EventSuicideUpsertWithWhereUniqueWithoutServerInput = {
  create: EventSuicideCreateWithoutServerInput;
  update: EventSuicideUpdateWithoutServerInput;
  where: EventSuicideWhereUniqueInput;
};

export type EventSuicideWhereInput = {
  AND?: InputMaybe<Array<EventSuicideWhereInput>>;
  NOT?: InputMaybe<Array<EventSuicideWhereInput>>;
  OR?: InputMaybe<Array<EventSuicideWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventSuicideWhereUniqueInput = {
  AND?: InputMaybe<Array<EventSuicideWhereInput>>;
  NOT?: InputMaybe<Array<EventSuicideWhereInput>>;
  OR?: InputMaybe<Array<EventSuicideWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventTeamBonus = {
  __typename?: 'EventTeamBonus';
  action: Action;
  actionId: Scalars['Int']['output'];
  bonus: Scalars['Int']['output'];
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
};

export type EventTeamBonusAvgOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventTeamBonusCountOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventTeamBonusCreateInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventTeamBonusesInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutTeamBonusesInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsTeamBonusInput>;
};

export type EventTeamBonusCreateManyActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventTeamBonusCreateManyActionInputEnvelope = {
  data: Array<EventTeamBonusCreateManyActionInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventTeamBonusCreateManyInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventTeamBonusCreateManyPlayerInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventTeamBonusCreateManyPlayerInputEnvelope = {
  data: Array<EventTeamBonusCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventTeamBonusCreateManyServerInput = {
  actionId?: InputMaybe<Scalars['Int']['input']>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
};

export type EventTeamBonusCreateManyServerInputEnvelope = {
  data: Array<EventTeamBonusCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventTeamBonusCreateNestedManyWithoutActionInput = {
  connect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamBonusCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventTeamBonusCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventTeamBonusCreateManyActionInputEnvelope>;
};

export type EventTeamBonusCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamBonusCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventTeamBonusCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventTeamBonusCreateManyPlayerInputEnvelope>;
};

export type EventTeamBonusCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamBonusCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventTeamBonusCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventTeamBonusCreateManyServerInputEnvelope>;
};

export type EventTeamBonusCreateOrConnectWithoutActionInput = {
  create: EventTeamBonusCreateWithoutActionInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusCreateOrConnectWithoutPlayerInput = {
  create: EventTeamBonusCreateWithoutPlayerInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusCreateOrConnectWithoutServerInput = {
  create: EventTeamBonusCreateWithoutServerInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusCreateWithoutActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutTeamBonusesInput>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsTeamBonusInput>;
};

export type EventTeamBonusCreateWithoutPlayerInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventTeamBonusesInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsTeamBonusInput>;
};

export type EventTeamBonusCreateWithoutServerInput = {
  action?: InputMaybe<ActionCreateNestedOneWithoutEventTeamBonusesInput>;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  player?: InputMaybe<PlayerCreateNestedOneWithoutTeamBonusesInput>;
};

export type EventTeamBonusListRelationFilter = {
  every?: InputMaybe<EventTeamBonusWhereInput>;
  none?: InputMaybe<EventTeamBonusWhereInput>;
  some?: InputMaybe<EventTeamBonusWhereInput>;
};

export type EventTeamBonusMaxOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventTeamBonusMinOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventTeamBonusOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventTeamBonusOrderByRelevanceFieldEnum {
  Map = 'map'
}

export type EventTeamBonusOrderByRelevanceInput = {
  fields: Array<EventTeamBonusOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventTeamBonusOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventTeamBonusAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventTeamBonusCountOrderByAggregateInput>;
  _max?: InputMaybe<EventTeamBonusMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventTeamBonusMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventTeamBonusSumOrderByAggregateInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventTeamBonusOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventTeamBonusOrderByRelevanceInput>;
  action?: InputMaybe<ActionOrderByWithRelationInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventTeamBonusScalarFieldEnum {
  ActionId = 'actionId',
  Bonus = 'bonus',
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  PlayerId = 'playerId',
  ServerId = 'serverId'
}

export type EventTeamBonusScalarWhereInput = {
  AND?: InputMaybe<Array<EventTeamBonusScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventTeamBonusScalarWhereInput>>;
  OR?: InputMaybe<Array<EventTeamBonusScalarWhereInput>>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventTeamBonusScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventTeamBonusScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventTeamBonusScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventTeamBonusScalarWhereWithAggregatesInput>>;
  actionId?: InputMaybe<IntWithAggregatesFilter>;
  bonus?: InputMaybe<IntWithAggregatesFilter>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventTeamBonusSumOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventTeamBonusUpdateInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventTeamBonusesNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamBonusesNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsTeamBonusNestedInput>;
};

export type EventTeamBonusUpdateManyMutationInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventTeamBonusUpdateManyWithWhereWithoutActionInput = {
  data: EventTeamBonusUpdateManyMutationInput;
  where: EventTeamBonusScalarWhereInput;
};

export type EventTeamBonusUpdateManyWithWhereWithoutPlayerInput = {
  data: EventTeamBonusUpdateManyMutationInput;
  where: EventTeamBonusScalarWhereInput;
};

export type EventTeamBonusUpdateManyWithWhereWithoutServerInput = {
  data: EventTeamBonusUpdateManyMutationInput;
  where: EventTeamBonusScalarWhereInput;
};

export type EventTeamBonusUpdateManyWithoutActionNestedInput = {
  connect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamBonusCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventTeamBonusCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventTeamBonusCreateManyActionInputEnvelope>;
  delete?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventTeamBonusScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  set?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  update?: InputMaybe<Array<EventTeamBonusUpdateWithWhereUniqueWithoutActionInput>>;
  updateMany?: InputMaybe<Array<EventTeamBonusUpdateManyWithWhereWithoutActionInput>>;
  upsert?: InputMaybe<Array<EventTeamBonusUpsertWithWhereUniqueWithoutActionInput>>;
};

export type EventTeamBonusUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamBonusCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<EventTeamBonusCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<EventTeamBonusCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventTeamBonusScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  set?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  update?: InputMaybe<Array<EventTeamBonusUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<EventTeamBonusUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<EventTeamBonusUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type EventTeamBonusUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamBonusCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventTeamBonusCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventTeamBonusCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventTeamBonusScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  set?: InputMaybe<Array<EventTeamBonusWhereUniqueInput>>;
  update?: InputMaybe<Array<EventTeamBonusUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventTeamBonusUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventTeamBonusUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventTeamBonusUpdateWithWhereUniqueWithoutActionInput = {
  data: EventTeamBonusUpdateWithoutActionInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusUpdateWithWhereUniqueWithoutPlayerInput = {
  data: EventTeamBonusUpdateWithoutPlayerInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusUpdateWithWhereUniqueWithoutServerInput = {
  data: EventTeamBonusUpdateWithoutServerInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusUpdateWithoutActionInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamBonusesNestedInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsTeamBonusNestedInput>;
};

export type EventTeamBonusUpdateWithoutPlayerInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventTeamBonusesNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsTeamBonusNestedInput>;
};

export type EventTeamBonusUpdateWithoutServerInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventTeamBonusesNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamBonusesNestedInput>;
};

export type EventTeamBonusUpsertWithWhereUniqueWithoutActionInput = {
  create: EventTeamBonusCreateWithoutActionInput;
  update: EventTeamBonusUpdateWithoutActionInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusUpsertWithWhereUniqueWithoutPlayerInput = {
  create: EventTeamBonusCreateWithoutPlayerInput;
  update: EventTeamBonusUpdateWithoutPlayerInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusUpsertWithWhereUniqueWithoutServerInput = {
  create: EventTeamBonusCreateWithoutServerInput;
  update: EventTeamBonusUpdateWithoutServerInput;
  where: EventTeamBonusWhereUniqueInput;
};

export type EventTeamBonusWhereInput = {
  AND?: InputMaybe<Array<EventTeamBonusWhereInput>>;
  NOT?: InputMaybe<Array<EventTeamBonusWhereInput>>;
  OR?: InputMaybe<Array<EventTeamBonusWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventTeamBonusWhereUniqueInput = {
  AND?: InputMaybe<Array<EventTeamBonusWhereInput>>;
  NOT?: InputMaybe<Array<EventTeamBonusWhereInput>>;
  OR?: InputMaybe<Array<EventTeamBonusWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventTeamkill = {
  __typename?: 'EventTeamkill';
  eventTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  killer: Player;
  killerId: Scalars['Int']['output'];
  map: Scalars['String']['output'];
  posVictimX?: Maybe<Scalars['Int']['output']>;
  posVictimY?: Maybe<Scalars['Int']['output']>;
  posVictimZ?: Maybe<Scalars['Int']['output']>;
  posX?: Maybe<Scalars['Int']['output']>;
  posY?: Maybe<Scalars['Int']['output']>;
  posZ?: Maybe<Scalars['Int']['output']>;
  server: Server;
  serverId: Scalars['Int']['output'];
  victim: Player;
  victimId: Scalars['Int']['output'];
  weapon: Scalars['String']['output'];
};

export type EventTeamkillAvgOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventTeamkillCountOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventTeamkillCreateInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  killer?: InputMaybe<PlayerCreateNestedOneWithoutTeamkillsAsKillerInput>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsTeamkillInput>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutTeamkillsAsVictimInput>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillCreateManyInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killerId?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillCreateManyKillerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillCreateManyKillerInputEnvelope = {
  data: Array<EventTeamkillCreateManyKillerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventTeamkillCreateManyServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killerId?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  victimId?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillCreateManyServerInputEnvelope = {
  data: Array<EventTeamkillCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventTeamkillCreateManyVictimInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killerId?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillCreateManyVictimInputEnvelope = {
  data: Array<EventTeamkillCreateManyVictimInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventTeamkillCreateNestedManyWithoutKillerInput = {
  connect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamkillCreateOrConnectWithoutKillerInput>>;
  create?: InputMaybe<Array<EventTeamkillCreateWithoutKillerInput>>;
  createMany?: InputMaybe<EventTeamkillCreateManyKillerInputEnvelope>;
};

export type EventTeamkillCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamkillCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventTeamkillCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventTeamkillCreateManyServerInputEnvelope>;
};

export type EventTeamkillCreateNestedManyWithoutVictimInput = {
  connect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamkillCreateOrConnectWithoutVictimInput>>;
  create?: InputMaybe<Array<EventTeamkillCreateWithoutVictimInput>>;
  createMany?: InputMaybe<EventTeamkillCreateManyVictimInputEnvelope>;
};

export type EventTeamkillCreateOrConnectWithoutKillerInput = {
  create: EventTeamkillCreateWithoutKillerInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillCreateOrConnectWithoutServerInput = {
  create: EventTeamkillCreateWithoutServerInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillCreateOrConnectWithoutVictimInput = {
  create: EventTeamkillCreateWithoutVictimInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillCreateWithoutKillerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsTeamkillInput>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutTeamkillsAsVictimInput>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillCreateWithoutServerInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  killer?: InputMaybe<PlayerCreateNestedOneWithoutTeamkillsAsKillerInput>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  victim?: InputMaybe<PlayerCreateNestedOneWithoutTeamkillsAsVictimInput>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillCreateWithoutVictimInput = {
  eventTime?: InputMaybe<Scalars['DateTime']['input']>;
  killer?: InputMaybe<PlayerCreateNestedOneWithoutTeamkillsAsKillerInput>;
  map?: InputMaybe<Scalars['String']['input']>;
  posVictimX?: InputMaybe<Scalars['Int']['input']>;
  posVictimY?: InputMaybe<Scalars['Int']['input']>;
  posVictimZ?: InputMaybe<Scalars['Int']['input']>;
  posX?: InputMaybe<Scalars['Int']['input']>;
  posY?: InputMaybe<Scalars['Int']['input']>;
  posZ?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutEventsTeamkillInput>;
  weapon?: InputMaybe<Scalars['String']['input']>;
};

export type EventTeamkillListRelationFilter = {
  every?: InputMaybe<EventTeamkillWhereInput>;
  none?: InputMaybe<EventTeamkillWhereInput>;
  some?: InputMaybe<EventTeamkillWhereInput>;
};

export type EventTeamkillMaxOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventTeamkillMinOrderByAggregateInput = {
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventTeamkillOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventTeamkillOrderByRelevanceFieldEnum {
  Map = 'map',
  Weapon = 'weapon'
}

export type EventTeamkillOrderByRelevanceInput = {
  fields: Array<EventTeamkillOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventTeamkillOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventTeamkillAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventTeamkillCountOrderByAggregateInput>;
  _max?: InputMaybe<EventTeamkillMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventTeamkillMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventTeamkillSumOrderByAggregateInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export type EventTeamkillOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventTeamkillOrderByRelevanceInput>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  killer?: InputMaybe<PlayerOrderByWithRelationInput>;
  killerId?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  victim?: InputMaybe<PlayerOrderByWithRelationInput>;
  victimId?: InputMaybe<SortOrder>;
  weapon?: InputMaybe<SortOrder>;
};

export enum EventTeamkillScalarFieldEnum {
  EventTime = 'eventTime',
  Id = 'id',
  KillerId = 'killerId',
  Map = 'map',
  PosVictimX = 'posVictimX',
  PosVictimY = 'posVictimY',
  PosVictimZ = 'posVictimZ',
  PosX = 'posX',
  PosY = 'posY',
  PosZ = 'posZ',
  ServerId = 'serverId',
  VictimId = 'victimId',
  Weapon = 'weapon'
}

export type EventTeamkillScalarWhereInput = {
  AND?: InputMaybe<Array<EventTeamkillScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventTeamkillScalarWhereInput>>;
  OR?: InputMaybe<Array<EventTeamkillScalarWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  killerId?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  serverId?: InputMaybe<IntFilter>;
  victimId?: InputMaybe<IntFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventTeamkillScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventTeamkillScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventTeamkillScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventTeamkillScalarWhereWithAggregatesInput>>;
  eventTime?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  killerId?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  posVictimX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posVictimY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posVictimZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  posX?: InputMaybe<IntNullableWithAggregatesFilter>;
  posY?: InputMaybe<IntNullableWithAggregatesFilter>;
  posZ?: InputMaybe<IntNullableWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  victimId?: InputMaybe<IntWithAggregatesFilter>;
  weapon?: InputMaybe<StringWithAggregatesFilter>;
};

export type EventTeamkillSumOrderByAggregateInput = {
  id?: InputMaybe<SortOrder>;
  killerId?: InputMaybe<SortOrder>;
  posVictimX?: InputMaybe<SortOrder>;
  posVictimY?: InputMaybe<SortOrder>;
  posVictimZ?: InputMaybe<SortOrder>;
  posX?: InputMaybe<SortOrder>;
  posY?: InputMaybe<SortOrder>;
  posZ?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  victimId?: InputMaybe<SortOrder>;
};

export type EventTeamkillUpdateInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  killer?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamkillsAsKillerNestedInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsTeamkillNestedInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamkillsAsVictimNestedInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventTeamkillUpdateManyMutationInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventTeamkillUpdateManyWithWhereWithoutKillerInput = {
  data: EventTeamkillUpdateManyMutationInput;
  where: EventTeamkillScalarWhereInput;
};

export type EventTeamkillUpdateManyWithWhereWithoutServerInput = {
  data: EventTeamkillUpdateManyMutationInput;
  where: EventTeamkillScalarWhereInput;
};

export type EventTeamkillUpdateManyWithWhereWithoutVictimInput = {
  data: EventTeamkillUpdateManyMutationInput;
  where: EventTeamkillScalarWhereInput;
};

export type EventTeamkillUpdateManyWithoutKillerNestedInput = {
  connect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamkillCreateOrConnectWithoutKillerInput>>;
  create?: InputMaybe<Array<EventTeamkillCreateWithoutKillerInput>>;
  createMany?: InputMaybe<EventTeamkillCreateManyKillerInputEnvelope>;
  delete?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventTeamkillScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  set?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  update?: InputMaybe<Array<EventTeamkillUpdateWithWhereUniqueWithoutKillerInput>>;
  updateMany?: InputMaybe<Array<EventTeamkillUpdateManyWithWhereWithoutKillerInput>>;
  upsert?: InputMaybe<Array<EventTeamkillUpsertWithWhereUniqueWithoutKillerInput>>;
};

export type EventTeamkillUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamkillCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<EventTeamkillCreateWithoutServerInput>>;
  createMany?: InputMaybe<EventTeamkillCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventTeamkillScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  set?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  update?: InputMaybe<Array<EventTeamkillUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<EventTeamkillUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<EventTeamkillUpsertWithWhereUniqueWithoutServerInput>>;
};

export type EventTeamkillUpdateManyWithoutVictimNestedInput = {
  connect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventTeamkillCreateOrConnectWithoutVictimInput>>;
  create?: InputMaybe<Array<EventTeamkillCreateWithoutVictimInput>>;
  createMany?: InputMaybe<EventTeamkillCreateManyVictimInputEnvelope>;
  delete?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventTeamkillScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  set?: InputMaybe<Array<EventTeamkillWhereUniqueInput>>;
  update?: InputMaybe<Array<EventTeamkillUpdateWithWhereUniqueWithoutVictimInput>>;
  updateMany?: InputMaybe<Array<EventTeamkillUpdateManyWithWhereWithoutVictimInput>>;
  upsert?: InputMaybe<Array<EventTeamkillUpsertWithWhereUniqueWithoutVictimInput>>;
};

export type EventTeamkillUpdateWithWhereUniqueWithoutKillerInput = {
  data: EventTeamkillUpdateWithoutKillerInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillUpdateWithWhereUniqueWithoutServerInput = {
  data: EventTeamkillUpdateWithoutServerInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillUpdateWithWhereUniqueWithoutVictimInput = {
  data: EventTeamkillUpdateWithoutVictimInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillUpdateWithoutKillerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsTeamkillNestedInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamkillsAsVictimNestedInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventTeamkillUpdateWithoutServerInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  killer?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamkillsAsKillerNestedInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  victim?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamkillsAsVictimNestedInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventTeamkillUpdateWithoutVictimInput = {
  eventTime?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  killer?: InputMaybe<PlayerUpdateOneRequiredWithoutTeamkillsAsKillerNestedInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  posVictimX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posVictimZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posX?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posY?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  posZ?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutEventsTeamkillNestedInput>;
  weapon?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type EventTeamkillUpsertWithWhereUniqueWithoutKillerInput = {
  create: EventTeamkillCreateWithoutKillerInput;
  update: EventTeamkillUpdateWithoutKillerInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillUpsertWithWhereUniqueWithoutServerInput = {
  create: EventTeamkillCreateWithoutServerInput;
  update: EventTeamkillUpdateWithoutServerInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillUpsertWithWhereUniqueWithoutVictimInput = {
  create: EventTeamkillCreateWithoutVictimInput;
  update: EventTeamkillUpdateWithoutVictimInput;
  where: EventTeamkillWhereUniqueInput;
};

export type EventTeamkillWhereInput = {
  AND?: InputMaybe<Array<EventTeamkillWhereInput>>;
  NOT?: InputMaybe<Array<EventTeamkillWhereInput>>;
  OR?: InputMaybe<Array<EventTeamkillWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  killer?: InputMaybe<PlayerWhereInput>;
  killerId?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  victim?: InputMaybe<PlayerWhereInput>;
  victimId?: InputMaybe<IntFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventTeamkillWhereUniqueInput = {
  AND?: InputMaybe<Array<EventTeamkillWhereInput>>;
  NOT?: InputMaybe<Array<EventTeamkillWhereInput>>;
  OR?: InputMaybe<Array<EventTeamkillWhereInput>>;
  eventTime?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  killer?: InputMaybe<PlayerWhereInput>;
  killerId?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  posVictimX?: InputMaybe<IntNullableFilter>;
  posVictimY?: InputMaybe<IntNullableFilter>;
  posVictimZ?: InputMaybe<IntNullableFilter>;
  posX?: InputMaybe<IntNullableFilter>;
  posY?: InputMaybe<IntNullableFilter>;
  posZ?: InputMaybe<IntNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  victim?: InputMaybe<PlayerWhereInput>;
  victimId?: InputMaybe<IntFilter>;
  weapon?: InputMaybe<StringFilter>;
};

export type EventWorldAction = {
  __typename?: 'EventWorldAction';
  action: Action;
  actionId: Scalars['Int']['output'];
  bonus: Scalars['Int']['output'];
  eventTime: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  map: Scalars['String']['output'];
  serverId: Scalars['Int']['output'];
};

export type EventWorldActionAvgOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventWorldActionCountOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventWorldActionCreateInput = {
  action: ActionCreateNestedOneWithoutEventWorldActionsInput;
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  map?: InputMaybe<Scalars['String']['input']>;
  serverId: Scalars['Int']['input'];
};

export type EventWorldActionCreateManyActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  serverId: Scalars['Int']['input'];
};

export type EventWorldActionCreateManyActionInputEnvelope = {
  data: Array<EventWorldActionCreateManyActionInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EventWorldActionCreateManyInput = {
  actionId: Scalars['Int']['input'];
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  serverId: Scalars['Int']['input'];
};

export type EventWorldActionCreateNestedManyWithoutActionInput = {
  connect?: InputMaybe<Array<EventWorldActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventWorldActionCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventWorldActionCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventWorldActionCreateManyActionInputEnvelope>;
};

export type EventWorldActionCreateOrConnectWithoutActionInput = {
  create: EventWorldActionCreateWithoutActionInput;
  where: EventWorldActionWhereUniqueInput;
};

export type EventWorldActionCreateWithoutActionInput = {
  bonus?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  map?: InputMaybe<Scalars['String']['input']>;
  serverId: Scalars['Int']['input'];
};

export type EventWorldActionListRelationFilter = {
  every?: InputMaybe<EventWorldActionWhereInput>;
  none?: InputMaybe<EventWorldActionWhereInput>;
  some?: InputMaybe<EventWorldActionWhereInput>;
};

export type EventWorldActionMaxOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventWorldActionMinOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventWorldActionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum EventWorldActionOrderByRelevanceFieldEnum {
  Map = 'map'
}

export type EventWorldActionOrderByRelevanceInput = {
  fields: Array<EventWorldActionOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type EventWorldActionOrderByWithAggregationInput = {
  _avg?: InputMaybe<EventWorldActionAvgOrderByAggregateInput>;
  _count?: InputMaybe<EventWorldActionCountOrderByAggregateInput>;
  _max?: InputMaybe<EventWorldActionMaxOrderByAggregateInput>;
  _min?: InputMaybe<EventWorldActionMinOrderByAggregateInput>;
  _sum?: InputMaybe<EventWorldActionSumOrderByAggregateInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventWorldActionOrderByWithRelationInput = {
  _relevance?: InputMaybe<EventWorldActionOrderByRelevanceInput>;
  action?: InputMaybe<ActionOrderByWithRelationInput>;
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export enum EventWorldActionScalarFieldEnum {
  ActionId = 'actionId',
  Bonus = 'bonus',
  EventTime = 'eventTime',
  Id = 'id',
  Map = 'map',
  ServerId = 'serverId'
}

export type EventWorldActionScalarWhereInput = {
  AND?: InputMaybe<Array<EventWorldActionScalarWhereInput>>;
  NOT?: InputMaybe<Array<EventWorldActionScalarWhereInput>>;
  OR?: InputMaybe<Array<EventWorldActionScalarWhereInput>>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventWorldActionScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<EventWorldActionScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<EventWorldActionScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<EventWorldActionScalarWhereWithAggregatesInput>>;
  actionId?: InputMaybe<IntWithAggregatesFilter>;
  bonus?: InputMaybe<IntWithAggregatesFilter>;
  eventTime?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
};

export type EventWorldActionSumOrderByAggregateInput = {
  actionId?: InputMaybe<SortOrder>;
  bonus?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type EventWorldActionUpdateInput = {
  action?: InputMaybe<ActionUpdateOneRequiredWithoutEventWorldActionsNestedInput>;
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  serverId?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type EventWorldActionUpdateManyMutationInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  serverId?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type EventWorldActionUpdateManyWithWhereWithoutActionInput = {
  data: EventWorldActionUpdateManyMutationInput;
  where: EventWorldActionScalarWhereInput;
};

export type EventWorldActionUpdateManyWithoutActionNestedInput = {
  connect?: InputMaybe<Array<EventWorldActionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<EventWorldActionCreateOrConnectWithoutActionInput>>;
  create?: InputMaybe<Array<EventWorldActionCreateWithoutActionInput>>;
  createMany?: InputMaybe<EventWorldActionCreateManyActionInputEnvelope>;
  delete?: InputMaybe<Array<EventWorldActionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<EventWorldActionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<EventWorldActionWhereUniqueInput>>;
  set?: InputMaybe<Array<EventWorldActionWhereUniqueInput>>;
  update?: InputMaybe<Array<EventWorldActionUpdateWithWhereUniqueWithoutActionInput>>;
  updateMany?: InputMaybe<Array<EventWorldActionUpdateManyWithWhereWithoutActionInput>>;
  upsert?: InputMaybe<Array<EventWorldActionUpsertWithWhereUniqueWithoutActionInput>>;
};

export type EventWorldActionUpdateWithWhereUniqueWithoutActionInput = {
  data: EventWorldActionUpdateWithoutActionInput;
  where: EventWorldActionWhereUniqueInput;
};

export type EventWorldActionUpdateWithoutActionInput = {
  bonus?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
  serverId?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type EventWorldActionUpsertWithWhereUniqueWithoutActionInput = {
  create: EventWorldActionCreateWithoutActionInput;
  update: EventWorldActionUpdateWithoutActionInput;
  where: EventWorldActionWhereUniqueInput;
};

export type EventWorldActionWhereInput = {
  AND?: InputMaybe<Array<EventWorldActionWhereInput>>;
  NOT?: InputMaybe<Array<EventWorldActionWhereInput>>;
  OR?: InputMaybe<Array<EventWorldActionWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type EventWorldActionWhereUniqueInput = {
  AND?: InputMaybe<Array<EventWorldActionWhereInput>>;
  NOT?: InputMaybe<Array<EventWorldActionWhereInput>>;
  OR?: InputMaybe<Array<EventWorldActionWhereInput>>;
  action?: InputMaybe<ActionWhereInput>;
  actionId?: InputMaybe<IntFilter>;
  bonus?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['Int']['input']>;
  map?: InputMaybe<StringFilter>;
  serverId?: InputMaybe<IntFilter>;
};

export type FloatFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Float']['input']>;
  divide?: InputMaybe<Scalars['Float']['input']>;
  increment?: InputMaybe<Scalars['Float']['input']>;
  multiply?: InputMaybe<Scalars['Float']['input']>;
  set?: InputMaybe<Scalars['Float']['input']>;
};

export type FloatFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FloatNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedFloatNullableFilter>;
  _min?: InputMaybe<NestedFloatNullableFilter>;
  _sum?: InputMaybe<NestedFloatNullableFilter>;
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FloatWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedFloatFilter>;
  _min?: InputMaybe<NestedFloatFilter>;
  _sum?: InputMaybe<NestedFloatFilter>;
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type Game = {
  __typename?: 'Game';
  clans: Array<Clan>;
  code: Scalars['ID']['output'];
  hidden: Scalars['String']['output'];
  name: Scalars['String']['output'];
  players: Array<Player>;
  realgame: Scalars['String']['output'];
};


export type GameClansArgs = {
  cursor?: InputMaybe<ClanWhereUniqueInput>;
  distinct?: InputMaybe<Array<ClanScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ClanOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ClanWhereInput>;
};


export type GamePlayersArgs = {
  cursor?: InputMaybe<PlayerWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerWhereInput>;
};

export type GameCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  realgame?: InputMaybe<SortOrder>;
};

export type GameCreateInput = {
  clans?: InputMaybe<ClanCreateNestedManyWithoutGameDataInput>;
  code: Scalars['String']['input'];
  hidden?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  players?: InputMaybe<PlayerCreateNestedManyWithoutGameDataInput>;
  realgame?: InputMaybe<Scalars['String']['input']>;
};

export type GameCreateManyInput = {
  code: Scalars['String']['input'];
  hidden?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  realgame?: InputMaybe<Scalars['String']['input']>;
};

export type GameCreateNestedOneWithoutClansInput = {
  connect?: InputMaybe<GameWhereUniqueInput>;
  connectOrCreate?: InputMaybe<GameCreateOrConnectWithoutClansInput>;
  create?: InputMaybe<GameCreateWithoutClansInput>;
};

export type GameCreateNestedOneWithoutPlayersInput = {
  connect?: InputMaybe<GameWhereUniqueInput>;
  connectOrCreate?: InputMaybe<GameCreateOrConnectWithoutPlayersInput>;
  create?: InputMaybe<GameCreateWithoutPlayersInput>;
};

export type GameCreateOrConnectWithoutClansInput = {
  create: GameCreateWithoutClansInput;
  where: GameWhereUniqueInput;
};

export type GameCreateOrConnectWithoutPlayersInput = {
  create: GameCreateWithoutPlayersInput;
  where: GameWhereUniqueInput;
};

export type GameCreateWithoutClansInput = {
  code: Scalars['String']['input'];
  hidden?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  players?: InputMaybe<PlayerCreateNestedManyWithoutGameDataInput>;
  realgame?: InputMaybe<Scalars['String']['input']>;
};

export type GameCreateWithoutPlayersInput = {
  clans?: InputMaybe<ClanCreateNestedManyWithoutGameDataInput>;
  code: Scalars['String']['input'];
  hidden?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  realgame?: InputMaybe<Scalars['String']['input']>;
};

export type GameDefault = {
  __typename?: 'GameDefault';
  code: Scalars['String']['output'];
  parameter: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type GameDefaultCodeParameterCompoundUniqueInput = {
  code: Scalars['String']['input'];
  parameter: Scalars['String']['input'];
};

export type GameDefaultCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type GameDefaultCreateInput = {
  code: Scalars['String']['input'];
  parameter: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type GameDefaultCreateManyInput = {
  code: Scalars['String']['input'];
  parameter: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type GameDefaultMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type GameDefaultMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum GameDefaultOrderByRelevanceFieldEnum {
  Code = 'code',
  Parameter = 'parameter',
  Value = 'value'
}

export type GameDefaultOrderByRelevanceInput = {
  fields: Array<GameDefaultOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type GameDefaultOrderByWithAggregationInput = {
  _count?: InputMaybe<GameDefaultCountOrderByAggregateInput>;
  _max?: InputMaybe<GameDefaultMaxOrderByAggregateInput>;
  _min?: InputMaybe<GameDefaultMinOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type GameDefaultOrderByWithRelationInput = {
  _relevance?: InputMaybe<GameDefaultOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum GameDefaultScalarFieldEnum {
  Code = 'code',
  Parameter = 'parameter',
  Value = 'value'
}

export type GameDefaultScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<GameDefaultScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<GameDefaultScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<GameDefaultScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  parameter?: InputMaybe<StringWithAggregatesFilter>;
  value?: InputMaybe<StringWithAggregatesFilter>;
};

export type GameDefaultUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameDefaultUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameDefaultWhereInput = {
  AND?: InputMaybe<Array<GameDefaultWhereInput>>;
  NOT?: InputMaybe<Array<GameDefaultWhereInput>>;
  OR?: InputMaybe<Array<GameDefaultWhereInput>>;
  code?: InputMaybe<StringFilter>;
  parameter?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type GameDefaultWhereUniqueInput = {
  AND?: InputMaybe<Array<GameDefaultWhereInput>>;
  NOT?: InputMaybe<Array<GameDefaultWhereInput>>;
  OR?: InputMaybe<Array<GameDefaultWhereInput>>;
  code?: InputMaybe<StringFilter>;
  code_parameter?: InputMaybe<GameDefaultCodeParameterCompoundUniqueInput>;
  parameter?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type GameMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  realgame?: InputMaybe<SortOrder>;
};

export type GameMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  realgame?: InputMaybe<SortOrder>;
};

export enum GameOrderByRelevanceFieldEnum {
  Code = 'code',
  Hidden = 'hidden',
  Name = 'name',
  Realgame = 'realgame'
}

export type GameOrderByRelevanceInput = {
  fields: Array<GameOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type GameOrderByWithAggregationInput = {
  _count?: InputMaybe<GameCountOrderByAggregateInput>;
  _max?: InputMaybe<GameMaxOrderByAggregateInput>;
  _min?: InputMaybe<GameMinOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  realgame?: InputMaybe<SortOrder>;
};

export type GameOrderByWithRelationInput = {
  _relevance?: InputMaybe<GameOrderByRelevanceInput>;
  clans?: InputMaybe<ClanOrderByRelationAggregateInput>;
  code?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  players?: InputMaybe<PlayerOrderByRelationAggregateInput>;
  realgame?: InputMaybe<SortOrder>;
};

export enum GameScalarFieldEnum {
  Code = 'code',
  Hidden = 'hidden',
  Name = 'name',
  Realgame = 'realgame'
}

export type GameScalarRelationFilter = {
  is?: InputMaybe<GameWhereInput>;
  isNot?: InputMaybe<GameWhereInput>;
};

export type GameScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<GameScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<GameScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<GameScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  hidden?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  realgame?: InputMaybe<StringWithAggregatesFilter>;
};

export type GameSupported = {
  __typename?: 'GameSupported';
  code: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type GameSupportedCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type GameSupportedCreateInput = {
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type GameSupportedCreateManyInput = {
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type GameSupportedMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type GameSupportedMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export enum GameSupportedOrderByRelevanceFieldEnum {
  Code = 'code',
  Name = 'name'
}

export type GameSupportedOrderByRelevanceInput = {
  fields: Array<GameSupportedOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type GameSupportedOrderByWithAggregationInput = {
  _count?: InputMaybe<GameSupportedCountOrderByAggregateInput>;
  _max?: InputMaybe<GameSupportedMaxOrderByAggregateInput>;
  _min?: InputMaybe<GameSupportedMinOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type GameSupportedOrderByWithRelationInput = {
  _relevance?: InputMaybe<GameSupportedOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export enum GameSupportedScalarFieldEnum {
  Code = 'code',
  Name = 'name'
}

export type GameSupportedScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<GameSupportedScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<GameSupportedScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<GameSupportedScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
};

export type GameSupportedUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameSupportedUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameSupportedWhereInput = {
  AND?: InputMaybe<Array<GameSupportedWhereInput>>;
  NOT?: InputMaybe<Array<GameSupportedWhereInput>>;
  OR?: InputMaybe<Array<GameSupportedWhereInput>>;
  code?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
};

export type GameSupportedWhereUniqueInput = {
  AND?: InputMaybe<Array<GameSupportedWhereInput>>;
  NOT?: InputMaybe<Array<GameSupportedWhereInput>>;
  OR?: InputMaybe<Array<GameSupportedWhereInput>>;
  code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<StringFilter>;
};

export type GameUpdateInput = {
  clans?: InputMaybe<ClanUpdateManyWithoutGameDataNestedInput>;
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  players?: InputMaybe<PlayerUpdateManyWithoutGameDataNestedInput>;
  realgame?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  realgame?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameUpdateOneRequiredWithoutClansNestedInput = {
  connect?: InputMaybe<GameWhereUniqueInput>;
  connectOrCreate?: InputMaybe<GameCreateOrConnectWithoutClansInput>;
  create?: InputMaybe<GameCreateWithoutClansInput>;
  update?: InputMaybe<GameUpdateToOneWithWhereWithoutClansInput>;
  upsert?: InputMaybe<GameUpsertWithoutClansInput>;
};

export type GameUpdateOneRequiredWithoutPlayersNestedInput = {
  connect?: InputMaybe<GameWhereUniqueInput>;
  connectOrCreate?: InputMaybe<GameCreateOrConnectWithoutPlayersInput>;
  create?: InputMaybe<GameCreateWithoutPlayersInput>;
  update?: InputMaybe<GameUpdateToOneWithWhereWithoutPlayersInput>;
  upsert?: InputMaybe<GameUpsertWithoutPlayersInput>;
};

export type GameUpdateToOneWithWhereWithoutClansInput = {
  data: GameUpdateWithoutClansInput;
  where?: InputMaybe<GameWhereInput>;
};

export type GameUpdateToOneWithWhereWithoutPlayersInput = {
  data: GameUpdateWithoutPlayersInput;
  where?: InputMaybe<GameWhereInput>;
};

export type GameUpdateWithoutClansInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  players?: InputMaybe<PlayerUpdateManyWithoutGameDataNestedInput>;
  realgame?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameUpdateWithoutPlayersInput = {
  clans?: InputMaybe<ClanUpdateManyWithoutGameDataNestedInput>;
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  realgame?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type GameUpsertWithoutClansInput = {
  create: GameCreateWithoutClansInput;
  update: GameUpdateWithoutClansInput;
  where?: InputMaybe<GameWhereInput>;
};

export type GameUpsertWithoutPlayersInput = {
  create: GameCreateWithoutPlayersInput;
  update: GameUpdateWithoutPlayersInput;
  where?: InputMaybe<GameWhereInput>;
};

export type GameWhereInput = {
  AND?: InputMaybe<Array<GameWhereInput>>;
  NOT?: InputMaybe<Array<GameWhereInput>>;
  OR?: InputMaybe<Array<GameWhereInput>>;
  clans?: InputMaybe<ClanListRelationFilter>;
  code?: InputMaybe<StringFilter>;
  hidden?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  players?: InputMaybe<PlayerListRelationFilter>;
  realgame?: InputMaybe<StringFilter>;
};

export type GameWhereUniqueInput = {
  AND?: InputMaybe<Array<GameWhereInput>>;
  NOT?: InputMaybe<Array<GameWhereInput>>;
  OR?: InputMaybe<Array<GameWhereInput>>;
  clans?: InputMaybe<ClanListRelationFilter>;
  code?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  players?: InputMaybe<PlayerListRelationFilter>;
  realgame?: InputMaybe<StringFilter>;
};

export type GeoLiteCityBlock = {
  __typename?: 'GeoLiteCityBlock';
  endIpNum: Scalars['BigInt']['output'];
  locId: Scalars['BigInt']['output'];
  location: GeoLiteCityLocation;
  startIpNum: Scalars['BigInt']['output'];
};

export type GeoLiteCityBlockAvgOrderByAggregateInput = {
  endIpNum?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  startIpNum?: InputMaybe<SortOrder>;
};

export type GeoLiteCityBlockCountOrderByAggregateInput = {
  endIpNum?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  startIpNum?: InputMaybe<SortOrder>;
};

export type GeoLiteCityBlockCreateInput = {
  endIpNum: Scalars['BigInt']['input'];
  location: GeoLiteCityLocationCreateNestedOneWithoutBlocksInput;
  startIpNum: Scalars['BigInt']['input'];
};

export type GeoLiteCityBlockCreateManyInput = {
  endIpNum: Scalars['BigInt']['input'];
  locId: Scalars['BigInt']['input'];
  startIpNum: Scalars['BigInt']['input'];
};

export type GeoLiteCityBlockCreateManyLocationInput = {
  endIpNum: Scalars['BigInt']['input'];
  startIpNum: Scalars['BigInt']['input'];
};

export type GeoLiteCityBlockCreateManyLocationInputEnvelope = {
  data: Array<GeoLiteCityBlockCreateManyLocationInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GeoLiteCityBlockCreateNestedManyWithoutLocationInput = {
  connect?: InputMaybe<Array<GeoLiteCityBlockWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<GeoLiteCityBlockCreateOrConnectWithoutLocationInput>>;
  create?: InputMaybe<Array<GeoLiteCityBlockCreateWithoutLocationInput>>;
  createMany?: InputMaybe<GeoLiteCityBlockCreateManyLocationInputEnvelope>;
};

export type GeoLiteCityBlockCreateOrConnectWithoutLocationInput = {
  create: GeoLiteCityBlockCreateWithoutLocationInput;
  where: GeoLiteCityBlockWhereUniqueInput;
};

export type GeoLiteCityBlockCreateWithoutLocationInput = {
  endIpNum: Scalars['BigInt']['input'];
  startIpNum: Scalars['BigInt']['input'];
};

export type GeoLiteCityBlockListRelationFilter = {
  every?: InputMaybe<GeoLiteCityBlockWhereInput>;
  none?: InputMaybe<GeoLiteCityBlockWhereInput>;
  some?: InputMaybe<GeoLiteCityBlockWhereInput>;
};

export type GeoLiteCityBlockMaxOrderByAggregateInput = {
  endIpNum?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  startIpNum?: InputMaybe<SortOrder>;
};

export type GeoLiteCityBlockMinOrderByAggregateInput = {
  endIpNum?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  startIpNum?: InputMaybe<SortOrder>;
};

export type GeoLiteCityBlockOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type GeoLiteCityBlockOrderByWithAggregationInput = {
  _avg?: InputMaybe<GeoLiteCityBlockAvgOrderByAggregateInput>;
  _count?: InputMaybe<GeoLiteCityBlockCountOrderByAggregateInput>;
  _max?: InputMaybe<GeoLiteCityBlockMaxOrderByAggregateInput>;
  _min?: InputMaybe<GeoLiteCityBlockMinOrderByAggregateInput>;
  _sum?: InputMaybe<GeoLiteCityBlockSumOrderByAggregateInput>;
  endIpNum?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  startIpNum?: InputMaybe<SortOrder>;
};

export type GeoLiteCityBlockOrderByWithRelationInput = {
  endIpNum?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  location?: InputMaybe<GeoLiteCityLocationOrderByWithRelationInput>;
  startIpNum?: InputMaybe<SortOrder>;
};

export enum GeoLiteCityBlockScalarFieldEnum {
  EndIpNum = 'endIpNum',
  LocId = 'locId',
  StartIpNum = 'startIpNum'
}

export type GeoLiteCityBlockScalarWhereInput = {
  AND?: InputMaybe<Array<GeoLiteCityBlockScalarWhereInput>>;
  NOT?: InputMaybe<Array<GeoLiteCityBlockScalarWhereInput>>;
  OR?: InputMaybe<Array<GeoLiteCityBlockScalarWhereInput>>;
  endIpNum?: InputMaybe<BigIntFilter>;
  locId?: InputMaybe<BigIntFilter>;
  startIpNum?: InputMaybe<BigIntFilter>;
};

export type GeoLiteCityBlockScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<GeoLiteCityBlockScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<GeoLiteCityBlockScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<GeoLiteCityBlockScalarWhereWithAggregatesInput>>;
  endIpNum?: InputMaybe<BigIntWithAggregatesFilter>;
  locId?: InputMaybe<BigIntWithAggregatesFilter>;
  startIpNum?: InputMaybe<BigIntWithAggregatesFilter>;
};

export type GeoLiteCityBlockStartIpNumEndIpNumCompoundUniqueInput = {
  endIpNum: Scalars['BigInt']['input'];
  startIpNum: Scalars['BigInt']['input'];
};

export type GeoLiteCityBlockSumOrderByAggregateInput = {
  endIpNum?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  startIpNum?: InputMaybe<SortOrder>;
};

export type GeoLiteCityBlockUpdateInput = {
  endIpNum?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  location?: InputMaybe<GeoLiteCityLocationUpdateOneRequiredWithoutBlocksNestedInput>;
  startIpNum?: InputMaybe<BigIntFieldUpdateOperationsInput>;
};

export type GeoLiteCityBlockUpdateManyMutationInput = {
  endIpNum?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  startIpNum?: InputMaybe<BigIntFieldUpdateOperationsInput>;
};

export type GeoLiteCityBlockUpdateManyWithWhereWithoutLocationInput = {
  data: GeoLiteCityBlockUpdateManyMutationInput;
  where: GeoLiteCityBlockScalarWhereInput;
};

export type GeoLiteCityBlockUpdateManyWithoutLocationNestedInput = {
  connect?: InputMaybe<Array<GeoLiteCityBlockWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<GeoLiteCityBlockCreateOrConnectWithoutLocationInput>>;
  create?: InputMaybe<Array<GeoLiteCityBlockCreateWithoutLocationInput>>;
  createMany?: InputMaybe<GeoLiteCityBlockCreateManyLocationInputEnvelope>;
  delete?: InputMaybe<Array<GeoLiteCityBlockWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<GeoLiteCityBlockScalarWhereInput>>;
  disconnect?: InputMaybe<Array<GeoLiteCityBlockWhereUniqueInput>>;
  set?: InputMaybe<Array<GeoLiteCityBlockWhereUniqueInput>>;
  update?: InputMaybe<Array<GeoLiteCityBlockUpdateWithWhereUniqueWithoutLocationInput>>;
  updateMany?: InputMaybe<Array<GeoLiteCityBlockUpdateManyWithWhereWithoutLocationInput>>;
  upsert?: InputMaybe<Array<GeoLiteCityBlockUpsertWithWhereUniqueWithoutLocationInput>>;
};

export type GeoLiteCityBlockUpdateWithWhereUniqueWithoutLocationInput = {
  data: GeoLiteCityBlockUpdateWithoutLocationInput;
  where: GeoLiteCityBlockWhereUniqueInput;
};

export type GeoLiteCityBlockUpdateWithoutLocationInput = {
  endIpNum?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  startIpNum?: InputMaybe<BigIntFieldUpdateOperationsInput>;
};

export type GeoLiteCityBlockUpsertWithWhereUniqueWithoutLocationInput = {
  create: GeoLiteCityBlockCreateWithoutLocationInput;
  update: GeoLiteCityBlockUpdateWithoutLocationInput;
  where: GeoLiteCityBlockWhereUniqueInput;
};

export type GeoLiteCityBlockWhereInput = {
  AND?: InputMaybe<Array<GeoLiteCityBlockWhereInput>>;
  NOT?: InputMaybe<Array<GeoLiteCityBlockWhereInput>>;
  OR?: InputMaybe<Array<GeoLiteCityBlockWhereInput>>;
  endIpNum?: InputMaybe<BigIntFilter>;
  locId?: InputMaybe<BigIntFilter>;
  location?: InputMaybe<GeoLiteCityLocationWhereInput>;
  startIpNum?: InputMaybe<BigIntFilter>;
};

export type GeoLiteCityBlockWhereUniqueInput = {
  AND?: InputMaybe<Array<GeoLiteCityBlockWhereInput>>;
  NOT?: InputMaybe<Array<GeoLiteCityBlockWhereInput>>;
  OR?: InputMaybe<Array<GeoLiteCityBlockWhereInput>>;
  endIpNum?: InputMaybe<BigIntFilter>;
  locId?: InputMaybe<BigIntFilter>;
  location?: InputMaybe<GeoLiteCityLocationWhereInput>;
  startIpNum?: InputMaybe<BigIntFilter>;
  startIpNum_endIpNum?: InputMaybe<GeoLiteCityBlockStartIpNumEndIpNumCompoundUniqueInput>;
};

export type GeoLiteCityLocation = {
  __typename?: 'GeoLiteCityLocation';
  blocks: Array<GeoLiteCityBlock>;
  city?: Maybe<Scalars['String']['output']>;
  country: Scalars['String']['output'];
  latitude?: Maybe<Scalars['Decimal']['output']>;
  locId: Scalars['ID']['output'];
  longitude?: Maybe<Scalars['Decimal']['output']>;
  postalCode?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Scalars['String']['output']>;
};


export type GeoLiteCityLocationBlocksArgs = {
  cursor?: InputMaybe<GeoLiteCityBlockWhereUniqueInput>;
  distinct?: InputMaybe<Array<GeoLiteCityBlockScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GeoLiteCityBlockOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GeoLiteCityBlockWhereInput>;
};

export type GeoLiteCityLocationAvgOrderByAggregateInput = {
  latitude?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  longitude?: InputMaybe<SortOrder>;
};

export type GeoLiteCityLocationCountOrderByAggregateInput = {
  city?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  latitude?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  longitude?: InputMaybe<SortOrder>;
  postalCode?: InputMaybe<SortOrder>;
  region?: InputMaybe<SortOrder>;
};

export type GeoLiteCityLocationCreateInput = {
  blocks?: InputMaybe<GeoLiteCityBlockCreateNestedManyWithoutLocationInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  country: Scalars['String']['input'];
  latitude?: InputMaybe<Scalars['Decimal']['input']>;
  locId: Scalars['BigInt']['input'];
  longitude?: InputMaybe<Scalars['Decimal']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
};

export type GeoLiteCityLocationCreateManyInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country: Scalars['String']['input'];
  latitude?: InputMaybe<Scalars['Decimal']['input']>;
  locId: Scalars['BigInt']['input'];
  longitude?: InputMaybe<Scalars['Decimal']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
};

export type GeoLiteCityLocationCreateNestedOneWithoutBlocksInput = {
  connect?: InputMaybe<GeoLiteCityLocationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<GeoLiteCityLocationCreateOrConnectWithoutBlocksInput>;
  create?: InputMaybe<GeoLiteCityLocationCreateWithoutBlocksInput>;
};

export type GeoLiteCityLocationCreateOrConnectWithoutBlocksInput = {
  create: GeoLiteCityLocationCreateWithoutBlocksInput;
  where: GeoLiteCityLocationWhereUniqueInput;
};

export type GeoLiteCityLocationCreateWithoutBlocksInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country: Scalars['String']['input'];
  latitude?: InputMaybe<Scalars['Decimal']['input']>;
  locId: Scalars['BigInt']['input'];
  longitude?: InputMaybe<Scalars['Decimal']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
};

export type GeoLiteCityLocationMaxOrderByAggregateInput = {
  city?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  latitude?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  longitude?: InputMaybe<SortOrder>;
  postalCode?: InputMaybe<SortOrder>;
  region?: InputMaybe<SortOrder>;
};

export type GeoLiteCityLocationMinOrderByAggregateInput = {
  city?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  latitude?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  longitude?: InputMaybe<SortOrder>;
  postalCode?: InputMaybe<SortOrder>;
  region?: InputMaybe<SortOrder>;
};

export enum GeoLiteCityLocationOrderByRelevanceFieldEnum {
  City = 'city',
  Country = 'country',
  PostalCode = 'postalCode',
  Region = 'region'
}

export type GeoLiteCityLocationOrderByRelevanceInput = {
  fields: Array<GeoLiteCityLocationOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type GeoLiteCityLocationOrderByWithAggregationInput = {
  _avg?: InputMaybe<GeoLiteCityLocationAvgOrderByAggregateInput>;
  _count?: InputMaybe<GeoLiteCityLocationCountOrderByAggregateInput>;
  _max?: InputMaybe<GeoLiteCityLocationMaxOrderByAggregateInput>;
  _min?: InputMaybe<GeoLiteCityLocationMinOrderByAggregateInput>;
  _sum?: InputMaybe<GeoLiteCityLocationSumOrderByAggregateInput>;
  city?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  latitude?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  longitude?: InputMaybe<SortOrder>;
  postalCode?: InputMaybe<SortOrder>;
  region?: InputMaybe<SortOrder>;
};

export type GeoLiteCityLocationOrderByWithRelationInput = {
  _relevance?: InputMaybe<GeoLiteCityLocationOrderByRelevanceInput>;
  blocks?: InputMaybe<GeoLiteCityBlockOrderByRelationAggregateInput>;
  city?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  latitude?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  longitude?: InputMaybe<SortOrder>;
  postalCode?: InputMaybe<SortOrder>;
  region?: InputMaybe<SortOrder>;
};

export enum GeoLiteCityLocationScalarFieldEnum {
  City = 'city',
  Country = 'country',
  Latitude = 'latitude',
  LocId = 'locId',
  Longitude = 'longitude',
  PostalCode = 'postalCode',
  Region = 'region'
}

export type GeoLiteCityLocationScalarRelationFilter = {
  is?: InputMaybe<GeoLiteCityLocationWhereInput>;
  isNot?: InputMaybe<GeoLiteCityLocationWhereInput>;
};

export type GeoLiteCityLocationScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<GeoLiteCityLocationScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<GeoLiteCityLocationScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<GeoLiteCityLocationScalarWhereWithAggregatesInput>>;
  city?: InputMaybe<StringNullableWithAggregatesFilter>;
  country?: InputMaybe<StringWithAggregatesFilter>;
  latitude?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  locId?: InputMaybe<BigIntWithAggregatesFilter>;
  longitude?: InputMaybe<DecimalNullableWithAggregatesFilter>;
  postalCode?: InputMaybe<StringNullableWithAggregatesFilter>;
  region?: InputMaybe<StringNullableWithAggregatesFilter>;
};

export type GeoLiteCityLocationSumOrderByAggregateInput = {
  latitude?: InputMaybe<SortOrder>;
  locId?: InputMaybe<SortOrder>;
  longitude?: InputMaybe<SortOrder>;
};

export type GeoLiteCityLocationUpdateInput = {
  blocks?: InputMaybe<GeoLiteCityBlockUpdateManyWithoutLocationNestedInput>;
  city?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  latitude?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  locId?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  longitude?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  postalCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  region?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type GeoLiteCityLocationUpdateManyMutationInput = {
  city?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  latitude?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  locId?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  longitude?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  postalCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  region?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type GeoLiteCityLocationUpdateOneRequiredWithoutBlocksNestedInput = {
  connect?: InputMaybe<GeoLiteCityLocationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<GeoLiteCityLocationCreateOrConnectWithoutBlocksInput>;
  create?: InputMaybe<GeoLiteCityLocationCreateWithoutBlocksInput>;
  update?: InputMaybe<GeoLiteCityLocationUpdateToOneWithWhereWithoutBlocksInput>;
  upsert?: InputMaybe<GeoLiteCityLocationUpsertWithoutBlocksInput>;
};

export type GeoLiteCityLocationUpdateToOneWithWhereWithoutBlocksInput = {
  data: GeoLiteCityLocationUpdateWithoutBlocksInput;
  where?: InputMaybe<GeoLiteCityLocationWhereInput>;
};

export type GeoLiteCityLocationUpdateWithoutBlocksInput = {
  city?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  latitude?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  locId?: InputMaybe<BigIntFieldUpdateOperationsInput>;
  longitude?: InputMaybe<NullableDecimalFieldUpdateOperationsInput>;
  postalCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  region?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type GeoLiteCityLocationUpsertWithoutBlocksInput = {
  create: GeoLiteCityLocationCreateWithoutBlocksInput;
  update: GeoLiteCityLocationUpdateWithoutBlocksInput;
  where?: InputMaybe<GeoLiteCityLocationWhereInput>;
};

export type GeoLiteCityLocationWhereInput = {
  AND?: InputMaybe<Array<GeoLiteCityLocationWhereInput>>;
  NOT?: InputMaybe<Array<GeoLiteCityLocationWhereInput>>;
  OR?: InputMaybe<Array<GeoLiteCityLocationWhereInput>>;
  blocks?: InputMaybe<GeoLiteCityBlockListRelationFilter>;
  city?: InputMaybe<StringNullableFilter>;
  country?: InputMaybe<StringFilter>;
  latitude?: InputMaybe<DecimalNullableFilter>;
  locId?: InputMaybe<BigIntFilter>;
  longitude?: InputMaybe<DecimalNullableFilter>;
  postalCode?: InputMaybe<StringNullableFilter>;
  region?: InputMaybe<StringNullableFilter>;
};

export type GeoLiteCityLocationWhereUniqueInput = {
  AND?: InputMaybe<Array<GeoLiteCityLocationWhereInput>>;
  NOT?: InputMaybe<Array<GeoLiteCityLocationWhereInput>>;
  OR?: InputMaybe<Array<GeoLiteCityLocationWhereInput>>;
  blocks?: InputMaybe<GeoLiteCityBlockListRelationFilter>;
  city?: InputMaybe<StringNullableFilter>;
  country?: InputMaybe<StringFilter>;
  latitude?: InputMaybe<DecimalNullableFilter>;
  locId?: InputMaybe<Scalars['BigInt']['input']>;
  longitude?: InputMaybe<DecimalNullableFilter>;
  postalCode?: InputMaybe<StringNullableFilter>;
  region?: InputMaybe<StringNullableFilter>;
};

export type GetPlayersFiltersInput = {
  game?: InputMaybe<Scalars['String']['input']>;
  onlineOnly?: InputMaybe<Scalars['Boolean']['input']>;
  recentDays?: InputMaybe<Scalars['Int']['input']>;
  recentOnly?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
};

export type GetPlayersResult = {
  __typename?: 'GetPlayersResult';
  players?: Maybe<Array<PlayerServerStats>>;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type GetServerPlayersFiltersInput = {
  minKills?: InputMaybe<Scalars['Int']['input']>;
  minSkill?: InputMaybe<Scalars['Int']['input']>;
  onlineOnly?: InputMaybe<Scalars['Boolean']['input']>;
  recentDays?: InputMaybe<Scalars['Int']['input']>;
  recentOnly?: InputMaybe<Scalars['Boolean']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};

export type GetServerPlayersResult = {
  __typename?: 'GetServerPlayersResult';
  onlineCount?: Maybe<Scalars['Int']['output']>;
  players?: Maybe<Array<PlayerServerStats>>;
  recentCount?: Maybe<Scalars['Int']['output']>;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type HealthStatus = {
  __typename?: 'HealthStatus';
  status?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

export type IntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Int']['input']>;
  divide?: InputMaybe<Scalars['Int']['input']>;
  increment?: InputMaybe<Scalars['Int']['input']>;
  multiply?: InputMaybe<Scalars['Int']['input']>;
  set?: InputMaybe<Scalars['Int']['input']>;
};

export type IntFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type IntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type IntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type IntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedIntFilter>;
  _min?: InputMaybe<NestedIntFilter>;
  _sum?: InputMaybe<NestedIntFilter>;
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export enum JsonNullValueFilter {
  AnyNull = 'AnyNull',
  DbNull = 'DbNull',
  JsonNull = 'JsonNull'
}

export type JsonNullableFilter = {
  array_contains?: InputMaybe<Scalars['Json']['input']>;
  array_ends_with?: InputMaybe<Scalars['Json']['input']>;
  array_starts_with?: InputMaybe<Scalars['Json']['input']>;
  equals?: InputMaybe<Scalars['Json']['input']>;
  gt?: InputMaybe<Scalars['Json']['input']>;
  gte?: InputMaybe<Scalars['Json']['input']>;
  lt?: InputMaybe<Scalars['Json']['input']>;
  lte?: InputMaybe<Scalars['Json']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<Scalars['Json']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  string_contains?: InputMaybe<Scalars['String']['input']>;
  string_ends_with?: InputMaybe<Scalars['String']['input']>;
  string_starts_with?: InputMaybe<Scalars['String']['input']>;
};

export type JsonNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedJsonNullableFilter>;
  _min?: InputMaybe<NestedJsonNullableFilter>;
  array_contains?: InputMaybe<Scalars['Json']['input']>;
  array_ends_with?: InputMaybe<Scalars['Json']['input']>;
  array_starts_with?: InputMaybe<Scalars['Json']['input']>;
  equals?: InputMaybe<Scalars['Json']['input']>;
  gt?: InputMaybe<Scalars['Json']['input']>;
  gte?: InputMaybe<Scalars['Json']['input']>;
  lt?: InputMaybe<Scalars['Json']['input']>;
  lte?: InputMaybe<Scalars['Json']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<Scalars['Json']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  string_contains?: InputMaybe<Scalars['String']['input']>;
  string_ends_with?: InputMaybe<Scalars['String']['input']>;
  string_starts_with?: InputMaybe<Scalars['String']['input']>;
};

export type MapCount = {
  __typename?: 'MapCount';
  game: Scalars['String']['output'];
  headshots: Scalars['Int']['output'];
  kills: Scalars['Int']['output'];
  map: Scalars['String']['output'];
  rowId: Scalars['Int']['output'];
};

export type MapCountAvgOrderByAggregateInput = {
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  rowId?: InputMaybe<SortOrder>;
};

export type MapCountCountOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  rowId?: InputMaybe<SortOrder>;
};

export type MapCountCreateInput = {
  game: Scalars['String']['input'];
  headshots: Scalars['Int']['input'];
  kills: Scalars['Int']['input'];
  map: Scalars['String']['input'];
  rowId?: InputMaybe<Scalars['Int']['input']>;
};

export type MapCountCreateManyInput = {
  game: Scalars['String']['input'];
  headshots: Scalars['Int']['input'];
  kills: Scalars['Int']['input'];
  map: Scalars['String']['input'];
  rowId?: InputMaybe<Scalars['Int']['input']>;
};

export type MapCountGameMapCompoundUniqueInput = {
  game: Scalars['String']['input'];
  map: Scalars['String']['input'];
};

export type MapCountMaxOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  rowId?: InputMaybe<SortOrder>;
};

export type MapCountMinOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  rowId?: InputMaybe<SortOrder>;
};

export enum MapCountOrderByRelevanceFieldEnum {
  Game = 'game',
  Map = 'map'
}

export type MapCountOrderByRelevanceInput = {
  fields: Array<MapCountOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type MapCountOrderByWithAggregationInput = {
  _avg?: InputMaybe<MapCountAvgOrderByAggregateInput>;
  _count?: InputMaybe<MapCountCountOrderByAggregateInput>;
  _max?: InputMaybe<MapCountMaxOrderByAggregateInput>;
  _min?: InputMaybe<MapCountMinOrderByAggregateInput>;
  _sum?: InputMaybe<MapCountSumOrderByAggregateInput>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  rowId?: InputMaybe<SortOrder>;
};

export type MapCountOrderByWithRelationInput = {
  _relevance?: InputMaybe<MapCountOrderByRelevanceInput>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  rowId?: InputMaybe<SortOrder>;
};

export enum MapCountScalarFieldEnum {
  Game = 'game',
  Headshots = 'headshots',
  Kills = 'kills',
  Map = 'map',
  RowId = 'rowId'
}

export type MapCountScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<MapCountScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<MapCountScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<MapCountScalarWhereWithAggregatesInput>>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  headshots?: InputMaybe<IntWithAggregatesFilter>;
  kills?: InputMaybe<IntWithAggregatesFilter>;
  map?: InputMaybe<StringWithAggregatesFilter>;
  rowId?: InputMaybe<IntWithAggregatesFilter>;
};

export type MapCountSumOrderByAggregateInput = {
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  rowId?: InputMaybe<SortOrder>;
};

export type MapCountUpdateInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type MapCountUpdateManyMutationInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  map?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type MapCountWhereInput = {
  AND?: InputMaybe<Array<MapCountWhereInput>>;
  NOT?: InputMaybe<Array<MapCountWhereInput>>;
  OR?: InputMaybe<Array<MapCountWhereInput>>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  rowId?: InputMaybe<IntFilter>;
};

export type MapCountWhereUniqueInput = {
  AND?: InputMaybe<Array<MapCountWhereInput>>;
  NOT?: InputMaybe<Array<MapCountWhereInput>>;
  OR?: InputMaybe<Array<MapCountWhereInput>>;
  game?: InputMaybe<StringFilter>;
  game_map?: InputMaybe<MapCountGameMapCompoundUniqueInput>;
  headshots?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  map?: InputMaybe<StringFilter>;
  rowId?: InputMaybe<Scalars['Int']['input']>;
};

export type ModDefault = {
  __typename?: 'ModDefault';
  code: Scalars['String']['output'];
  parameter: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ModDefaultCodeParameterCompoundUniqueInput = {
  code: Scalars['String']['input'];
  parameter: Scalars['String']['input'];
};

export type ModDefaultCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ModDefaultCreateInput = {
  code: Scalars['String']['input'];
  parameter: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ModDefaultCreateManyInput = {
  code: Scalars['String']['input'];
  parameter: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ModDefaultMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ModDefaultMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum ModDefaultOrderByRelevanceFieldEnum {
  Code = 'code',
  Parameter = 'parameter',
  Value = 'value'
}

export type ModDefaultOrderByRelevanceInput = {
  fields: Array<ModDefaultOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ModDefaultOrderByWithAggregationInput = {
  _count?: InputMaybe<ModDefaultCountOrderByAggregateInput>;
  _max?: InputMaybe<ModDefaultMaxOrderByAggregateInput>;
  _min?: InputMaybe<ModDefaultMinOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ModDefaultOrderByWithRelationInput = {
  _relevance?: InputMaybe<ModDefaultOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum ModDefaultScalarFieldEnum {
  Code = 'code',
  Parameter = 'parameter',
  Value = 'value'
}

export type ModDefaultScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ModDefaultScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ModDefaultScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ModDefaultScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  parameter?: InputMaybe<StringWithAggregatesFilter>;
  value?: InputMaybe<StringWithAggregatesFilter>;
};

export type ModDefaultUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ModDefaultUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ModDefaultWhereInput = {
  AND?: InputMaybe<Array<ModDefaultWhereInput>>;
  NOT?: InputMaybe<Array<ModDefaultWhereInput>>;
  OR?: InputMaybe<Array<ModDefaultWhereInput>>;
  code?: InputMaybe<StringFilter>;
  parameter?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type ModDefaultWhereUniqueInput = {
  AND?: InputMaybe<Array<ModDefaultWhereInput>>;
  NOT?: InputMaybe<Array<ModDefaultWhereInput>>;
  OR?: InputMaybe<Array<ModDefaultWhereInput>>;
  code?: InputMaybe<StringFilter>;
  code_parameter?: InputMaybe<ModDefaultCodeParameterCompoundUniqueInput>;
  parameter?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type ModSupported = {
  __typename?: 'ModSupported';
  code: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type ModSupportedCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type ModSupportedCreateInput = {
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type ModSupportedCreateManyInput = {
  code: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type ModSupportedMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type ModSupportedMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export enum ModSupportedOrderByRelevanceFieldEnum {
  Code = 'code',
  Name = 'name'
}

export type ModSupportedOrderByRelevanceInput = {
  fields: Array<ModSupportedOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ModSupportedOrderByWithAggregationInput = {
  _count?: InputMaybe<ModSupportedCountOrderByAggregateInput>;
  _max?: InputMaybe<ModSupportedMaxOrderByAggregateInput>;
  _min?: InputMaybe<ModSupportedMinOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export type ModSupportedOrderByWithRelationInput = {
  _relevance?: InputMaybe<ModSupportedOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
};

export enum ModSupportedScalarFieldEnum {
  Code = 'code',
  Name = 'name'
}

export type ModSupportedScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ModSupportedScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ModSupportedScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ModSupportedScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
};

export type ModSupportedUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ModSupportedUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ModSupportedWhereInput = {
  AND?: InputMaybe<Array<ModSupportedWhereInput>>;
  NOT?: InputMaybe<Array<ModSupportedWhereInput>>;
  OR?: InputMaybe<Array<ModSupportedWhereInput>>;
  code?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
};

export type ModSupportedWhereUniqueInput = {
  AND?: InputMaybe<Array<ModSupportedWhereInput>>;
  NOT?: InputMaybe<Array<ModSupportedWhereInput>>;
  OR?: InputMaybe<Array<ModSupportedWhereInput>>;
  code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<StringFilter>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createManyAccount: Array<Account>;
  createManyAction: Array<Action>;
  createManyAward: Array<Award>;
  createManyClan: Array<Clan>;
  createManyClanTag: Array<ClanTag>;
  createManyCountry: Array<Country>;
  createManyEventAdmin: Array<EventAdmin>;
  createManyEventChangeName: Array<EventChangeName>;
  createManyEventChangeRole: Array<EventChangeRole>;
  createManyEventChangeTeam: Array<EventChangeTeam>;
  createManyEventChat: Array<EventChat>;
  createManyEventConnect: Array<EventConnect>;
  createManyEventDisconnect: Array<EventDisconnect>;
  createManyEventEntry: Array<EventEntry>;
  createManyEventFrag: Array<EventFrag>;
  createManyEventLatency: Array<EventLatency>;
  createManyEventPlayerAction: Array<EventPlayerAction>;
  createManyEventPlayerPlayerAction: Array<EventPlayerPlayerAction>;
  createManyEventRcon: Array<EventRcon>;
  createManyEventSuicide: Array<EventSuicide>;
  createManyEventTeamBonus: Array<EventTeamBonus>;
  createManyEventTeamkill: Array<EventTeamkill>;
  createManyEventWorldAction: Array<EventWorldAction>;
  createManyGame: Array<Game>;
  createManyGameDefault: Array<GameDefault>;
  createManyGameSupported: Array<GameSupported>;
  createManyGeoLiteCityBlock: Array<GeoLiteCityBlock>;
  createManyGeoLiteCityLocation: Array<GeoLiteCityLocation>;
  createManyMapCount: Array<MapCount>;
  createManyModDefault: Array<ModDefault>;
  createManyModSupported: Array<ModSupported>;
  createManyNotificationConfig: Array<NotificationConfig>;
  createManyOption: Array<Option>;
  createManyOptionChoice: Array<OptionChoice>;
  createManyPlayer: Array<Player>;
  createManyPlayerAward: Array<PlayerAward>;
  createManyPlayerHistory: Array<PlayerHistory>;
  createManyPlayerName: Array<PlayerName>;
  createManyPlayerRibbon: Array<PlayerRibbon>;
  createManyPlayerUniqueId: Array<PlayerUniqueId>;
  createManyRank: Array<Rank>;
  createManyRibbon: Array<Ribbon>;
  createManyRole: Array<Role>;
  createManyServer: Array<Server>;
  createManyServerConfig: Array<ServerConfig>;
  createManyServerConfigDefault: Array<ServerConfigDefault>;
  createManyServerLoad: Array<ServerLoad>;
  createManySession: Array<Session>;
  createManyTeam: Array<Team>;
  createManyUser: Array<User>;
  createManyVerification: Array<Verification>;
  createManyWeapon: Array<Weapon>;
  createOneAccount: Account;
  createOneAction: Action;
  createOneAward: Award;
  createOneClan: Clan;
  createOneClanTag: ClanTag;
  createOneCountry: Country;
  createOneEventAdmin: EventAdmin;
  createOneEventChangeName: EventChangeName;
  createOneEventChangeRole: EventChangeRole;
  createOneEventChangeTeam: EventChangeTeam;
  createOneEventChat: EventChat;
  createOneEventConnect: EventConnect;
  createOneEventDisconnect: EventDisconnect;
  createOneEventEntry: EventEntry;
  createOneEventFrag: EventFrag;
  createOneEventLatency: EventLatency;
  createOneEventPlayerAction: EventPlayerAction;
  createOneEventPlayerPlayerAction: EventPlayerPlayerAction;
  createOneEventRcon: EventRcon;
  createOneEventSuicide: EventSuicide;
  createOneEventTeamBonus: EventTeamBonus;
  createOneEventTeamkill: EventTeamkill;
  createOneEventWorldAction: EventWorldAction;
  createOneGame: Game;
  createOneGameDefault: GameDefault;
  createOneGameSupported: GameSupported;
  createOneGeoLiteCityBlock: GeoLiteCityBlock;
  createOneGeoLiteCityLocation: GeoLiteCityLocation;
  createOneMapCount: MapCount;
  createOneModDefault: ModDefault;
  createOneModSupported: ModSupported;
  createOneNotificationConfig: NotificationConfig;
  createOneOption: Option;
  createOneOptionChoice: OptionChoice;
  createOnePlayer: Player;
  createOnePlayerAward: PlayerAward;
  createOnePlayerHistory: PlayerHistory;
  createOnePlayerName: PlayerName;
  createOnePlayerRibbon: PlayerRibbon;
  createOnePlayerUniqueId: PlayerUniqueId;
  createOneRank: Rank;
  createOneRibbon: Ribbon;
  createOneRole: Role;
  createOneServer: Server;
  createOneServerConfig: ServerConfig;
  createOneServerConfigDefault: ServerConfigDefault;
  createOneServerLoad: ServerLoad;
  createOneSession: Session;
  createOneTeam: Team;
  createOneUser: User;
  createOneVerification: Verification;
  createOneWeapon: Weapon;
  createServerWithConfig?: Maybe<ServerOperationResult>;
  deleteManyAccount?: Maybe<BatchPayload>;
  deleteManyAction?: Maybe<BatchPayload>;
  deleteManyAward?: Maybe<BatchPayload>;
  deleteManyClan?: Maybe<BatchPayload>;
  deleteManyClanTag?: Maybe<BatchPayload>;
  deleteManyCountry?: Maybe<BatchPayload>;
  deleteManyEventAdmin?: Maybe<BatchPayload>;
  deleteManyEventChangeName?: Maybe<BatchPayload>;
  deleteManyEventChangeRole?: Maybe<BatchPayload>;
  deleteManyEventChangeTeam?: Maybe<BatchPayload>;
  deleteManyEventChat?: Maybe<BatchPayload>;
  deleteManyEventConnect?: Maybe<BatchPayload>;
  deleteManyEventDisconnect?: Maybe<BatchPayload>;
  deleteManyEventEntry?: Maybe<BatchPayload>;
  deleteManyEventFrag?: Maybe<BatchPayload>;
  deleteManyEventLatency?: Maybe<BatchPayload>;
  deleteManyEventPlayerAction?: Maybe<BatchPayload>;
  deleteManyEventPlayerPlayerAction?: Maybe<BatchPayload>;
  deleteManyEventRcon?: Maybe<BatchPayload>;
  deleteManyEventSuicide?: Maybe<BatchPayload>;
  deleteManyEventTeamBonus?: Maybe<BatchPayload>;
  deleteManyEventTeamkill?: Maybe<BatchPayload>;
  deleteManyEventWorldAction?: Maybe<BatchPayload>;
  deleteManyGame?: Maybe<BatchPayload>;
  deleteManyGameDefault?: Maybe<BatchPayload>;
  deleteManyGameSupported?: Maybe<BatchPayload>;
  deleteManyGeoLiteCityBlock?: Maybe<BatchPayload>;
  deleteManyGeoLiteCityLocation?: Maybe<BatchPayload>;
  deleteManyMapCount?: Maybe<BatchPayload>;
  deleteManyModDefault?: Maybe<BatchPayload>;
  deleteManyModSupported?: Maybe<BatchPayload>;
  deleteManyNotificationConfig?: Maybe<BatchPayload>;
  deleteManyOption?: Maybe<BatchPayload>;
  deleteManyOptionChoice?: Maybe<BatchPayload>;
  deleteManyPlayer?: Maybe<BatchPayload>;
  deleteManyPlayerAward?: Maybe<BatchPayload>;
  deleteManyPlayerHistory?: Maybe<BatchPayload>;
  deleteManyPlayerName?: Maybe<BatchPayload>;
  deleteManyPlayerRibbon?: Maybe<BatchPayload>;
  deleteManyPlayerUniqueId?: Maybe<BatchPayload>;
  deleteManyRank?: Maybe<BatchPayload>;
  deleteManyRibbon?: Maybe<BatchPayload>;
  deleteManyRole?: Maybe<BatchPayload>;
  deleteManyServer?: Maybe<BatchPayload>;
  deleteManyServerConfig?: Maybe<BatchPayload>;
  deleteManyServerConfigDefault?: Maybe<BatchPayload>;
  deleteManyServerLoad?: Maybe<BatchPayload>;
  deleteManySession?: Maybe<BatchPayload>;
  deleteManyTeam?: Maybe<BatchPayload>;
  deleteManyUser?: Maybe<BatchPayload>;
  deleteManyVerification?: Maybe<BatchPayload>;
  deleteManyWeapon?: Maybe<BatchPayload>;
  deleteOneAccount?: Maybe<Account>;
  deleteOneAction?: Maybe<Action>;
  deleteOneAward?: Maybe<Award>;
  deleteOneClan?: Maybe<Clan>;
  deleteOneClanTag?: Maybe<ClanTag>;
  deleteOneCountry?: Maybe<Country>;
  deleteOneEventAdmin?: Maybe<EventAdmin>;
  deleteOneEventChangeName?: Maybe<EventChangeName>;
  deleteOneEventChangeRole?: Maybe<EventChangeRole>;
  deleteOneEventChangeTeam?: Maybe<EventChangeTeam>;
  deleteOneEventChat?: Maybe<EventChat>;
  deleteOneEventConnect?: Maybe<EventConnect>;
  deleteOneEventDisconnect?: Maybe<EventDisconnect>;
  deleteOneEventEntry?: Maybe<EventEntry>;
  deleteOneEventFrag?: Maybe<EventFrag>;
  deleteOneEventLatency?: Maybe<EventLatency>;
  deleteOneEventPlayerAction?: Maybe<EventPlayerAction>;
  deleteOneEventPlayerPlayerAction?: Maybe<EventPlayerPlayerAction>;
  deleteOneEventRcon?: Maybe<EventRcon>;
  deleteOneEventSuicide?: Maybe<EventSuicide>;
  deleteOneEventTeamBonus?: Maybe<EventTeamBonus>;
  deleteOneEventTeamkill?: Maybe<EventTeamkill>;
  deleteOneEventWorldAction?: Maybe<EventWorldAction>;
  deleteOneGame?: Maybe<Game>;
  deleteOneGameDefault?: Maybe<GameDefault>;
  deleteOneGameSupported?: Maybe<GameSupported>;
  deleteOneGeoLiteCityBlock?: Maybe<GeoLiteCityBlock>;
  deleteOneGeoLiteCityLocation?: Maybe<GeoLiteCityLocation>;
  deleteOneMapCount?: Maybe<MapCount>;
  deleteOneModDefault?: Maybe<ModDefault>;
  deleteOneModSupported?: Maybe<ModSupported>;
  deleteOneNotificationConfig?: Maybe<NotificationConfig>;
  deleteOneOption?: Maybe<Option>;
  deleteOneOptionChoice?: Maybe<OptionChoice>;
  deleteOnePlayer?: Maybe<Player>;
  deleteOnePlayerAward?: Maybe<PlayerAward>;
  deleteOnePlayerHistory?: Maybe<PlayerHistory>;
  deleteOnePlayerName?: Maybe<PlayerName>;
  deleteOnePlayerRibbon?: Maybe<PlayerRibbon>;
  deleteOnePlayerUniqueId?: Maybe<PlayerUniqueId>;
  deleteOneRank?: Maybe<Rank>;
  deleteOneRibbon?: Maybe<Ribbon>;
  deleteOneRole?: Maybe<Role>;
  deleteOneServer?: Maybe<Server>;
  deleteOneServerConfig?: Maybe<ServerConfig>;
  deleteOneServerConfigDefault?: Maybe<ServerConfigDefault>;
  deleteOneServerLoad?: Maybe<ServerLoad>;
  deleteOneSession?: Maybe<Session>;
  deleteOneTeam?: Maybe<Team>;
  deleteOneUser?: Maybe<User>;
  deleteOneVerification?: Maybe<Verification>;
  deleteOneWeapon?: Maybe<Weapon>;
  updateManyAccount: BatchPayload;
  updateManyAction: BatchPayload;
  updateManyAward: BatchPayload;
  updateManyClan: BatchPayload;
  updateManyClanTag: BatchPayload;
  updateManyCountry: BatchPayload;
  updateManyEventAdmin: BatchPayload;
  updateManyEventChangeName: BatchPayload;
  updateManyEventChangeRole: BatchPayload;
  updateManyEventChangeTeam: BatchPayload;
  updateManyEventChat: BatchPayload;
  updateManyEventConnect: BatchPayload;
  updateManyEventDisconnect: BatchPayload;
  updateManyEventEntry: BatchPayload;
  updateManyEventFrag: BatchPayload;
  updateManyEventLatency: BatchPayload;
  updateManyEventPlayerAction: BatchPayload;
  updateManyEventPlayerPlayerAction: BatchPayload;
  updateManyEventRcon: BatchPayload;
  updateManyEventSuicide: BatchPayload;
  updateManyEventTeamBonus: BatchPayload;
  updateManyEventTeamkill: BatchPayload;
  updateManyEventWorldAction: BatchPayload;
  updateManyGame: BatchPayload;
  updateManyGameDefault: BatchPayload;
  updateManyGameSupported: BatchPayload;
  updateManyGeoLiteCityBlock: BatchPayload;
  updateManyGeoLiteCityLocation: BatchPayload;
  updateManyMapCount: BatchPayload;
  updateManyModDefault: BatchPayload;
  updateManyModSupported: BatchPayload;
  updateManyNotificationConfig: BatchPayload;
  updateManyOption: BatchPayload;
  updateManyOptionChoice: BatchPayload;
  updateManyPlayer: BatchPayload;
  updateManyPlayerAward: BatchPayload;
  updateManyPlayerHistory: BatchPayload;
  updateManyPlayerName: BatchPayload;
  updateManyPlayerRibbon: BatchPayload;
  updateManyPlayerUniqueId: BatchPayload;
  updateManyRank: BatchPayload;
  updateManyRibbon: BatchPayload;
  updateManyRole: BatchPayload;
  updateManyServer: BatchPayload;
  updateManyServerConfig: BatchPayload;
  updateManyServerConfigDefault: BatchPayload;
  updateManyServerLoad: BatchPayload;
  updateManySession: BatchPayload;
  updateManyTeam: BatchPayload;
  updateManyUser: BatchPayload;
  updateManyVerification: BatchPayload;
  updateManyWeapon: BatchPayload;
  updateOneAccount?: Maybe<Account>;
  updateOneAction?: Maybe<Action>;
  updateOneAward?: Maybe<Award>;
  updateOneClan?: Maybe<Clan>;
  updateOneClanTag?: Maybe<ClanTag>;
  updateOneCountry?: Maybe<Country>;
  updateOneEventAdmin?: Maybe<EventAdmin>;
  updateOneEventChangeName?: Maybe<EventChangeName>;
  updateOneEventChangeRole?: Maybe<EventChangeRole>;
  updateOneEventChangeTeam?: Maybe<EventChangeTeam>;
  updateOneEventChat?: Maybe<EventChat>;
  updateOneEventConnect?: Maybe<EventConnect>;
  updateOneEventDisconnect?: Maybe<EventDisconnect>;
  updateOneEventEntry?: Maybe<EventEntry>;
  updateOneEventFrag?: Maybe<EventFrag>;
  updateOneEventLatency?: Maybe<EventLatency>;
  updateOneEventPlayerAction?: Maybe<EventPlayerAction>;
  updateOneEventPlayerPlayerAction?: Maybe<EventPlayerPlayerAction>;
  updateOneEventRcon?: Maybe<EventRcon>;
  updateOneEventSuicide?: Maybe<EventSuicide>;
  updateOneEventTeamBonus?: Maybe<EventTeamBonus>;
  updateOneEventTeamkill?: Maybe<EventTeamkill>;
  updateOneEventWorldAction?: Maybe<EventWorldAction>;
  updateOneGame?: Maybe<Game>;
  updateOneGameDefault?: Maybe<GameDefault>;
  updateOneGameSupported?: Maybe<GameSupported>;
  updateOneGeoLiteCityBlock?: Maybe<GeoLiteCityBlock>;
  updateOneGeoLiteCityLocation?: Maybe<GeoLiteCityLocation>;
  updateOneMapCount?: Maybe<MapCount>;
  updateOneModDefault?: Maybe<ModDefault>;
  updateOneModSupported?: Maybe<ModSupported>;
  updateOneNotificationConfig?: Maybe<NotificationConfig>;
  updateOneOption?: Maybe<Option>;
  updateOneOptionChoice?: Maybe<OptionChoice>;
  updateOnePlayer?: Maybe<Player>;
  updateOnePlayerAward?: Maybe<PlayerAward>;
  updateOnePlayerHistory?: Maybe<PlayerHistory>;
  updateOnePlayerName?: Maybe<PlayerName>;
  updateOnePlayerRibbon?: Maybe<PlayerRibbon>;
  updateOnePlayerUniqueId?: Maybe<PlayerUniqueId>;
  updateOneRank?: Maybe<Rank>;
  updateOneRibbon?: Maybe<Ribbon>;
  updateOneRole?: Maybe<Role>;
  updateOneServer?: Maybe<Server>;
  updateOneServerConfig?: Maybe<ServerConfig>;
  updateOneServerConfigDefault?: Maybe<ServerConfigDefault>;
  updateOneServerLoad?: Maybe<ServerLoad>;
  updateOneSession?: Maybe<Session>;
  updateOneTeam?: Maybe<Team>;
  updateOneUser?: Maybe<User>;
  updateOneVerification?: Maybe<Verification>;
  updateOneWeapon?: Maybe<Weapon>;
  updateServerWithConfig?: Maybe<ServerOperationResult>;
  upsertOneAccount: Account;
  upsertOneAction: Action;
  upsertOneAward: Award;
  upsertOneClan: Clan;
  upsertOneClanTag: ClanTag;
  upsertOneCountry: Country;
  upsertOneEventAdmin: EventAdmin;
  upsertOneEventChangeName: EventChangeName;
  upsertOneEventChangeRole: EventChangeRole;
  upsertOneEventChangeTeam: EventChangeTeam;
  upsertOneEventChat: EventChat;
  upsertOneEventConnect: EventConnect;
  upsertOneEventDisconnect: EventDisconnect;
  upsertOneEventEntry: EventEntry;
  upsertOneEventFrag: EventFrag;
  upsertOneEventLatency: EventLatency;
  upsertOneEventPlayerAction: EventPlayerAction;
  upsertOneEventPlayerPlayerAction: EventPlayerPlayerAction;
  upsertOneEventRcon: EventRcon;
  upsertOneEventSuicide: EventSuicide;
  upsertOneEventTeamBonus: EventTeamBonus;
  upsertOneEventTeamkill: EventTeamkill;
  upsertOneEventWorldAction: EventWorldAction;
  upsertOneGame: Game;
  upsertOneGameDefault: GameDefault;
  upsertOneGameSupported: GameSupported;
  upsertOneGeoLiteCityBlock: GeoLiteCityBlock;
  upsertOneGeoLiteCityLocation: GeoLiteCityLocation;
  upsertOneMapCount: MapCount;
  upsertOneModDefault: ModDefault;
  upsertOneModSupported: ModSupported;
  upsertOneNotificationConfig: NotificationConfig;
  upsertOneOption: Option;
  upsertOneOptionChoice: OptionChoice;
  upsertOnePlayer: Player;
  upsertOnePlayerAward: PlayerAward;
  upsertOnePlayerHistory: PlayerHistory;
  upsertOnePlayerName: PlayerName;
  upsertOnePlayerRibbon: PlayerRibbon;
  upsertOnePlayerUniqueId: PlayerUniqueId;
  upsertOneRank: Rank;
  upsertOneRibbon: Ribbon;
  upsertOneRole: Role;
  upsertOneServer: Server;
  upsertOneServerConfig: ServerConfig;
  upsertOneServerConfigDefault: ServerConfigDefault;
  upsertOneServerLoad: ServerLoad;
  upsertOneSession: Session;
  upsertOneTeam: Team;
  upsertOneUser: User;
  upsertOneVerification: Verification;
  upsertOneWeapon: Weapon;
};


export type MutationCreateManyAccountArgs = {
  data: Array<AccountCreateInput>;
};


export type MutationCreateManyActionArgs = {
  data: Array<ActionCreateInput>;
};


export type MutationCreateManyAwardArgs = {
  data: Array<AwardCreateInput>;
};


export type MutationCreateManyClanArgs = {
  data: Array<ClanCreateInput>;
};


export type MutationCreateManyClanTagArgs = {
  data: Array<ClanTagCreateInput>;
};


export type MutationCreateManyCountryArgs = {
  data: Array<CountryCreateInput>;
};


export type MutationCreateManyEventAdminArgs = {
  data: Array<EventAdminCreateInput>;
};


export type MutationCreateManyEventChangeNameArgs = {
  data: Array<EventChangeNameCreateInput>;
};


export type MutationCreateManyEventChangeRoleArgs = {
  data: Array<EventChangeRoleCreateInput>;
};


export type MutationCreateManyEventChangeTeamArgs = {
  data: Array<EventChangeTeamCreateInput>;
};


export type MutationCreateManyEventChatArgs = {
  data: Array<EventChatCreateInput>;
};


export type MutationCreateManyEventConnectArgs = {
  data: Array<EventConnectCreateInput>;
};


export type MutationCreateManyEventDisconnectArgs = {
  data: Array<EventDisconnectCreateInput>;
};


export type MutationCreateManyEventEntryArgs = {
  data: Array<EventEntryCreateInput>;
};


export type MutationCreateManyEventFragArgs = {
  data: Array<EventFragCreateInput>;
};


export type MutationCreateManyEventLatencyArgs = {
  data: Array<EventLatencyCreateInput>;
};


export type MutationCreateManyEventPlayerActionArgs = {
  data: Array<EventPlayerActionCreateInput>;
};


export type MutationCreateManyEventPlayerPlayerActionArgs = {
  data: Array<EventPlayerPlayerActionCreateInput>;
};


export type MutationCreateManyEventRconArgs = {
  data: Array<EventRconCreateInput>;
};


export type MutationCreateManyEventSuicideArgs = {
  data: Array<EventSuicideCreateInput>;
};


export type MutationCreateManyEventTeamBonusArgs = {
  data: Array<EventTeamBonusCreateInput>;
};


export type MutationCreateManyEventTeamkillArgs = {
  data: Array<EventTeamkillCreateInput>;
};


export type MutationCreateManyEventWorldActionArgs = {
  data: Array<EventWorldActionCreateInput>;
};


export type MutationCreateManyGameArgs = {
  data: Array<GameCreateInput>;
};


export type MutationCreateManyGameDefaultArgs = {
  data: Array<GameDefaultCreateInput>;
};


export type MutationCreateManyGameSupportedArgs = {
  data: Array<GameSupportedCreateInput>;
};


export type MutationCreateManyGeoLiteCityBlockArgs = {
  data: Array<GeoLiteCityBlockCreateInput>;
};


export type MutationCreateManyGeoLiteCityLocationArgs = {
  data: Array<GeoLiteCityLocationCreateInput>;
};


export type MutationCreateManyMapCountArgs = {
  data: Array<MapCountCreateInput>;
};


export type MutationCreateManyModDefaultArgs = {
  data: Array<ModDefaultCreateInput>;
};


export type MutationCreateManyModSupportedArgs = {
  data: Array<ModSupportedCreateInput>;
};


export type MutationCreateManyNotificationConfigArgs = {
  data: Array<NotificationConfigCreateInput>;
};


export type MutationCreateManyOptionArgs = {
  data: Array<OptionCreateInput>;
};


export type MutationCreateManyOptionChoiceArgs = {
  data: Array<OptionChoiceCreateInput>;
};


export type MutationCreateManyPlayerArgs = {
  data: Array<PlayerCreateInput>;
};


export type MutationCreateManyPlayerAwardArgs = {
  data: Array<PlayerAwardCreateInput>;
};


export type MutationCreateManyPlayerHistoryArgs = {
  data: Array<PlayerHistoryCreateInput>;
};


export type MutationCreateManyPlayerNameArgs = {
  data: Array<PlayerNameCreateInput>;
};


export type MutationCreateManyPlayerRibbonArgs = {
  data: Array<PlayerRibbonCreateInput>;
};


export type MutationCreateManyPlayerUniqueIdArgs = {
  data: Array<PlayerUniqueIdCreateInput>;
};


export type MutationCreateManyRankArgs = {
  data: Array<RankCreateInput>;
};


export type MutationCreateManyRibbonArgs = {
  data: Array<RibbonCreateInput>;
};


export type MutationCreateManyRoleArgs = {
  data: Array<RoleCreateInput>;
};


export type MutationCreateManyServerArgs = {
  data: Array<ServerCreateInput>;
};


export type MutationCreateManyServerConfigArgs = {
  data: Array<ServerConfigCreateInput>;
};


export type MutationCreateManyServerConfigDefaultArgs = {
  data: Array<ServerConfigDefaultCreateInput>;
};


export type MutationCreateManyServerLoadArgs = {
  data: Array<ServerLoadCreateInput>;
};


export type MutationCreateManySessionArgs = {
  data: Array<SessionCreateInput>;
};


export type MutationCreateManyTeamArgs = {
  data: Array<TeamCreateInput>;
};


export type MutationCreateManyUserArgs = {
  data: Array<UserCreateInput>;
};


export type MutationCreateManyVerificationArgs = {
  data: Array<VerificationCreateInput>;
};


export type MutationCreateManyWeaponArgs = {
  data: Array<WeaponCreateInput>;
};


export type MutationCreateOneAccountArgs = {
  data: AccountCreateInput;
};


export type MutationCreateOneActionArgs = {
  data: ActionCreateInput;
};


export type MutationCreateOneAwardArgs = {
  data: AwardCreateInput;
};


export type MutationCreateOneClanArgs = {
  data: ClanCreateInput;
};


export type MutationCreateOneClanTagArgs = {
  data: ClanTagCreateInput;
};


export type MutationCreateOneCountryArgs = {
  data: CountryCreateInput;
};


export type MutationCreateOneEventAdminArgs = {
  data: EventAdminCreateInput;
};


export type MutationCreateOneEventChangeNameArgs = {
  data: EventChangeNameCreateInput;
};


export type MutationCreateOneEventChangeRoleArgs = {
  data: EventChangeRoleCreateInput;
};


export type MutationCreateOneEventChangeTeamArgs = {
  data: EventChangeTeamCreateInput;
};


export type MutationCreateOneEventChatArgs = {
  data: EventChatCreateInput;
};


export type MutationCreateOneEventConnectArgs = {
  data: EventConnectCreateInput;
};


export type MutationCreateOneEventDisconnectArgs = {
  data: EventDisconnectCreateInput;
};


export type MutationCreateOneEventEntryArgs = {
  data: EventEntryCreateInput;
};


export type MutationCreateOneEventFragArgs = {
  data: EventFragCreateInput;
};


export type MutationCreateOneEventLatencyArgs = {
  data: EventLatencyCreateInput;
};


export type MutationCreateOneEventPlayerActionArgs = {
  data: EventPlayerActionCreateInput;
};


export type MutationCreateOneEventPlayerPlayerActionArgs = {
  data: EventPlayerPlayerActionCreateInput;
};


export type MutationCreateOneEventRconArgs = {
  data: EventRconCreateInput;
};


export type MutationCreateOneEventSuicideArgs = {
  data: EventSuicideCreateInput;
};


export type MutationCreateOneEventTeamBonusArgs = {
  data: EventTeamBonusCreateInput;
};


export type MutationCreateOneEventTeamkillArgs = {
  data: EventTeamkillCreateInput;
};


export type MutationCreateOneEventWorldActionArgs = {
  data: EventWorldActionCreateInput;
};


export type MutationCreateOneGameArgs = {
  data: GameCreateInput;
};


export type MutationCreateOneGameDefaultArgs = {
  data: GameDefaultCreateInput;
};


export type MutationCreateOneGameSupportedArgs = {
  data: GameSupportedCreateInput;
};


export type MutationCreateOneGeoLiteCityBlockArgs = {
  data: GeoLiteCityBlockCreateInput;
};


export type MutationCreateOneGeoLiteCityLocationArgs = {
  data: GeoLiteCityLocationCreateInput;
};


export type MutationCreateOneMapCountArgs = {
  data: MapCountCreateInput;
};


export type MutationCreateOneModDefaultArgs = {
  data: ModDefaultCreateInput;
};


export type MutationCreateOneModSupportedArgs = {
  data: ModSupportedCreateInput;
};


export type MutationCreateOneNotificationConfigArgs = {
  data: NotificationConfigCreateInput;
};


export type MutationCreateOneOptionArgs = {
  data: OptionCreateInput;
};


export type MutationCreateOneOptionChoiceArgs = {
  data: OptionChoiceCreateInput;
};


export type MutationCreateOnePlayerArgs = {
  data: PlayerCreateInput;
};


export type MutationCreateOnePlayerAwardArgs = {
  data: PlayerAwardCreateInput;
};


export type MutationCreateOnePlayerHistoryArgs = {
  data: PlayerHistoryCreateInput;
};


export type MutationCreateOnePlayerNameArgs = {
  data: PlayerNameCreateInput;
};


export type MutationCreateOnePlayerRibbonArgs = {
  data: PlayerRibbonCreateInput;
};


export type MutationCreateOnePlayerUniqueIdArgs = {
  data: PlayerUniqueIdCreateInput;
};


export type MutationCreateOneRankArgs = {
  data: RankCreateInput;
};


export type MutationCreateOneRibbonArgs = {
  data: RibbonCreateInput;
};


export type MutationCreateOneRoleArgs = {
  data: RoleCreateInput;
};


export type MutationCreateOneServerArgs = {
  data: ServerCreateInput;
};


export type MutationCreateOneServerConfigArgs = {
  data: ServerConfigCreateInput;
};


export type MutationCreateOneServerConfigDefaultArgs = {
  data: ServerConfigDefaultCreateInput;
};


export type MutationCreateOneServerLoadArgs = {
  data: ServerLoadCreateInput;
};


export type MutationCreateOneSessionArgs = {
  data: SessionCreateInput;
};


export type MutationCreateOneTeamArgs = {
  data: TeamCreateInput;
};


export type MutationCreateOneUserArgs = {
  data: UserCreateInput;
};


export type MutationCreateOneVerificationArgs = {
  data: VerificationCreateInput;
};


export type MutationCreateOneWeaponArgs = {
  data: WeaponCreateInput;
};


export type MutationCreateServerWithConfigArgs = {
  data: CreateServerInput;
};


export type MutationDeleteManyAccountArgs = {
  where: AccountWhereInput;
};


export type MutationDeleteManyActionArgs = {
  where: ActionWhereInput;
};


export type MutationDeleteManyAwardArgs = {
  where: AwardWhereInput;
};


export type MutationDeleteManyClanArgs = {
  where: ClanWhereInput;
};


export type MutationDeleteManyClanTagArgs = {
  where: ClanTagWhereInput;
};


export type MutationDeleteManyCountryArgs = {
  where: CountryWhereInput;
};


export type MutationDeleteManyEventAdminArgs = {
  where: EventAdminWhereInput;
};


export type MutationDeleteManyEventChangeNameArgs = {
  where: EventChangeNameWhereInput;
};


export type MutationDeleteManyEventChangeRoleArgs = {
  where: EventChangeRoleWhereInput;
};


export type MutationDeleteManyEventChangeTeamArgs = {
  where: EventChangeTeamWhereInput;
};


export type MutationDeleteManyEventChatArgs = {
  where: EventChatWhereInput;
};


export type MutationDeleteManyEventConnectArgs = {
  where: EventConnectWhereInput;
};


export type MutationDeleteManyEventDisconnectArgs = {
  where: EventDisconnectWhereInput;
};


export type MutationDeleteManyEventEntryArgs = {
  where: EventEntryWhereInput;
};


export type MutationDeleteManyEventFragArgs = {
  where: EventFragWhereInput;
};


export type MutationDeleteManyEventLatencyArgs = {
  where: EventLatencyWhereInput;
};


export type MutationDeleteManyEventPlayerActionArgs = {
  where: EventPlayerActionWhereInput;
};


export type MutationDeleteManyEventPlayerPlayerActionArgs = {
  where: EventPlayerPlayerActionWhereInput;
};


export type MutationDeleteManyEventRconArgs = {
  where: EventRconWhereInput;
};


export type MutationDeleteManyEventSuicideArgs = {
  where: EventSuicideWhereInput;
};


export type MutationDeleteManyEventTeamBonusArgs = {
  where: EventTeamBonusWhereInput;
};


export type MutationDeleteManyEventTeamkillArgs = {
  where: EventTeamkillWhereInput;
};


export type MutationDeleteManyEventWorldActionArgs = {
  where: EventWorldActionWhereInput;
};


export type MutationDeleteManyGameArgs = {
  where: GameWhereInput;
};


export type MutationDeleteManyGameDefaultArgs = {
  where: GameDefaultWhereInput;
};


export type MutationDeleteManyGameSupportedArgs = {
  where: GameSupportedWhereInput;
};


export type MutationDeleteManyGeoLiteCityBlockArgs = {
  where: GeoLiteCityBlockWhereInput;
};


export type MutationDeleteManyGeoLiteCityLocationArgs = {
  where: GeoLiteCityLocationWhereInput;
};


export type MutationDeleteManyMapCountArgs = {
  where: MapCountWhereInput;
};


export type MutationDeleteManyModDefaultArgs = {
  where: ModDefaultWhereInput;
};


export type MutationDeleteManyModSupportedArgs = {
  where: ModSupportedWhereInput;
};


export type MutationDeleteManyNotificationConfigArgs = {
  where: NotificationConfigWhereInput;
};


export type MutationDeleteManyOptionArgs = {
  where: OptionWhereInput;
};


export type MutationDeleteManyOptionChoiceArgs = {
  where: OptionChoiceWhereInput;
};


export type MutationDeleteManyPlayerArgs = {
  where: PlayerWhereInput;
};


export type MutationDeleteManyPlayerAwardArgs = {
  where: PlayerAwardWhereInput;
};


export type MutationDeleteManyPlayerHistoryArgs = {
  where: PlayerHistoryWhereInput;
};


export type MutationDeleteManyPlayerNameArgs = {
  where: PlayerNameWhereInput;
};


export type MutationDeleteManyPlayerRibbonArgs = {
  where: PlayerRibbonWhereInput;
};


export type MutationDeleteManyPlayerUniqueIdArgs = {
  where: PlayerUniqueIdWhereInput;
};


export type MutationDeleteManyRankArgs = {
  where: RankWhereInput;
};


export type MutationDeleteManyRibbonArgs = {
  where: RibbonWhereInput;
};


export type MutationDeleteManyRoleArgs = {
  where: RoleWhereInput;
};


export type MutationDeleteManyServerArgs = {
  where: ServerWhereInput;
};


export type MutationDeleteManyServerConfigArgs = {
  where: ServerConfigWhereInput;
};


export type MutationDeleteManyServerConfigDefaultArgs = {
  where: ServerConfigDefaultWhereInput;
};


export type MutationDeleteManyServerLoadArgs = {
  where: ServerLoadWhereInput;
};


export type MutationDeleteManySessionArgs = {
  where: SessionWhereInput;
};


export type MutationDeleteManyTeamArgs = {
  where: TeamWhereInput;
};


export type MutationDeleteManyUserArgs = {
  where: UserWhereInput;
};


export type MutationDeleteManyVerificationArgs = {
  where: VerificationWhereInput;
};


export type MutationDeleteManyWeaponArgs = {
  where: WeaponWhereInput;
};


export type MutationDeleteOneAccountArgs = {
  where: AccountWhereUniqueInput;
};


export type MutationDeleteOneActionArgs = {
  where: ActionWhereUniqueInput;
};


export type MutationDeleteOneAwardArgs = {
  where: AwardWhereUniqueInput;
};


export type MutationDeleteOneClanArgs = {
  where: ClanWhereUniqueInput;
};


export type MutationDeleteOneClanTagArgs = {
  where: ClanTagWhereUniqueInput;
};


export type MutationDeleteOneCountryArgs = {
  where: CountryWhereUniqueInput;
};


export type MutationDeleteOneEventAdminArgs = {
  where: EventAdminWhereUniqueInput;
};


export type MutationDeleteOneEventChangeNameArgs = {
  where: EventChangeNameWhereUniqueInput;
};


export type MutationDeleteOneEventChangeRoleArgs = {
  where: EventChangeRoleWhereUniqueInput;
};


export type MutationDeleteOneEventChangeTeamArgs = {
  where: EventChangeTeamWhereUniqueInput;
};


export type MutationDeleteOneEventChatArgs = {
  where: EventChatWhereUniqueInput;
};


export type MutationDeleteOneEventConnectArgs = {
  where: EventConnectWhereUniqueInput;
};


export type MutationDeleteOneEventDisconnectArgs = {
  where: EventDisconnectWhereUniqueInput;
};


export type MutationDeleteOneEventEntryArgs = {
  where: EventEntryWhereUniqueInput;
};


export type MutationDeleteOneEventFragArgs = {
  where: EventFragWhereUniqueInput;
};


export type MutationDeleteOneEventLatencyArgs = {
  where: EventLatencyWhereUniqueInput;
};


export type MutationDeleteOneEventPlayerActionArgs = {
  where: EventPlayerActionWhereUniqueInput;
};


export type MutationDeleteOneEventPlayerPlayerActionArgs = {
  where: EventPlayerPlayerActionWhereUniqueInput;
};


export type MutationDeleteOneEventRconArgs = {
  where: EventRconWhereUniqueInput;
};


export type MutationDeleteOneEventSuicideArgs = {
  where: EventSuicideWhereUniqueInput;
};


export type MutationDeleteOneEventTeamBonusArgs = {
  where: EventTeamBonusWhereUniqueInput;
};


export type MutationDeleteOneEventTeamkillArgs = {
  where: EventTeamkillWhereUniqueInput;
};


export type MutationDeleteOneEventWorldActionArgs = {
  where: EventWorldActionWhereUniqueInput;
};


export type MutationDeleteOneGameArgs = {
  where: GameWhereUniqueInput;
};


export type MutationDeleteOneGameDefaultArgs = {
  where: GameDefaultWhereUniqueInput;
};


export type MutationDeleteOneGameSupportedArgs = {
  where: GameSupportedWhereUniqueInput;
};


export type MutationDeleteOneGeoLiteCityBlockArgs = {
  where: GeoLiteCityBlockWhereUniqueInput;
};


export type MutationDeleteOneGeoLiteCityLocationArgs = {
  where: GeoLiteCityLocationWhereUniqueInput;
};


export type MutationDeleteOneMapCountArgs = {
  where: MapCountWhereUniqueInput;
};


export type MutationDeleteOneModDefaultArgs = {
  where: ModDefaultWhereUniqueInput;
};


export type MutationDeleteOneModSupportedArgs = {
  where: ModSupportedWhereUniqueInput;
};


export type MutationDeleteOneNotificationConfigArgs = {
  where: NotificationConfigWhereUniqueInput;
};


export type MutationDeleteOneOptionArgs = {
  where: OptionWhereUniqueInput;
};


export type MutationDeleteOneOptionChoiceArgs = {
  where: OptionChoiceWhereUniqueInput;
};


export type MutationDeleteOnePlayerArgs = {
  where: PlayerWhereUniqueInput;
};


export type MutationDeleteOnePlayerAwardArgs = {
  where: PlayerAwardWhereUniqueInput;
};


export type MutationDeleteOnePlayerHistoryArgs = {
  where: PlayerHistoryWhereUniqueInput;
};


export type MutationDeleteOnePlayerNameArgs = {
  where: PlayerNameWhereUniqueInput;
};


export type MutationDeleteOnePlayerRibbonArgs = {
  where: PlayerRibbonWhereUniqueInput;
};


export type MutationDeleteOnePlayerUniqueIdArgs = {
  where: PlayerUniqueIdWhereUniqueInput;
};


export type MutationDeleteOneRankArgs = {
  where: RankWhereUniqueInput;
};


export type MutationDeleteOneRibbonArgs = {
  where: RibbonWhereUniqueInput;
};


export type MutationDeleteOneRoleArgs = {
  where: RoleWhereUniqueInput;
};


export type MutationDeleteOneServerArgs = {
  where: ServerWhereUniqueInput;
};


export type MutationDeleteOneServerConfigArgs = {
  where: ServerConfigWhereUniqueInput;
};


export type MutationDeleteOneServerConfigDefaultArgs = {
  where: ServerConfigDefaultWhereUniqueInput;
};


export type MutationDeleteOneServerLoadArgs = {
  where: ServerLoadWhereUniqueInput;
};


export type MutationDeleteOneSessionArgs = {
  where: SessionWhereUniqueInput;
};


export type MutationDeleteOneTeamArgs = {
  where: TeamWhereUniqueInput;
};


export type MutationDeleteOneUserArgs = {
  where: UserWhereUniqueInput;
};


export type MutationDeleteOneVerificationArgs = {
  where: VerificationWhereUniqueInput;
};


export type MutationDeleteOneWeaponArgs = {
  where: WeaponWhereUniqueInput;
};


export type MutationUpdateManyAccountArgs = {
  data: AccountUpdateManyMutationInput;
  where?: InputMaybe<AccountWhereInput>;
};


export type MutationUpdateManyActionArgs = {
  data: ActionUpdateManyMutationInput;
  where?: InputMaybe<ActionWhereInput>;
};


export type MutationUpdateManyAwardArgs = {
  data: AwardUpdateManyMutationInput;
  where?: InputMaybe<AwardWhereInput>;
};


export type MutationUpdateManyClanArgs = {
  data: ClanUpdateManyMutationInput;
  where?: InputMaybe<ClanWhereInput>;
};


export type MutationUpdateManyClanTagArgs = {
  data: ClanTagUpdateManyMutationInput;
  where?: InputMaybe<ClanTagWhereInput>;
};


export type MutationUpdateManyCountryArgs = {
  data: CountryUpdateManyMutationInput;
  where?: InputMaybe<CountryWhereInput>;
};


export type MutationUpdateManyEventAdminArgs = {
  data: EventAdminUpdateManyMutationInput;
  where?: InputMaybe<EventAdminWhereInput>;
};


export type MutationUpdateManyEventChangeNameArgs = {
  data: EventChangeNameUpdateManyMutationInput;
  where?: InputMaybe<EventChangeNameWhereInput>;
};


export type MutationUpdateManyEventChangeRoleArgs = {
  data: EventChangeRoleUpdateManyMutationInput;
  where?: InputMaybe<EventChangeRoleWhereInput>;
};


export type MutationUpdateManyEventChangeTeamArgs = {
  data: EventChangeTeamUpdateManyMutationInput;
  where?: InputMaybe<EventChangeTeamWhereInput>;
};


export type MutationUpdateManyEventChatArgs = {
  data: EventChatUpdateManyMutationInput;
  where?: InputMaybe<EventChatWhereInput>;
};


export type MutationUpdateManyEventConnectArgs = {
  data: EventConnectUpdateManyMutationInput;
  where?: InputMaybe<EventConnectWhereInput>;
};


export type MutationUpdateManyEventDisconnectArgs = {
  data: EventDisconnectUpdateManyMutationInput;
  where?: InputMaybe<EventDisconnectWhereInput>;
};


export type MutationUpdateManyEventEntryArgs = {
  data: EventEntryUpdateManyMutationInput;
  where?: InputMaybe<EventEntryWhereInput>;
};


export type MutationUpdateManyEventFragArgs = {
  data: EventFragUpdateManyMutationInput;
  where?: InputMaybe<EventFragWhereInput>;
};


export type MutationUpdateManyEventLatencyArgs = {
  data: EventLatencyUpdateManyMutationInput;
  where?: InputMaybe<EventLatencyWhereInput>;
};


export type MutationUpdateManyEventPlayerActionArgs = {
  data: EventPlayerActionUpdateManyMutationInput;
  where?: InputMaybe<EventPlayerActionWhereInput>;
};


export type MutationUpdateManyEventPlayerPlayerActionArgs = {
  data: EventPlayerPlayerActionUpdateManyMutationInput;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type MutationUpdateManyEventRconArgs = {
  data: EventRconUpdateManyMutationInput;
  where?: InputMaybe<EventRconWhereInput>;
};


export type MutationUpdateManyEventSuicideArgs = {
  data: EventSuicideUpdateManyMutationInput;
  where?: InputMaybe<EventSuicideWhereInput>;
};


export type MutationUpdateManyEventTeamBonusArgs = {
  data: EventTeamBonusUpdateManyMutationInput;
  where?: InputMaybe<EventTeamBonusWhereInput>;
};


export type MutationUpdateManyEventTeamkillArgs = {
  data: EventTeamkillUpdateManyMutationInput;
  where?: InputMaybe<EventTeamkillWhereInput>;
};


export type MutationUpdateManyEventWorldActionArgs = {
  data: EventWorldActionUpdateManyMutationInput;
  where?: InputMaybe<EventWorldActionWhereInput>;
};


export type MutationUpdateManyGameArgs = {
  data: GameUpdateManyMutationInput;
  where?: InputMaybe<GameWhereInput>;
};


export type MutationUpdateManyGameDefaultArgs = {
  data: GameDefaultUpdateManyMutationInput;
  where?: InputMaybe<GameDefaultWhereInput>;
};


export type MutationUpdateManyGameSupportedArgs = {
  data: GameSupportedUpdateManyMutationInput;
  where?: InputMaybe<GameSupportedWhereInput>;
};


export type MutationUpdateManyGeoLiteCityBlockArgs = {
  data: GeoLiteCityBlockUpdateManyMutationInput;
  where?: InputMaybe<GeoLiteCityBlockWhereInput>;
};


export type MutationUpdateManyGeoLiteCityLocationArgs = {
  data: GeoLiteCityLocationUpdateManyMutationInput;
  where?: InputMaybe<GeoLiteCityLocationWhereInput>;
};


export type MutationUpdateManyMapCountArgs = {
  data: MapCountUpdateManyMutationInput;
  where?: InputMaybe<MapCountWhereInput>;
};


export type MutationUpdateManyModDefaultArgs = {
  data: ModDefaultUpdateManyMutationInput;
  where?: InputMaybe<ModDefaultWhereInput>;
};


export type MutationUpdateManyModSupportedArgs = {
  data: ModSupportedUpdateManyMutationInput;
  where?: InputMaybe<ModSupportedWhereInput>;
};


export type MutationUpdateManyNotificationConfigArgs = {
  data: NotificationConfigUpdateManyMutationInput;
  where?: InputMaybe<NotificationConfigWhereInput>;
};


export type MutationUpdateManyOptionArgs = {
  data: OptionUpdateManyMutationInput;
  where?: InputMaybe<OptionWhereInput>;
};


export type MutationUpdateManyOptionChoiceArgs = {
  data: OptionChoiceUpdateManyMutationInput;
  where?: InputMaybe<OptionChoiceWhereInput>;
};


export type MutationUpdateManyPlayerArgs = {
  data: PlayerUpdateManyMutationInput;
  where?: InputMaybe<PlayerWhereInput>;
};


export type MutationUpdateManyPlayerAwardArgs = {
  data: PlayerAwardUpdateManyMutationInput;
  where?: InputMaybe<PlayerAwardWhereInput>;
};


export type MutationUpdateManyPlayerHistoryArgs = {
  data: PlayerHistoryUpdateManyMutationInput;
  where?: InputMaybe<PlayerHistoryWhereInput>;
};


export type MutationUpdateManyPlayerNameArgs = {
  data: PlayerNameUpdateManyMutationInput;
  where?: InputMaybe<PlayerNameWhereInput>;
};


export type MutationUpdateManyPlayerRibbonArgs = {
  data: PlayerRibbonUpdateManyMutationInput;
  where?: InputMaybe<PlayerRibbonWhereInput>;
};


export type MutationUpdateManyPlayerUniqueIdArgs = {
  data: PlayerUniqueIdUpdateManyMutationInput;
  where?: InputMaybe<PlayerUniqueIdWhereInput>;
};


export type MutationUpdateManyRankArgs = {
  data: RankUpdateManyMutationInput;
  where?: InputMaybe<RankWhereInput>;
};


export type MutationUpdateManyRibbonArgs = {
  data: RibbonUpdateManyMutationInput;
  where?: InputMaybe<RibbonWhereInput>;
};


export type MutationUpdateManyRoleArgs = {
  data: RoleUpdateManyMutationInput;
  where?: InputMaybe<RoleWhereInput>;
};


export type MutationUpdateManyServerArgs = {
  data: ServerUpdateManyMutationInput;
  where?: InputMaybe<ServerWhereInput>;
};


export type MutationUpdateManyServerConfigArgs = {
  data: ServerConfigUpdateManyMutationInput;
  where?: InputMaybe<ServerConfigWhereInput>;
};


export type MutationUpdateManyServerConfigDefaultArgs = {
  data: ServerConfigDefaultUpdateManyMutationInput;
  where?: InputMaybe<ServerConfigDefaultWhereInput>;
};


export type MutationUpdateManyServerLoadArgs = {
  data: ServerLoadUpdateManyMutationInput;
  where?: InputMaybe<ServerLoadWhereInput>;
};


export type MutationUpdateManySessionArgs = {
  data: SessionUpdateManyMutationInput;
  where?: InputMaybe<SessionWhereInput>;
};


export type MutationUpdateManyTeamArgs = {
  data: TeamUpdateManyMutationInput;
  where?: InputMaybe<TeamWhereInput>;
};


export type MutationUpdateManyUserArgs = {
  data: UserUpdateManyMutationInput;
  where?: InputMaybe<UserWhereInput>;
};


export type MutationUpdateManyVerificationArgs = {
  data: VerificationUpdateManyMutationInput;
  where?: InputMaybe<VerificationWhereInput>;
};


export type MutationUpdateManyWeaponArgs = {
  data: WeaponUpdateManyMutationInput;
  where?: InputMaybe<WeaponWhereInput>;
};


export type MutationUpdateOneAccountArgs = {
  data: AccountUpdateInput;
  where: AccountWhereUniqueInput;
};


export type MutationUpdateOneActionArgs = {
  data: ActionUpdateInput;
  where: ActionWhereUniqueInput;
};


export type MutationUpdateOneAwardArgs = {
  data: AwardUpdateInput;
  where: AwardWhereUniqueInput;
};


export type MutationUpdateOneClanArgs = {
  data: ClanUpdateInput;
  where: ClanWhereUniqueInput;
};


export type MutationUpdateOneClanTagArgs = {
  data: ClanTagUpdateInput;
  where: ClanTagWhereUniqueInput;
};


export type MutationUpdateOneCountryArgs = {
  data: CountryUpdateInput;
  where: CountryWhereUniqueInput;
};


export type MutationUpdateOneEventAdminArgs = {
  data: EventAdminUpdateInput;
  where: EventAdminWhereUniqueInput;
};


export type MutationUpdateOneEventChangeNameArgs = {
  data: EventChangeNameUpdateInput;
  where: EventChangeNameWhereUniqueInput;
};


export type MutationUpdateOneEventChangeRoleArgs = {
  data: EventChangeRoleUpdateInput;
  where: EventChangeRoleWhereUniqueInput;
};


export type MutationUpdateOneEventChangeTeamArgs = {
  data: EventChangeTeamUpdateInput;
  where: EventChangeTeamWhereUniqueInput;
};


export type MutationUpdateOneEventChatArgs = {
  data: EventChatUpdateInput;
  where: EventChatWhereUniqueInput;
};


export type MutationUpdateOneEventConnectArgs = {
  data: EventConnectUpdateInput;
  where: EventConnectWhereUniqueInput;
};


export type MutationUpdateOneEventDisconnectArgs = {
  data: EventDisconnectUpdateInput;
  where: EventDisconnectWhereUniqueInput;
};


export type MutationUpdateOneEventEntryArgs = {
  data: EventEntryUpdateInput;
  where: EventEntryWhereUniqueInput;
};


export type MutationUpdateOneEventFragArgs = {
  data: EventFragUpdateInput;
  where: EventFragWhereUniqueInput;
};


export type MutationUpdateOneEventLatencyArgs = {
  data: EventLatencyUpdateInput;
  where: EventLatencyWhereUniqueInput;
};


export type MutationUpdateOneEventPlayerActionArgs = {
  data: EventPlayerActionUpdateInput;
  where: EventPlayerActionWhereUniqueInput;
};


export type MutationUpdateOneEventPlayerPlayerActionArgs = {
  data: EventPlayerPlayerActionUpdateInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};


export type MutationUpdateOneEventRconArgs = {
  data: EventRconUpdateInput;
  where: EventRconWhereUniqueInput;
};


export type MutationUpdateOneEventSuicideArgs = {
  data: EventSuicideUpdateInput;
  where: EventSuicideWhereUniqueInput;
};


export type MutationUpdateOneEventTeamBonusArgs = {
  data: EventTeamBonusUpdateInput;
  where: EventTeamBonusWhereUniqueInput;
};


export type MutationUpdateOneEventTeamkillArgs = {
  data: EventTeamkillUpdateInput;
  where: EventTeamkillWhereUniqueInput;
};


export type MutationUpdateOneEventWorldActionArgs = {
  data: EventWorldActionUpdateInput;
  where: EventWorldActionWhereUniqueInput;
};


export type MutationUpdateOneGameArgs = {
  data: GameUpdateInput;
  where: GameWhereUniqueInput;
};


export type MutationUpdateOneGameDefaultArgs = {
  data: GameDefaultUpdateInput;
  where: GameDefaultWhereUniqueInput;
};


export type MutationUpdateOneGameSupportedArgs = {
  data: GameSupportedUpdateInput;
  where: GameSupportedWhereUniqueInput;
};


export type MutationUpdateOneGeoLiteCityBlockArgs = {
  data: GeoLiteCityBlockUpdateInput;
  where: GeoLiteCityBlockWhereUniqueInput;
};


export type MutationUpdateOneGeoLiteCityLocationArgs = {
  data: GeoLiteCityLocationUpdateInput;
  where: GeoLiteCityLocationWhereUniqueInput;
};


export type MutationUpdateOneMapCountArgs = {
  data: MapCountUpdateInput;
  where: MapCountWhereUniqueInput;
};


export type MutationUpdateOneModDefaultArgs = {
  data: ModDefaultUpdateInput;
  where: ModDefaultWhereUniqueInput;
};


export type MutationUpdateOneModSupportedArgs = {
  data: ModSupportedUpdateInput;
  where: ModSupportedWhereUniqueInput;
};


export type MutationUpdateOneNotificationConfigArgs = {
  data: NotificationConfigUpdateInput;
  where: NotificationConfigWhereUniqueInput;
};


export type MutationUpdateOneOptionArgs = {
  data: OptionUpdateInput;
  where: OptionWhereUniqueInput;
};


export type MutationUpdateOneOptionChoiceArgs = {
  data: OptionChoiceUpdateInput;
  where: OptionChoiceWhereUniqueInput;
};


export type MutationUpdateOnePlayerArgs = {
  data: PlayerUpdateInput;
  where: PlayerWhereUniqueInput;
};


export type MutationUpdateOnePlayerAwardArgs = {
  data: PlayerAwardUpdateInput;
  where: PlayerAwardWhereUniqueInput;
};


export type MutationUpdateOnePlayerHistoryArgs = {
  data: PlayerHistoryUpdateInput;
  where: PlayerHistoryWhereUniqueInput;
};


export type MutationUpdateOnePlayerNameArgs = {
  data: PlayerNameUpdateInput;
  where: PlayerNameWhereUniqueInput;
};


export type MutationUpdateOnePlayerRibbonArgs = {
  data: PlayerRibbonUpdateInput;
  where: PlayerRibbonWhereUniqueInput;
};


export type MutationUpdateOnePlayerUniqueIdArgs = {
  data: PlayerUniqueIdUpdateInput;
  where: PlayerUniqueIdWhereUniqueInput;
};


export type MutationUpdateOneRankArgs = {
  data: RankUpdateInput;
  where: RankWhereUniqueInput;
};


export type MutationUpdateOneRibbonArgs = {
  data: RibbonUpdateInput;
  where: RibbonWhereUniqueInput;
};


export type MutationUpdateOneRoleArgs = {
  data: RoleUpdateInput;
  where: RoleWhereUniqueInput;
};


export type MutationUpdateOneServerArgs = {
  data: ServerUpdateInput;
  where: ServerWhereUniqueInput;
};


export type MutationUpdateOneServerConfigArgs = {
  data: ServerConfigUpdateInput;
  where: ServerConfigWhereUniqueInput;
};


export type MutationUpdateOneServerConfigDefaultArgs = {
  data: ServerConfigDefaultUpdateInput;
  where: ServerConfigDefaultWhereUniqueInput;
};


export type MutationUpdateOneServerLoadArgs = {
  data: ServerLoadUpdateInput;
  where: ServerLoadWhereUniqueInput;
};


export type MutationUpdateOneSessionArgs = {
  data: SessionUpdateInput;
  where: SessionWhereUniqueInput;
};


export type MutationUpdateOneTeamArgs = {
  data: TeamUpdateInput;
  where: TeamWhereUniqueInput;
};


export type MutationUpdateOneUserArgs = {
  data: UserUpdateInput;
  where: UserWhereUniqueInput;
};


export type MutationUpdateOneVerificationArgs = {
  data: VerificationUpdateInput;
  where: VerificationWhereUniqueInput;
};


export type MutationUpdateOneWeaponArgs = {
  data: WeaponUpdateInput;
  where: WeaponWhereUniqueInput;
};


export type MutationUpdateServerWithConfigArgs = {
  data: UpdateServerInput;
  serverId: Scalars['Int']['input'];
};


export type MutationUpsertOneAccountArgs = {
  create: AccountCreateInput;
  update: AccountUpdateInput;
  where: AccountWhereUniqueInput;
};


export type MutationUpsertOneActionArgs = {
  create: ActionCreateInput;
  update: ActionUpdateInput;
  where: ActionWhereUniqueInput;
};


export type MutationUpsertOneAwardArgs = {
  create: AwardCreateInput;
  update: AwardUpdateInput;
  where: AwardWhereUniqueInput;
};


export type MutationUpsertOneClanArgs = {
  create: ClanCreateInput;
  update: ClanUpdateInput;
  where: ClanWhereUniqueInput;
};


export type MutationUpsertOneClanTagArgs = {
  create: ClanTagCreateInput;
  update: ClanTagUpdateInput;
  where: ClanTagWhereUniqueInput;
};


export type MutationUpsertOneCountryArgs = {
  create: CountryCreateInput;
  update: CountryUpdateInput;
  where: CountryWhereUniqueInput;
};


export type MutationUpsertOneEventAdminArgs = {
  create: EventAdminCreateInput;
  update: EventAdminUpdateInput;
  where: EventAdminWhereUniqueInput;
};


export type MutationUpsertOneEventChangeNameArgs = {
  create: EventChangeNameCreateInput;
  update: EventChangeNameUpdateInput;
  where: EventChangeNameWhereUniqueInput;
};


export type MutationUpsertOneEventChangeRoleArgs = {
  create: EventChangeRoleCreateInput;
  update: EventChangeRoleUpdateInput;
  where: EventChangeRoleWhereUniqueInput;
};


export type MutationUpsertOneEventChangeTeamArgs = {
  create: EventChangeTeamCreateInput;
  update: EventChangeTeamUpdateInput;
  where: EventChangeTeamWhereUniqueInput;
};


export type MutationUpsertOneEventChatArgs = {
  create: EventChatCreateInput;
  update: EventChatUpdateInput;
  where: EventChatWhereUniqueInput;
};


export type MutationUpsertOneEventConnectArgs = {
  create: EventConnectCreateInput;
  update: EventConnectUpdateInput;
  where: EventConnectWhereUniqueInput;
};


export type MutationUpsertOneEventDisconnectArgs = {
  create: EventDisconnectCreateInput;
  update: EventDisconnectUpdateInput;
  where: EventDisconnectWhereUniqueInput;
};


export type MutationUpsertOneEventEntryArgs = {
  create: EventEntryCreateInput;
  update: EventEntryUpdateInput;
  where: EventEntryWhereUniqueInput;
};


export type MutationUpsertOneEventFragArgs = {
  create: EventFragCreateInput;
  update: EventFragUpdateInput;
  where: EventFragWhereUniqueInput;
};


export type MutationUpsertOneEventLatencyArgs = {
  create: EventLatencyCreateInput;
  update: EventLatencyUpdateInput;
  where: EventLatencyWhereUniqueInput;
};


export type MutationUpsertOneEventPlayerActionArgs = {
  create: EventPlayerActionCreateInput;
  update: EventPlayerActionUpdateInput;
  where: EventPlayerActionWhereUniqueInput;
};


export type MutationUpsertOneEventPlayerPlayerActionArgs = {
  create: EventPlayerPlayerActionCreateInput;
  update: EventPlayerPlayerActionUpdateInput;
  where: EventPlayerPlayerActionWhereUniqueInput;
};


export type MutationUpsertOneEventRconArgs = {
  create: EventRconCreateInput;
  update: EventRconUpdateInput;
  where: EventRconWhereUniqueInput;
};


export type MutationUpsertOneEventSuicideArgs = {
  create: EventSuicideCreateInput;
  update: EventSuicideUpdateInput;
  where: EventSuicideWhereUniqueInput;
};


export type MutationUpsertOneEventTeamBonusArgs = {
  create: EventTeamBonusCreateInput;
  update: EventTeamBonusUpdateInput;
  where: EventTeamBonusWhereUniqueInput;
};


export type MutationUpsertOneEventTeamkillArgs = {
  create: EventTeamkillCreateInput;
  update: EventTeamkillUpdateInput;
  where: EventTeamkillWhereUniqueInput;
};


export type MutationUpsertOneEventWorldActionArgs = {
  create: EventWorldActionCreateInput;
  update: EventWorldActionUpdateInput;
  where: EventWorldActionWhereUniqueInput;
};


export type MutationUpsertOneGameArgs = {
  create: GameCreateInput;
  update: GameUpdateInput;
  where: GameWhereUniqueInput;
};


export type MutationUpsertOneGameDefaultArgs = {
  create: GameDefaultCreateInput;
  update: GameDefaultUpdateInput;
  where: GameDefaultWhereUniqueInput;
};


export type MutationUpsertOneGameSupportedArgs = {
  create: GameSupportedCreateInput;
  update: GameSupportedUpdateInput;
  where: GameSupportedWhereUniqueInput;
};


export type MutationUpsertOneGeoLiteCityBlockArgs = {
  create: GeoLiteCityBlockCreateInput;
  update: GeoLiteCityBlockUpdateInput;
  where: GeoLiteCityBlockWhereUniqueInput;
};


export type MutationUpsertOneGeoLiteCityLocationArgs = {
  create: GeoLiteCityLocationCreateInput;
  update: GeoLiteCityLocationUpdateInput;
  where: GeoLiteCityLocationWhereUniqueInput;
};


export type MutationUpsertOneMapCountArgs = {
  create: MapCountCreateInput;
  update: MapCountUpdateInput;
  where: MapCountWhereUniqueInput;
};


export type MutationUpsertOneModDefaultArgs = {
  create: ModDefaultCreateInput;
  update: ModDefaultUpdateInput;
  where: ModDefaultWhereUniqueInput;
};


export type MutationUpsertOneModSupportedArgs = {
  create: ModSupportedCreateInput;
  update: ModSupportedUpdateInput;
  where: ModSupportedWhereUniqueInput;
};


export type MutationUpsertOneNotificationConfigArgs = {
  create: NotificationConfigCreateInput;
  update: NotificationConfigUpdateInput;
  where: NotificationConfigWhereUniqueInput;
};


export type MutationUpsertOneOptionArgs = {
  create: OptionCreateInput;
  update: OptionUpdateInput;
  where: OptionWhereUniqueInput;
};


export type MutationUpsertOneOptionChoiceArgs = {
  create: OptionChoiceCreateInput;
  update: OptionChoiceUpdateInput;
  where: OptionChoiceWhereUniqueInput;
};


export type MutationUpsertOnePlayerArgs = {
  create: PlayerCreateInput;
  update: PlayerUpdateInput;
  where: PlayerWhereUniqueInput;
};


export type MutationUpsertOnePlayerAwardArgs = {
  create: PlayerAwardCreateInput;
  update: PlayerAwardUpdateInput;
  where: PlayerAwardWhereUniqueInput;
};


export type MutationUpsertOnePlayerHistoryArgs = {
  create: PlayerHistoryCreateInput;
  update: PlayerHistoryUpdateInput;
  where: PlayerHistoryWhereUniqueInput;
};


export type MutationUpsertOnePlayerNameArgs = {
  create: PlayerNameCreateInput;
  update: PlayerNameUpdateInput;
  where: PlayerNameWhereUniqueInput;
};


export type MutationUpsertOnePlayerRibbonArgs = {
  create: PlayerRibbonCreateInput;
  update: PlayerRibbonUpdateInput;
  where: PlayerRibbonWhereUniqueInput;
};


export type MutationUpsertOnePlayerUniqueIdArgs = {
  create: PlayerUniqueIdCreateInput;
  update: PlayerUniqueIdUpdateInput;
  where: PlayerUniqueIdWhereUniqueInput;
};


export type MutationUpsertOneRankArgs = {
  create: RankCreateInput;
  update: RankUpdateInput;
  where: RankWhereUniqueInput;
};


export type MutationUpsertOneRibbonArgs = {
  create: RibbonCreateInput;
  update: RibbonUpdateInput;
  where: RibbonWhereUniqueInput;
};


export type MutationUpsertOneRoleArgs = {
  create: RoleCreateInput;
  update: RoleUpdateInput;
  where: RoleWhereUniqueInput;
};


export type MutationUpsertOneServerArgs = {
  create: ServerCreateInput;
  update: ServerUpdateInput;
  where: ServerWhereUniqueInput;
};


export type MutationUpsertOneServerConfigArgs = {
  create: ServerConfigCreateInput;
  update: ServerConfigUpdateInput;
  where: ServerConfigWhereUniqueInput;
};


export type MutationUpsertOneServerConfigDefaultArgs = {
  create: ServerConfigDefaultCreateInput;
  update: ServerConfigDefaultUpdateInput;
  where: ServerConfigDefaultWhereUniqueInput;
};


export type MutationUpsertOneServerLoadArgs = {
  create: ServerLoadCreateInput;
  update: ServerLoadUpdateInput;
  where: ServerLoadWhereUniqueInput;
};


export type MutationUpsertOneSessionArgs = {
  create: SessionCreateInput;
  update: SessionUpdateInput;
  where: SessionWhereUniqueInput;
};


export type MutationUpsertOneTeamArgs = {
  create: TeamCreateInput;
  update: TeamUpdateInput;
  where: TeamWhereUniqueInput;
};


export type MutationUpsertOneUserArgs = {
  create: UserCreateInput;
  update: UserUpdateInput;
  where: UserWhereUniqueInput;
};


export type MutationUpsertOneVerificationArgs = {
  create: VerificationCreateInput;
  update: VerificationUpdateInput;
  where: VerificationWhereUniqueInput;
};


export type MutationUpsertOneWeaponArgs = {
  create: WeaponCreateInput;
  update: WeaponUpdateInput;
  where: WeaponWhereUniqueInput;
};

export type NestedBigIntFilter = {
  equals?: InputMaybe<Scalars['BigInt']['input']>;
  gt?: InputMaybe<Scalars['BigInt']['input']>;
  gte?: InputMaybe<Scalars['BigInt']['input']>;
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  lt?: InputMaybe<Scalars['BigInt']['input']>;
  lte?: InputMaybe<Scalars['BigInt']['input']>;
  not?: InputMaybe<NestedBigIntFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export type NestedBigIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBigIntFilter>;
  _min?: InputMaybe<NestedBigIntFilter>;
  _sum?: InputMaybe<NestedBigIntFilter>;
  equals?: InputMaybe<Scalars['BigInt']['input']>;
  gt?: InputMaybe<Scalars['BigInt']['input']>;
  gte?: InputMaybe<Scalars['BigInt']['input']>;
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  lt?: InputMaybe<Scalars['BigInt']['input']>;
  lte?: InputMaybe<Scalars['BigInt']['input']>;
  not?: InputMaybe<NestedBigIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export type NestedBoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type NestedBoolNullableFilter = {
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolNullableFilter>;
};

export type NestedBoolNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedBoolNullableFilter>;
  _min?: InputMaybe<NestedBoolNullableFilter>;
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolNullableWithAggregatesFilter>;
};

export type NestedBoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type NestedDateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedDateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedDateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedDecimalNullableFilter = {
  equals?: InputMaybe<Scalars['Decimal']['input']>;
  gt?: InputMaybe<Scalars['Decimal']['input']>;
  gte?: InputMaybe<Scalars['Decimal']['input']>;
  in?: InputMaybe<Array<Scalars['Decimal']['input']>>;
  lt?: InputMaybe<Scalars['Decimal']['input']>;
  lte?: InputMaybe<Scalars['Decimal']['input']>;
  not?: InputMaybe<NestedDecimalNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']['input']>>;
};

export type NestedDecimalNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedDecimalNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDecimalNullableFilter>;
  _min?: InputMaybe<NestedDecimalNullableFilter>;
  _sum?: InputMaybe<NestedDecimalNullableFilter>;
  equals?: InputMaybe<Scalars['Decimal']['input']>;
  gt?: InputMaybe<Scalars['Decimal']['input']>;
  gte?: InputMaybe<Scalars['Decimal']['input']>;
  in?: InputMaybe<Array<Scalars['Decimal']['input']>>;
  lt?: InputMaybe<Scalars['Decimal']['input']>;
  lte?: InputMaybe<Scalars['Decimal']['input']>;
  not?: InputMaybe<NestedDecimalNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Decimal']['input']>>;
};

export type NestedEnumClanTagPositionFilter = {
  equals?: InputMaybe<ClanTagPosition>;
  in?: InputMaybe<Array<ClanTagPosition>>;
  not?: InputMaybe<ClanTagPosition>;
  notIn?: InputMaybe<Array<ClanTagPosition>>;
};

export type NestedEnumClanTagPositionWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedEnumClanTagPositionFilter>;
  _min?: InputMaybe<NestedEnumClanTagPositionFilter>;
  equals?: InputMaybe<ClanTagPosition>;
  in?: InputMaybe<Array<ClanTagPosition>>;
  not?: InputMaybe<ClanTagPosition>;
  notIn?: InputMaybe<Array<ClanTagPosition>>;
};

export type NestedFloatFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type NestedFloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type NestedFloatNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedFloatNullableFilter>;
  _min?: InputMaybe<NestedFloatNullableFilter>;
  _sum?: InputMaybe<NestedFloatNullableFilter>;
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type NestedFloatWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedFloatFilter>;
  _min?: InputMaybe<NestedFloatFilter>;
  _sum?: InputMaybe<NestedFloatFilter>;
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type NestedIntFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NestedIntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NestedIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NestedIntWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedIntFilter>;
  _min?: InputMaybe<NestedIntFilter>;
  _sum?: InputMaybe<NestedIntFilter>;
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NestedJsonNullableFilter = {
  array_contains?: InputMaybe<Scalars['Json']['input']>;
  array_ends_with?: InputMaybe<Scalars['Json']['input']>;
  array_starts_with?: InputMaybe<Scalars['Json']['input']>;
  equals?: InputMaybe<Scalars['Json']['input']>;
  gt?: InputMaybe<Scalars['Json']['input']>;
  gte?: InputMaybe<Scalars['Json']['input']>;
  lt?: InputMaybe<Scalars['Json']['input']>;
  lte?: InputMaybe<Scalars['Json']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<Scalars['Json']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  string_contains?: InputMaybe<Scalars['String']['input']>;
  string_ends_with?: InputMaybe<Scalars['String']['input']>;
  string_starts_with?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type NotificationConfig = {
  __typename?: 'NotificationConfig';
  colorEnabled: Scalars['Int']['output'];
  colorScheme?: Maybe<Scalars['Json']['output']>;
  createdAt: Scalars['DateTime']['output'];
  engineType: Scalars['String']['output'];
  eventTypes?: Maybe<Scalars['Json']['output']>;
  messageFormats?: Maybe<Scalars['Json']['output']>;
  server: Server;
  serverId: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type NotificationConfigAvgOrderByAggregateInput = {
  colorEnabled?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type NotificationConfigCountOrderByAggregateInput = {
  colorEnabled?: InputMaybe<SortOrder>;
  colorScheme?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  engineType?: InputMaybe<SortOrder>;
  eventTypes?: InputMaybe<SortOrder>;
  messageFormats?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type NotificationConfigCreateInput = {
  colorEnabled?: InputMaybe<Scalars['Int']['input']>;
  colorScheme?: InputMaybe<Scalars['Json']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  engineType: Scalars['String']['input'];
  eventTypes?: InputMaybe<Scalars['Json']['input']>;
  messageFormats?: InputMaybe<Scalars['Json']['input']>;
  server: ServerCreateNestedOneWithoutNotificationConfigInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type NotificationConfigCreateManyInput = {
  colorEnabled?: InputMaybe<Scalars['Int']['input']>;
  colorScheme?: InputMaybe<Scalars['Json']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  engineType: Scalars['String']['input'];
  eventTypes?: InputMaybe<Scalars['Json']['input']>;
  messageFormats?: InputMaybe<Scalars['Json']['input']>;
  serverId: Scalars['Int']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type NotificationConfigCreateNestedOneWithoutServerInput = {
  connect?: InputMaybe<NotificationConfigWhereUniqueInput>;
  connectOrCreate?: InputMaybe<NotificationConfigCreateOrConnectWithoutServerInput>;
  create?: InputMaybe<NotificationConfigCreateWithoutServerInput>;
};

export type NotificationConfigCreateOrConnectWithoutServerInput = {
  create: NotificationConfigCreateWithoutServerInput;
  where: NotificationConfigWhereUniqueInput;
};

export type NotificationConfigCreateWithoutServerInput = {
  colorEnabled?: InputMaybe<Scalars['Int']['input']>;
  colorScheme?: InputMaybe<Scalars['Json']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  engineType: Scalars['String']['input'];
  eventTypes?: InputMaybe<Scalars['Json']['input']>;
  messageFormats?: InputMaybe<Scalars['Json']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type NotificationConfigMaxOrderByAggregateInput = {
  colorEnabled?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  engineType?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type NotificationConfigMinOrderByAggregateInput = {
  colorEnabled?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  engineType?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type NotificationConfigNullableScalarRelationFilter = {
  is?: InputMaybe<NotificationConfigWhereInput>;
  isNot?: InputMaybe<NotificationConfigWhereInput>;
};

export enum NotificationConfigOrderByRelevanceFieldEnum {
  EngineType = 'engineType'
}

export type NotificationConfigOrderByRelevanceInput = {
  fields: Array<NotificationConfigOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type NotificationConfigOrderByWithAggregationInput = {
  _avg?: InputMaybe<NotificationConfigAvgOrderByAggregateInput>;
  _count?: InputMaybe<NotificationConfigCountOrderByAggregateInput>;
  _max?: InputMaybe<NotificationConfigMaxOrderByAggregateInput>;
  _min?: InputMaybe<NotificationConfigMinOrderByAggregateInput>;
  _sum?: InputMaybe<NotificationConfigSumOrderByAggregateInput>;
  colorEnabled?: InputMaybe<SortOrder>;
  colorScheme?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  engineType?: InputMaybe<SortOrder>;
  eventTypes?: InputMaybe<SortOrder>;
  messageFormats?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type NotificationConfigOrderByWithRelationInput = {
  _relevance?: InputMaybe<NotificationConfigOrderByRelevanceInput>;
  colorEnabled?: InputMaybe<SortOrder>;
  colorScheme?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  engineType?: InputMaybe<SortOrder>;
  eventTypes?: InputMaybe<SortOrder>;
  messageFormats?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum NotificationConfigScalarFieldEnum {
  ColorEnabled = 'colorEnabled',
  ColorScheme = 'colorScheme',
  CreatedAt = 'createdAt',
  EngineType = 'engineType',
  EventTypes = 'eventTypes',
  MessageFormats = 'messageFormats',
  ServerId = 'serverId',
  UpdatedAt = 'updatedAt'
}

export type NotificationConfigScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<NotificationConfigScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<NotificationConfigScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<NotificationConfigScalarWhereWithAggregatesInput>>;
  colorEnabled?: InputMaybe<IntWithAggregatesFilter>;
  colorScheme?: InputMaybe<JsonNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  engineType?: InputMaybe<StringWithAggregatesFilter>;
  eventTypes?: InputMaybe<JsonNullableWithAggregatesFilter>;
  messageFormats?: InputMaybe<JsonNullableWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type NotificationConfigSumOrderByAggregateInput = {
  colorEnabled?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type NotificationConfigUpdateInput = {
  colorEnabled?: InputMaybe<IntFieldUpdateOperationsInput>;
  colorScheme?: InputMaybe<Scalars['Json']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  engineType?: InputMaybe<StringFieldUpdateOperationsInput>;
  eventTypes?: InputMaybe<Scalars['Json']['input']>;
  messageFormats?: InputMaybe<Scalars['Json']['input']>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutNotificationConfigNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type NotificationConfigUpdateManyMutationInput = {
  colorEnabled?: InputMaybe<IntFieldUpdateOperationsInput>;
  colorScheme?: InputMaybe<Scalars['Json']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  engineType?: InputMaybe<StringFieldUpdateOperationsInput>;
  eventTypes?: InputMaybe<Scalars['Json']['input']>;
  messageFormats?: InputMaybe<Scalars['Json']['input']>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type NotificationConfigUpdateOneWithoutServerNestedInput = {
  connect?: InputMaybe<NotificationConfigWhereUniqueInput>;
  connectOrCreate?: InputMaybe<NotificationConfigCreateOrConnectWithoutServerInput>;
  create?: InputMaybe<NotificationConfigCreateWithoutServerInput>;
  delete?: InputMaybe<NotificationConfigWhereInput>;
  disconnect?: InputMaybe<NotificationConfigWhereInput>;
  update?: InputMaybe<NotificationConfigUpdateToOneWithWhereWithoutServerInput>;
  upsert?: InputMaybe<NotificationConfigUpsertWithoutServerInput>;
};

export type NotificationConfigUpdateToOneWithWhereWithoutServerInput = {
  data: NotificationConfigUpdateWithoutServerInput;
  where?: InputMaybe<NotificationConfigWhereInput>;
};

export type NotificationConfigUpdateWithoutServerInput = {
  colorEnabled?: InputMaybe<IntFieldUpdateOperationsInput>;
  colorScheme?: InputMaybe<Scalars['Json']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  engineType?: InputMaybe<StringFieldUpdateOperationsInput>;
  eventTypes?: InputMaybe<Scalars['Json']['input']>;
  messageFormats?: InputMaybe<Scalars['Json']['input']>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type NotificationConfigUpsertWithoutServerInput = {
  create: NotificationConfigCreateWithoutServerInput;
  update: NotificationConfigUpdateWithoutServerInput;
  where?: InputMaybe<NotificationConfigWhereInput>;
};

export type NotificationConfigWhereInput = {
  AND?: InputMaybe<Array<NotificationConfigWhereInput>>;
  NOT?: InputMaybe<Array<NotificationConfigWhereInput>>;
  OR?: InputMaybe<Array<NotificationConfigWhereInput>>;
  colorEnabled?: InputMaybe<IntFilter>;
  colorScheme?: InputMaybe<JsonNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  engineType?: InputMaybe<StringFilter>;
  eventTypes?: InputMaybe<JsonNullableFilter>;
  messageFormats?: InputMaybe<JsonNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type NotificationConfigWhereUniqueInput = {
  AND?: InputMaybe<Array<NotificationConfigWhereInput>>;
  NOT?: InputMaybe<Array<NotificationConfigWhereInput>>;
  OR?: InputMaybe<Array<NotificationConfigWhereInput>>;
  colorEnabled?: InputMaybe<IntFilter>;
  colorScheme?: InputMaybe<JsonNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  engineType?: InputMaybe<StringFilter>;
  eventTypes?: InputMaybe<JsonNullableFilter>;
  messageFormats?: InputMaybe<JsonNullableFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type NullableBoolFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['Boolean']['input']>;
};

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['DateTime']['input']>;
};

export type NullableDecimalFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Decimal']['input']>;
  divide?: InputMaybe<Scalars['Decimal']['input']>;
  increment?: InputMaybe<Scalars['Decimal']['input']>;
  multiply?: InputMaybe<Scalars['Decimal']['input']>;
  set?: InputMaybe<Scalars['Decimal']['input']>;
};

export type NullableFloatFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Float']['input']>;
  divide?: InputMaybe<Scalars['Float']['input']>;
  increment?: InputMaybe<Scalars['Float']['input']>;
  multiply?: InputMaybe<Scalars['Float']['input']>;
  set?: InputMaybe<Scalars['Float']['input']>;
};

export type NullableIntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Int']['input']>;
  divide?: InputMaybe<Scalars['Int']['input']>;
  increment?: InputMaybe<Scalars['Int']['input']>;
  multiply?: InputMaybe<Scalars['Int']['input']>;
  set?: InputMaybe<Scalars['Int']['input']>;
};

export enum NullableJsonNullValueInput {
  DbNull = 'DbNull',
  JsonNull = 'JsonNull'
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']['input']>;
};

export enum NullsOrder {
  First = 'first',
  Last = 'last'
}

export type Option = {
  __typename?: 'Option';
  choices: Array<OptionChoice>;
  keyname: Scalars['ID']['output'];
  opttype: Scalars['Int']['output'];
  value: Scalars['String']['output'];
};


export type OptionChoicesArgs = {
  cursor?: InputMaybe<OptionChoiceWhereUniqueInput>;
  distinct?: InputMaybe<Array<OptionChoiceScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OptionChoiceOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OptionChoiceWhereInput>;
};

export type OptionAvgOrderByAggregateInput = {
  opttype?: InputMaybe<SortOrder>;
};

export type OptionChoice = {
  __typename?: 'OptionChoice';
  isDefault: Scalars['Int']['output'];
  keyname: Scalars['String']['output'];
  option: Option;
  text: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type OptionChoiceAvgOrderByAggregateInput = {
  isDefault?: InputMaybe<SortOrder>;
};

export type OptionChoiceCountOrderByAggregateInput = {
  isDefault?: InputMaybe<SortOrder>;
  keyname?: InputMaybe<SortOrder>;
  text?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type OptionChoiceCreateInput = {
  isDefault?: InputMaybe<Scalars['Int']['input']>;
  option: OptionCreateNestedOneWithoutChoicesInput;
  text?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type OptionChoiceCreateManyInput = {
  isDefault?: InputMaybe<Scalars['Int']['input']>;
  keyname: Scalars['String']['input'];
  text?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type OptionChoiceCreateManyOptionInput = {
  isDefault?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type OptionChoiceCreateManyOptionInputEnvelope = {
  data: Array<OptionChoiceCreateManyOptionInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OptionChoiceCreateNestedManyWithoutOptionInput = {
  connect?: InputMaybe<Array<OptionChoiceWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<OptionChoiceCreateOrConnectWithoutOptionInput>>;
  create?: InputMaybe<Array<OptionChoiceCreateWithoutOptionInput>>;
  createMany?: InputMaybe<OptionChoiceCreateManyOptionInputEnvelope>;
};

export type OptionChoiceCreateOrConnectWithoutOptionInput = {
  create: OptionChoiceCreateWithoutOptionInput;
  where: OptionChoiceWhereUniqueInput;
};

export type OptionChoiceCreateWithoutOptionInput = {
  isDefault?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type OptionChoiceKeynameValueCompoundUniqueInput = {
  keyname: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type OptionChoiceListRelationFilter = {
  every?: InputMaybe<OptionChoiceWhereInput>;
  none?: InputMaybe<OptionChoiceWhereInput>;
  some?: InputMaybe<OptionChoiceWhereInput>;
};

export type OptionChoiceMaxOrderByAggregateInput = {
  isDefault?: InputMaybe<SortOrder>;
  keyname?: InputMaybe<SortOrder>;
  text?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type OptionChoiceMinOrderByAggregateInput = {
  isDefault?: InputMaybe<SortOrder>;
  keyname?: InputMaybe<SortOrder>;
  text?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type OptionChoiceOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum OptionChoiceOrderByRelevanceFieldEnum {
  Keyname = 'keyname',
  Text = 'text',
  Value = 'value'
}

export type OptionChoiceOrderByRelevanceInput = {
  fields: Array<OptionChoiceOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type OptionChoiceOrderByWithAggregationInput = {
  _avg?: InputMaybe<OptionChoiceAvgOrderByAggregateInput>;
  _count?: InputMaybe<OptionChoiceCountOrderByAggregateInput>;
  _max?: InputMaybe<OptionChoiceMaxOrderByAggregateInput>;
  _min?: InputMaybe<OptionChoiceMinOrderByAggregateInput>;
  _sum?: InputMaybe<OptionChoiceSumOrderByAggregateInput>;
  isDefault?: InputMaybe<SortOrder>;
  keyname?: InputMaybe<SortOrder>;
  text?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type OptionChoiceOrderByWithRelationInput = {
  _relevance?: InputMaybe<OptionChoiceOrderByRelevanceInput>;
  isDefault?: InputMaybe<SortOrder>;
  keyname?: InputMaybe<SortOrder>;
  option?: InputMaybe<OptionOrderByWithRelationInput>;
  text?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum OptionChoiceScalarFieldEnum {
  IsDefault = 'isDefault',
  Keyname = 'keyname',
  Text = 'text',
  Value = 'value'
}

export type OptionChoiceScalarWhereInput = {
  AND?: InputMaybe<Array<OptionChoiceScalarWhereInput>>;
  NOT?: InputMaybe<Array<OptionChoiceScalarWhereInput>>;
  OR?: InputMaybe<Array<OptionChoiceScalarWhereInput>>;
  isDefault?: InputMaybe<IntFilter>;
  keyname?: InputMaybe<StringFilter>;
  text?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type OptionChoiceScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<OptionChoiceScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<OptionChoiceScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<OptionChoiceScalarWhereWithAggregatesInput>>;
  isDefault?: InputMaybe<IntWithAggregatesFilter>;
  keyname?: InputMaybe<StringWithAggregatesFilter>;
  text?: InputMaybe<StringWithAggregatesFilter>;
  value?: InputMaybe<StringWithAggregatesFilter>;
};

export type OptionChoiceSumOrderByAggregateInput = {
  isDefault?: InputMaybe<SortOrder>;
};

export type OptionChoiceUpdateInput = {
  isDefault?: InputMaybe<IntFieldUpdateOperationsInput>;
  option?: InputMaybe<OptionUpdateOneRequiredWithoutChoicesNestedInput>;
  text?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type OptionChoiceUpdateManyMutationInput = {
  isDefault?: InputMaybe<IntFieldUpdateOperationsInput>;
  text?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type OptionChoiceUpdateManyWithWhereWithoutOptionInput = {
  data: OptionChoiceUpdateManyMutationInput;
  where: OptionChoiceScalarWhereInput;
};

export type OptionChoiceUpdateManyWithoutOptionNestedInput = {
  connect?: InputMaybe<Array<OptionChoiceWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<OptionChoiceCreateOrConnectWithoutOptionInput>>;
  create?: InputMaybe<Array<OptionChoiceCreateWithoutOptionInput>>;
  createMany?: InputMaybe<OptionChoiceCreateManyOptionInputEnvelope>;
  delete?: InputMaybe<Array<OptionChoiceWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<OptionChoiceScalarWhereInput>>;
  disconnect?: InputMaybe<Array<OptionChoiceWhereUniqueInput>>;
  set?: InputMaybe<Array<OptionChoiceWhereUniqueInput>>;
  update?: InputMaybe<Array<OptionChoiceUpdateWithWhereUniqueWithoutOptionInput>>;
  updateMany?: InputMaybe<Array<OptionChoiceUpdateManyWithWhereWithoutOptionInput>>;
  upsert?: InputMaybe<Array<OptionChoiceUpsertWithWhereUniqueWithoutOptionInput>>;
};

export type OptionChoiceUpdateWithWhereUniqueWithoutOptionInput = {
  data: OptionChoiceUpdateWithoutOptionInput;
  where: OptionChoiceWhereUniqueInput;
};

export type OptionChoiceUpdateWithoutOptionInput = {
  isDefault?: InputMaybe<IntFieldUpdateOperationsInput>;
  text?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type OptionChoiceUpsertWithWhereUniqueWithoutOptionInput = {
  create: OptionChoiceCreateWithoutOptionInput;
  update: OptionChoiceUpdateWithoutOptionInput;
  where: OptionChoiceWhereUniqueInput;
};

export type OptionChoiceWhereInput = {
  AND?: InputMaybe<Array<OptionChoiceWhereInput>>;
  NOT?: InputMaybe<Array<OptionChoiceWhereInput>>;
  OR?: InputMaybe<Array<OptionChoiceWhereInput>>;
  isDefault?: InputMaybe<IntFilter>;
  keyname?: InputMaybe<StringFilter>;
  option?: InputMaybe<OptionWhereInput>;
  text?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type OptionChoiceWhereUniqueInput = {
  AND?: InputMaybe<Array<OptionChoiceWhereInput>>;
  NOT?: InputMaybe<Array<OptionChoiceWhereInput>>;
  OR?: InputMaybe<Array<OptionChoiceWhereInput>>;
  isDefault?: InputMaybe<IntFilter>;
  keyname?: InputMaybe<StringFilter>;
  keyname_value?: InputMaybe<OptionChoiceKeynameValueCompoundUniqueInput>;
  option?: InputMaybe<OptionWhereInput>;
  text?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type OptionCountOrderByAggregateInput = {
  keyname?: InputMaybe<SortOrder>;
  opttype?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type OptionCreateInput = {
  choices?: InputMaybe<OptionChoiceCreateNestedManyWithoutOptionInput>;
  keyname: Scalars['String']['input'];
  opttype?: InputMaybe<Scalars['Int']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type OptionCreateManyInput = {
  keyname: Scalars['String']['input'];
  opttype?: InputMaybe<Scalars['Int']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type OptionCreateNestedOneWithoutChoicesInput = {
  connect?: InputMaybe<OptionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<OptionCreateOrConnectWithoutChoicesInput>;
  create?: InputMaybe<OptionCreateWithoutChoicesInput>;
};

export type OptionCreateOrConnectWithoutChoicesInput = {
  create: OptionCreateWithoutChoicesInput;
  where: OptionWhereUniqueInput;
};

export type OptionCreateWithoutChoicesInput = {
  keyname: Scalars['String']['input'];
  opttype?: InputMaybe<Scalars['Int']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type OptionMaxOrderByAggregateInput = {
  keyname?: InputMaybe<SortOrder>;
  opttype?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type OptionMinOrderByAggregateInput = {
  keyname?: InputMaybe<SortOrder>;
  opttype?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum OptionOrderByRelevanceFieldEnum {
  Keyname = 'keyname',
  Value = 'value'
}

export type OptionOrderByRelevanceInput = {
  fields: Array<OptionOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type OptionOrderByWithAggregationInput = {
  _avg?: InputMaybe<OptionAvgOrderByAggregateInput>;
  _count?: InputMaybe<OptionCountOrderByAggregateInput>;
  _max?: InputMaybe<OptionMaxOrderByAggregateInput>;
  _min?: InputMaybe<OptionMinOrderByAggregateInput>;
  _sum?: InputMaybe<OptionSumOrderByAggregateInput>;
  keyname?: InputMaybe<SortOrder>;
  opttype?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type OptionOrderByWithRelationInput = {
  _relevance?: InputMaybe<OptionOrderByRelevanceInput>;
  choices?: InputMaybe<OptionChoiceOrderByRelationAggregateInput>;
  keyname?: InputMaybe<SortOrder>;
  opttype?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum OptionScalarFieldEnum {
  Keyname = 'keyname',
  Opttype = 'opttype',
  Value = 'value'
}

export type OptionScalarRelationFilter = {
  is?: InputMaybe<OptionWhereInput>;
  isNot?: InputMaybe<OptionWhereInput>;
};

export type OptionScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<OptionScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<OptionScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<OptionScalarWhereWithAggregatesInput>>;
  keyname?: InputMaybe<StringWithAggregatesFilter>;
  opttype?: InputMaybe<IntWithAggregatesFilter>;
  value?: InputMaybe<StringWithAggregatesFilter>;
};

export type OptionSumOrderByAggregateInput = {
  opttype?: InputMaybe<SortOrder>;
};

export type OptionUpdateInput = {
  choices?: InputMaybe<OptionChoiceUpdateManyWithoutOptionNestedInput>;
  keyname?: InputMaybe<StringFieldUpdateOperationsInput>;
  opttype?: InputMaybe<IntFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type OptionUpdateManyMutationInput = {
  keyname?: InputMaybe<StringFieldUpdateOperationsInput>;
  opttype?: InputMaybe<IntFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type OptionUpdateOneRequiredWithoutChoicesNestedInput = {
  connect?: InputMaybe<OptionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<OptionCreateOrConnectWithoutChoicesInput>;
  create?: InputMaybe<OptionCreateWithoutChoicesInput>;
  update?: InputMaybe<OptionUpdateToOneWithWhereWithoutChoicesInput>;
  upsert?: InputMaybe<OptionUpsertWithoutChoicesInput>;
};

export type OptionUpdateToOneWithWhereWithoutChoicesInput = {
  data: OptionUpdateWithoutChoicesInput;
  where?: InputMaybe<OptionWhereInput>;
};

export type OptionUpdateWithoutChoicesInput = {
  keyname?: InputMaybe<StringFieldUpdateOperationsInput>;
  opttype?: InputMaybe<IntFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type OptionUpsertWithoutChoicesInput = {
  create: OptionCreateWithoutChoicesInput;
  update: OptionUpdateWithoutChoicesInput;
  where?: InputMaybe<OptionWhereInput>;
};

export type OptionWhereInput = {
  AND?: InputMaybe<Array<OptionWhereInput>>;
  NOT?: InputMaybe<Array<OptionWhereInput>>;
  OR?: InputMaybe<Array<OptionWhereInput>>;
  choices?: InputMaybe<OptionChoiceListRelationFilter>;
  keyname?: InputMaybe<StringFilter>;
  opttype?: InputMaybe<IntFilter>;
  value?: InputMaybe<StringFilter>;
};

export type OptionWhereUniqueInput = {
  AND?: InputMaybe<Array<OptionWhereInput>>;
  NOT?: InputMaybe<Array<OptionWhereInput>>;
  OR?: InputMaybe<Array<OptionWhereInput>>;
  choices?: InputMaybe<OptionChoiceListRelationFilter>;
  keyname?: InputMaybe<Scalars['String']['input']>;
  opttype?: InputMaybe<IntFilter>;
  value?: InputMaybe<StringFilter>;
};

export type Player = {
  __typename?: 'Player';
  activity: Scalars['Int']['output'];
  awards: Array<PlayerAward>;
  awardsWonAsDWinner: Array<Award>;
  awardsWonAsGWinner: Array<Award>;
  blockAvatar: Scalars['Int']['output'];
  chats: Array<EventChat>;
  city: Scalars['String']['output'];
  clan?: Maybe<Clan>;
  clanId?: Maybe<Scalars['Int']['output']>;
  connectionTime: Scalars['Int']['output'];
  connects: Array<EventConnect>;
  country: Scalars['String']['output'];
  countryData?: Maybe<Country>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  deathStreak: Scalars['Int']['output'];
  deaths: Scalars['Int']['output'];
  disconnects: Array<EventDisconnect>;
  displayEvents: Scalars['Int']['output'];
  email?: Maybe<Scalars['String']['output']>;
  entries: Array<EventEntry>;
  flag?: Maybe<Scalars['String']['output']>;
  fragsAsKiller: Array<EventFrag>;
  fragsAsVictim: Array<EventFrag>;
  fullName?: Maybe<Scalars['String']['output']>;
  game: Scalars['String']['output'];
  gameData: Game;
  headshots: Scalars['Int']['output'];
  hideRanking: Scalars['Int']['output'];
  history: Array<PlayerHistory>;
  hits: Scalars['Int']['output'];
  killStreak: Scalars['Int']['output'];
  kills: Scalars['Int']['output'];
  lastAddress: Scalars['String']['output'];
  lastEvent?: Maybe<Scalars['DateTime']['output']>;
  lastName: Scalars['String']['output'];
  lastSkillChange?: Maybe<Scalars['DateTime']['output']>;
  lat?: Maybe<Scalars['Float']['output']>;
  latencyEvents: Array<EventLatency>;
  lng?: Maybe<Scalars['Float']['output']>;
  mmrank?: Maybe<Scalars['Int']['output']>;
  nameChanges: Array<EventChangeName>;
  names: Array<PlayerName>;
  playerActions: Array<EventPlayerAction>;
  playerId: Scalars['ID']['output'];
  playerPlayerActionsAsActor: Array<EventPlayerPlayerAction>;
  playerPlayerActionsAsVictim: Array<EventPlayerPlayerAction>;
  ribbons: Array<PlayerRibbon>;
  roleChanges: Array<EventChangeRole>;
  shots: Scalars['Int']['output'];
  skill: Scalars['Int']['output'];
  state: Scalars['String']['output'];
  suicideEvents: Array<EventSuicide>;
  suicides: Scalars['Int']['output'];
  teamBonuses: Array<EventTeamBonus>;
  teamChanges: Array<EventChangeTeam>;
  teamkills: Scalars['Int']['output'];
  teamkillsAsKiller: Array<EventTeamkill>;
  teamkillsAsVictim: Array<EventTeamkill>;
  uniqueIds: Array<PlayerUniqueId>;
};


export type PlayerAwardsArgs = {
  cursor?: InputMaybe<PlayerAwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerAwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerAwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerAwardWhereInput>;
};


export type PlayerAwardsWonAsDWinnerArgs = {
  cursor?: InputMaybe<AwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<AwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AwardWhereInput>;
};


export type PlayerAwardsWonAsGWinnerArgs = {
  cursor?: InputMaybe<AwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<AwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AwardWhereInput>;
};


export type PlayerChatsArgs = {
  cursor?: InputMaybe<EventChatWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChatScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChatOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChatWhereInput>;
};


export type PlayerConnectsArgs = {
  cursor?: InputMaybe<EventConnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventConnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventConnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventConnectWhereInput>;
};


export type PlayerDisconnectsArgs = {
  cursor?: InputMaybe<EventDisconnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventDisconnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventDisconnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventDisconnectWhereInput>;
};


export type PlayerEntriesArgs = {
  cursor?: InputMaybe<EventEntryWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventEntryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventEntryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventEntryWhereInput>;
};


export type PlayerFragsAsKillerArgs = {
  cursor?: InputMaybe<EventFragWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventFragScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventFragOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventFragWhereInput>;
};


export type PlayerFragsAsVictimArgs = {
  cursor?: InputMaybe<EventFragWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventFragScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventFragOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventFragWhereInput>;
};


export type PlayerHistoryArgs = {
  cursor?: InputMaybe<PlayerHistoryWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerHistoryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerHistoryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerHistoryWhereInput>;
};


export type PlayerLatencyEventsArgs = {
  cursor?: InputMaybe<EventLatencyWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventLatencyScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventLatencyOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventLatencyWhereInput>;
};


export type PlayerNameChangesArgs = {
  cursor?: InputMaybe<EventChangeNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeNameWhereInput>;
};


export type PlayerNamesArgs = {
  cursor?: InputMaybe<PlayerNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerNameWhereInput>;
};


export type PlayerPlayerActionsArgs = {
  cursor?: InputMaybe<EventPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerActionWhereInput>;
};


export type PlayerPlayerPlayerActionsAsActorArgs = {
  cursor?: InputMaybe<EventPlayerPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type PlayerPlayerPlayerActionsAsVictimArgs = {
  cursor?: InputMaybe<EventPlayerPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type PlayerRibbonsArgs = {
  cursor?: InputMaybe<PlayerRibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerRibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerRibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerRibbonWhereInput>;
};


export type PlayerRoleChangesArgs = {
  cursor?: InputMaybe<EventChangeRoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeRoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeRoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeRoleWhereInput>;
};


export type PlayerSuicideEventsArgs = {
  cursor?: InputMaybe<EventSuicideWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventSuicideScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventSuicideOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventSuicideWhereInput>;
};


export type PlayerTeamBonusesArgs = {
  cursor?: InputMaybe<EventTeamBonusWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamBonusScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamBonusOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamBonusWhereInput>;
};


export type PlayerTeamChangesArgs = {
  cursor?: InputMaybe<EventChangeTeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeTeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeTeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeTeamWhereInput>;
};


export type PlayerTeamkillsAsKillerArgs = {
  cursor?: InputMaybe<EventTeamkillWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamkillScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamkillOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamkillWhereInput>;
};


export type PlayerTeamkillsAsVictimArgs = {
  cursor?: InputMaybe<EventTeamkillWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamkillScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamkillOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamkillWhereInput>;
};


export type PlayerUniqueIdsArgs = {
  cursor?: InputMaybe<PlayerUniqueIdWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerUniqueIdScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerUniqueIdOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerUniqueIdWhereInput>;
};

export type PlayerAvgOrderByAggregateInput = {
  activity?: InputMaybe<SortOrder>;
  blockAvatar?: InputMaybe<SortOrder>;
  clanId?: InputMaybe<SortOrder>;
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  displayEvents?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hideRanking?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mmrank?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerAward = {
  __typename?: 'PlayerAward';
  award: Award;
  awardId: Scalars['Int']['output'];
  awardTime: Scalars['DateTime']['output'];
  count: Scalars['Int']['output'];
  game: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
};

export type PlayerAwardAvgOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerAwardAwardTimeAwardIdPlayerIdGameCompoundUniqueInput = {
  awardId: Scalars['Int']['input'];
  awardTime: Scalars['DateTime']['input'];
  game: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
};

export type PlayerAwardCountOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  awardTime?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerAwardCreateInput = {
  award: AwardCreateNestedOneWithoutPlayerAwardsInput;
  awardTime: Scalars['DateTime']['input'];
  count?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
  player: PlayerCreateNestedOneWithoutAwardsInput;
};

export type PlayerAwardCreateManyAwardInput = {
  awardTime: Scalars['DateTime']['input'];
  count?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
};

export type PlayerAwardCreateManyAwardInputEnvelope = {
  data: Array<PlayerAwardCreateManyAwardInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerAwardCreateManyInput = {
  awardId: Scalars['Int']['input'];
  awardTime: Scalars['DateTime']['input'];
  count?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
};

export type PlayerAwardCreateManyPlayerInput = {
  awardId: Scalars['Int']['input'];
  awardTime: Scalars['DateTime']['input'];
  count?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
};

export type PlayerAwardCreateManyPlayerInputEnvelope = {
  data: Array<PlayerAwardCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerAwardCreateNestedManyWithoutAwardInput = {
  connect?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerAwardCreateOrConnectWithoutAwardInput>>;
  create?: InputMaybe<Array<PlayerAwardCreateWithoutAwardInput>>;
  createMany?: InputMaybe<PlayerAwardCreateManyAwardInputEnvelope>;
};

export type PlayerAwardCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerAwardCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerAwardCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerAwardCreateManyPlayerInputEnvelope>;
};

export type PlayerAwardCreateOrConnectWithoutAwardInput = {
  create: PlayerAwardCreateWithoutAwardInput;
  where: PlayerAwardWhereUniqueInput;
};

export type PlayerAwardCreateOrConnectWithoutPlayerInput = {
  create: PlayerAwardCreateWithoutPlayerInput;
  where: PlayerAwardWhereUniqueInput;
};

export type PlayerAwardCreateWithoutAwardInput = {
  awardTime: Scalars['DateTime']['input'];
  count?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
  player: PlayerCreateNestedOneWithoutAwardsInput;
};

export type PlayerAwardCreateWithoutPlayerInput = {
  award: AwardCreateNestedOneWithoutPlayerAwardsInput;
  awardTime: Scalars['DateTime']['input'];
  count?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
};

export type PlayerAwardListRelationFilter = {
  every?: InputMaybe<PlayerAwardWhereInput>;
  none?: InputMaybe<PlayerAwardWhereInput>;
  some?: InputMaybe<PlayerAwardWhereInput>;
};

export type PlayerAwardMaxOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  awardTime?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerAwardMinOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  awardTime?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerAwardOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum PlayerAwardOrderByRelevanceFieldEnum {
  Game = 'game'
}

export type PlayerAwardOrderByRelevanceInput = {
  fields: Array<PlayerAwardOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type PlayerAwardOrderByWithAggregationInput = {
  _avg?: InputMaybe<PlayerAwardAvgOrderByAggregateInput>;
  _count?: InputMaybe<PlayerAwardCountOrderByAggregateInput>;
  _max?: InputMaybe<PlayerAwardMaxOrderByAggregateInput>;
  _min?: InputMaybe<PlayerAwardMinOrderByAggregateInput>;
  _sum?: InputMaybe<PlayerAwardSumOrderByAggregateInput>;
  awardId?: InputMaybe<SortOrder>;
  awardTime?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerAwardOrderByWithRelationInput = {
  _relevance?: InputMaybe<PlayerAwardOrderByRelevanceInput>;
  award?: InputMaybe<AwardOrderByWithRelationInput>;
  awardId?: InputMaybe<SortOrder>;
  awardTime?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
};

export enum PlayerAwardScalarFieldEnum {
  AwardId = 'awardId',
  AwardTime = 'awardTime',
  Count = 'count',
  Game = 'game',
  PlayerId = 'playerId'
}

export type PlayerAwardScalarWhereInput = {
  AND?: InputMaybe<Array<PlayerAwardScalarWhereInput>>;
  NOT?: InputMaybe<Array<PlayerAwardScalarWhereInput>>;
  OR?: InputMaybe<Array<PlayerAwardScalarWhereInput>>;
  awardId?: InputMaybe<IntFilter>;
  awardTime?: InputMaybe<DateTimeFilter>;
  count?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
};

export type PlayerAwardScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<PlayerAwardScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<PlayerAwardScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<PlayerAwardScalarWhereWithAggregatesInput>>;
  awardId?: InputMaybe<IntWithAggregatesFilter>;
  awardTime?: InputMaybe<DateTimeWithAggregatesFilter>;
  count?: InputMaybe<IntWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
};

export type PlayerAwardSumOrderByAggregateInput = {
  awardId?: InputMaybe<SortOrder>;
  count?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerAwardUpdateInput = {
  award?: InputMaybe<AwardUpdateOneRequiredWithoutPlayerAwardsNestedInput>;
  awardTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutAwardsNestedInput>;
};

export type PlayerAwardUpdateManyMutationInput = {
  awardTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PlayerAwardUpdateManyWithWhereWithoutAwardInput = {
  data: PlayerAwardUpdateManyMutationInput;
  where: PlayerAwardScalarWhereInput;
};

export type PlayerAwardUpdateManyWithWhereWithoutPlayerInput = {
  data: PlayerAwardUpdateManyMutationInput;
  where: PlayerAwardScalarWhereInput;
};

export type PlayerAwardUpdateManyWithoutAwardNestedInput = {
  connect?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerAwardCreateOrConnectWithoutAwardInput>>;
  create?: InputMaybe<Array<PlayerAwardCreateWithoutAwardInput>>;
  createMany?: InputMaybe<PlayerAwardCreateManyAwardInputEnvelope>;
  delete?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerAwardScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerAwardUpdateWithWhereUniqueWithoutAwardInput>>;
  updateMany?: InputMaybe<Array<PlayerAwardUpdateManyWithWhereWithoutAwardInput>>;
  upsert?: InputMaybe<Array<PlayerAwardUpsertWithWhereUniqueWithoutAwardInput>>;
};

export type PlayerAwardUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerAwardCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerAwardCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerAwardCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerAwardScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerAwardWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerAwardUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<PlayerAwardUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<PlayerAwardUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type PlayerAwardUpdateWithWhereUniqueWithoutAwardInput = {
  data: PlayerAwardUpdateWithoutAwardInput;
  where: PlayerAwardWhereUniqueInput;
};

export type PlayerAwardUpdateWithWhereUniqueWithoutPlayerInput = {
  data: PlayerAwardUpdateWithoutPlayerInput;
  where: PlayerAwardWhereUniqueInput;
};

export type PlayerAwardUpdateWithoutAwardInput = {
  awardTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutAwardsNestedInput>;
};

export type PlayerAwardUpdateWithoutPlayerInput = {
  award?: InputMaybe<AwardUpdateOneRequiredWithoutPlayerAwardsNestedInput>;
  awardTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  count?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PlayerAwardUpsertWithWhereUniqueWithoutAwardInput = {
  create: PlayerAwardCreateWithoutAwardInput;
  update: PlayerAwardUpdateWithoutAwardInput;
  where: PlayerAwardWhereUniqueInput;
};

export type PlayerAwardUpsertWithWhereUniqueWithoutPlayerInput = {
  create: PlayerAwardCreateWithoutPlayerInput;
  update: PlayerAwardUpdateWithoutPlayerInput;
  where: PlayerAwardWhereUniqueInput;
};

export type PlayerAwardWhereInput = {
  AND?: InputMaybe<Array<PlayerAwardWhereInput>>;
  NOT?: InputMaybe<Array<PlayerAwardWhereInput>>;
  OR?: InputMaybe<Array<PlayerAwardWhereInput>>;
  award?: InputMaybe<AwardWhereInput>;
  awardId?: InputMaybe<IntFilter>;
  awardTime?: InputMaybe<DateTimeFilter>;
  count?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
};

export type PlayerAwardWhereUniqueInput = {
  AND?: InputMaybe<Array<PlayerAwardWhereInput>>;
  NOT?: InputMaybe<Array<PlayerAwardWhereInput>>;
  OR?: InputMaybe<Array<PlayerAwardWhereInput>>;
  award?: InputMaybe<AwardWhereInput>;
  awardId?: InputMaybe<IntFilter>;
  awardTime?: InputMaybe<DateTimeFilter>;
  awardTime_awardId_playerId_game?: InputMaybe<PlayerAwardAwardTimeAwardIdPlayerIdGameCompoundUniqueInput>;
  count?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
};

export type PlayerCountOrderByAggregateInput = {
  activity?: InputMaybe<SortOrder>;
  blockAvatar?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  clanId?: InputMaybe<SortOrder>;
  connectionTime?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  displayEvents?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  flag?: InputMaybe<SortOrder>;
  fullName?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hideRanking?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastAddress?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lastName?: InputMaybe<SortOrder>;
  lastSkillChange?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mmrank?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerCreateInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateManyClanInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  flag?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  game: Scalars['String']['input'];
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerCreateManyClanInputEnvelope = {
  data: Array<PlayerCreateManyClanInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerCreateManyCountryDataInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  clanId?: InputMaybe<Scalars['Int']['input']>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  game: Scalars['String']['input'];
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerCreateManyCountryDataInputEnvelope = {
  data: Array<PlayerCreateManyCountryDataInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerCreateManyGameDataInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  clanId?: InputMaybe<Scalars['Int']['input']>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  flag?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerCreateManyGameDataInputEnvelope = {
  data: Array<PlayerCreateManyGameDataInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerCreateManyInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  clanId?: InputMaybe<Scalars['Int']['input']>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  flag?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  game: Scalars['String']['input'];
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerCreateNestedManyWithoutClanInput = {
  connect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerCreateOrConnectWithoutClanInput>>;
  create?: InputMaybe<Array<PlayerCreateWithoutClanInput>>;
  createMany?: InputMaybe<PlayerCreateManyClanInputEnvelope>;
};

export type PlayerCreateNestedManyWithoutCountryDataInput = {
  connect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerCreateOrConnectWithoutCountryDataInput>>;
  create?: InputMaybe<Array<PlayerCreateWithoutCountryDataInput>>;
  createMany?: InputMaybe<PlayerCreateManyCountryDataInputEnvelope>;
};

export type PlayerCreateNestedManyWithoutGameDataInput = {
  connect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerCreateOrConnectWithoutGameDataInput>>;
  create?: InputMaybe<Array<PlayerCreateWithoutGameDataInput>>;
  createMany?: InputMaybe<PlayerCreateManyGameDataInputEnvelope>;
};

export type PlayerCreateNestedOneWithoutAwardsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutAwardsInput>;
  create?: InputMaybe<PlayerCreateWithoutAwardsInput>;
};

export type PlayerCreateNestedOneWithoutAwardsWonAsDWinnerInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutAwardsWonAsDWinnerInput>;
  create?: InputMaybe<PlayerCreateWithoutAwardsWonAsDWinnerInput>;
};

export type PlayerCreateNestedOneWithoutAwardsWonAsGWinnerInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutAwardsWonAsGWinnerInput>;
  create?: InputMaybe<PlayerCreateWithoutAwardsWonAsGWinnerInput>;
};

export type PlayerCreateNestedOneWithoutChatsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutChatsInput>;
  create?: InputMaybe<PlayerCreateWithoutChatsInput>;
};

export type PlayerCreateNestedOneWithoutConnectsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutConnectsInput>;
  create?: InputMaybe<PlayerCreateWithoutConnectsInput>;
};

export type PlayerCreateNestedOneWithoutDisconnectsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutDisconnectsInput>;
  create?: InputMaybe<PlayerCreateWithoutDisconnectsInput>;
};

export type PlayerCreateNestedOneWithoutEntriesInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutEntriesInput>;
  create?: InputMaybe<PlayerCreateWithoutEntriesInput>;
};

export type PlayerCreateNestedOneWithoutFragsAsKillerInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutFragsAsKillerInput>;
  create?: InputMaybe<PlayerCreateWithoutFragsAsKillerInput>;
};

export type PlayerCreateNestedOneWithoutFragsAsVictimInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutFragsAsVictimInput>;
  create?: InputMaybe<PlayerCreateWithoutFragsAsVictimInput>;
};

export type PlayerCreateNestedOneWithoutHistoryInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutHistoryInput>;
  create?: InputMaybe<PlayerCreateWithoutHistoryInput>;
};

export type PlayerCreateNestedOneWithoutLatencyEventsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutLatencyEventsInput>;
  create?: InputMaybe<PlayerCreateWithoutLatencyEventsInput>;
};

export type PlayerCreateNestedOneWithoutNameChangesInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutNameChangesInput>;
  create?: InputMaybe<PlayerCreateWithoutNameChangesInput>;
};

export type PlayerCreateNestedOneWithoutNamesInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutNamesInput>;
  create?: InputMaybe<PlayerCreateWithoutNamesInput>;
};

export type PlayerCreateNestedOneWithoutPlayerActionsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutPlayerActionsInput>;
  create?: InputMaybe<PlayerCreateWithoutPlayerActionsInput>;
};

export type PlayerCreateNestedOneWithoutPlayerPlayerActionsAsActorInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutPlayerPlayerActionsAsActorInput>;
  create?: InputMaybe<PlayerCreateWithoutPlayerPlayerActionsAsActorInput>;
};

export type PlayerCreateNestedOneWithoutPlayerPlayerActionsAsVictimInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutPlayerPlayerActionsAsVictimInput>;
  create?: InputMaybe<PlayerCreateWithoutPlayerPlayerActionsAsVictimInput>;
};

export type PlayerCreateNestedOneWithoutRibbonsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutRibbonsInput>;
  create?: InputMaybe<PlayerCreateWithoutRibbonsInput>;
};

export type PlayerCreateNestedOneWithoutRoleChangesInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutRoleChangesInput>;
  create?: InputMaybe<PlayerCreateWithoutRoleChangesInput>;
};

export type PlayerCreateNestedOneWithoutSuicideEventsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutSuicideEventsInput>;
  create?: InputMaybe<PlayerCreateWithoutSuicideEventsInput>;
};

export type PlayerCreateNestedOneWithoutTeamBonusesInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamBonusesInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamBonusesInput>;
};

export type PlayerCreateNestedOneWithoutTeamChangesInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamChangesInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamChangesInput>;
};

export type PlayerCreateNestedOneWithoutTeamkillsAsKillerInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamkillsAsKillerInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamkillsAsKillerInput>;
};

export type PlayerCreateNestedOneWithoutTeamkillsAsVictimInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamkillsAsVictimInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamkillsAsVictimInput>;
};

export type PlayerCreateNestedOneWithoutUniqueIdsInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutUniqueIdsInput>;
  create?: InputMaybe<PlayerCreateWithoutUniqueIdsInput>;
};

export type PlayerCreateOrConnectWithoutAwardsInput = {
  create: PlayerCreateWithoutAwardsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutAwardsWonAsDWinnerInput = {
  create: PlayerCreateWithoutAwardsWonAsDWinnerInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutAwardsWonAsGWinnerInput = {
  create: PlayerCreateWithoutAwardsWonAsGWinnerInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutChatsInput = {
  create: PlayerCreateWithoutChatsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutClanInput = {
  create: PlayerCreateWithoutClanInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutConnectsInput = {
  create: PlayerCreateWithoutConnectsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutCountryDataInput = {
  create: PlayerCreateWithoutCountryDataInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutDisconnectsInput = {
  create: PlayerCreateWithoutDisconnectsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutEntriesInput = {
  create: PlayerCreateWithoutEntriesInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutFragsAsKillerInput = {
  create: PlayerCreateWithoutFragsAsKillerInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutFragsAsVictimInput = {
  create: PlayerCreateWithoutFragsAsVictimInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutGameDataInput = {
  create: PlayerCreateWithoutGameDataInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutHistoryInput = {
  create: PlayerCreateWithoutHistoryInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutLatencyEventsInput = {
  create: PlayerCreateWithoutLatencyEventsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutNameChangesInput = {
  create: PlayerCreateWithoutNameChangesInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutNamesInput = {
  create: PlayerCreateWithoutNamesInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutPlayerActionsInput = {
  create: PlayerCreateWithoutPlayerActionsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutPlayerPlayerActionsAsActorInput = {
  create: PlayerCreateWithoutPlayerPlayerActionsAsActorInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutPlayerPlayerActionsAsVictimInput = {
  create: PlayerCreateWithoutPlayerPlayerActionsAsVictimInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutRibbonsInput = {
  create: PlayerCreateWithoutRibbonsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutRoleChangesInput = {
  create: PlayerCreateWithoutRoleChangesInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutSuicideEventsInput = {
  create: PlayerCreateWithoutSuicideEventsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutTeamBonusesInput = {
  create: PlayerCreateWithoutTeamBonusesInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutTeamChangesInput = {
  create: PlayerCreateWithoutTeamChangesInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutTeamkillsAsKillerInput = {
  create: PlayerCreateWithoutTeamkillsAsKillerInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutTeamkillsAsVictimInput = {
  create: PlayerCreateWithoutTeamkillsAsVictimInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateOrConnectWithoutUniqueIdsInput = {
  create: PlayerCreateWithoutUniqueIdsInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerCreateWithoutAwardsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutAwardsWonAsDWinnerInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutAwardsWonAsGWinnerInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutChatsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutClanInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutConnectsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutCountryDataInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutDisconnectsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutEntriesInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutFragsAsKillerInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutFragsAsVictimInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutGameDataInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutHistoryInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutLatencyEventsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutNameChangesInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutNamesInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutPlayerActionsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutPlayerPlayerActionsAsActorInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutPlayerPlayerActionsAsVictimInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutRibbonsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutRoleChangesInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutSuicideEventsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutTeamBonusesInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutTeamChangesInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutTeamkillsAsKillerInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutTeamkillsAsVictimInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdCreateNestedManyWithoutPlayerInput>;
};

export type PlayerCreateWithoutUniqueIdsInput = {
  activity?: InputMaybe<Scalars['Int']['input']>;
  awards?: InputMaybe<PlayerAwardCreateNestedManyWithoutPlayerInput>;
  awardsWonAsDWinner?: InputMaybe<AwardCreateNestedManyWithoutDWinnerInput>;
  awardsWonAsGWinner?: InputMaybe<AwardCreateNestedManyWithoutGWinnerInput>;
  blockAvatar?: InputMaybe<Scalars['Int']['input']>;
  chats?: InputMaybe<EventChatCreateNestedManyWithoutPlayerInput>;
  city?: InputMaybe<Scalars['String']['input']>;
  clan?: InputMaybe<ClanCreateNestedOneWithoutPlayersInput>;
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  connects?: InputMaybe<EventConnectCreateNestedManyWithoutPlayerInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryData?: InputMaybe<CountryCreateNestedOneWithoutPlayersInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  disconnects?: InputMaybe<EventDisconnectCreateNestedManyWithoutPlayerInput>;
  displayEvents?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<EventEntryCreateNestedManyWithoutPlayerInput>;
  fragsAsKiller?: InputMaybe<EventFragCreateNestedManyWithoutKillerInput>;
  fragsAsVictim?: InputMaybe<EventFragCreateNestedManyWithoutVictimInput>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gameData: GameCreateNestedOneWithoutPlayersInput;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hideRanking?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<PlayerHistoryCreateNestedManyWithoutPlayerInput>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastAddress?: InputMaybe<Scalars['String']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastSkillChange?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  latencyEvents?: InputMaybe<EventLatencyCreateNestedManyWithoutPlayerInput>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mmrank?: InputMaybe<Scalars['Int']['input']>;
  nameChanges?: InputMaybe<EventChangeNameCreateNestedManyWithoutPlayerInput>;
  names?: InputMaybe<PlayerNameCreateNestedManyWithoutPlayerInput>;
  playerActions?: InputMaybe<EventPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutPlayerInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutVictimInput>;
  ribbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutPlayerInput>;
  roleChanges?: InputMaybe<EventChangeRoleCreateNestedManyWithoutPlayerInput>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  suicideEvents?: InputMaybe<EventSuicideCreateNestedManyWithoutPlayerInput>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamBonuses?: InputMaybe<EventTeamBonusCreateNestedManyWithoutPlayerInput>;
  teamChanges?: InputMaybe<EventChangeTeamCreateNestedManyWithoutPlayerInput>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillCreateNestedManyWithoutKillerInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillCreateNestedManyWithoutVictimInput>;
};

export type PlayerHistory = {
  __typename?: 'PlayerHistory';
  connectionTime: Scalars['Int']['output'];
  deathStreak: Scalars['Int']['output'];
  deaths: Scalars['Int']['output'];
  eventTime: Scalars['DateTime']['output'];
  game: Scalars['String']['output'];
  headshots: Scalars['Int']['output'];
  hits: Scalars['Int']['output'];
  killStreak: Scalars['Int']['output'];
  kills: Scalars['Int']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  shots: Scalars['Int']['output'];
  skill: Scalars['Int']['output'];
  skillChange: Scalars['Int']['output'];
  suicides: Scalars['Int']['output'];
  teamkills: Scalars['Int']['output'];
};

export type PlayerHistoryAvgOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  skillChange?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerHistoryCountOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  skillChange?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerHistoryCreateInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  player: PlayerCreateNestedOneWithoutHistoryInput;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  skillChange?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerHistoryCreateManyInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  playerId: Scalars['Int']['input'];
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  skillChange?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerHistoryCreateManyPlayerInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  skillChange?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerHistoryCreateManyPlayerInputEnvelope = {
  data: Array<PlayerHistoryCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerHistoryCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<PlayerHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerHistoryCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerHistoryCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerHistoryCreateManyPlayerInputEnvelope>;
};

export type PlayerHistoryCreateOrConnectWithoutPlayerInput = {
  create: PlayerHistoryCreateWithoutPlayerInput;
  where: PlayerHistoryWhereUniqueInput;
};

export type PlayerHistoryCreateWithoutPlayerInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deathStreak?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  eventTime: Scalars['DateTime']['input'];
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  killStreak?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  skill?: InputMaybe<Scalars['Int']['input']>;
  skillChange?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  teamkills?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerHistoryEventTime_PlayerId_GameCompoundUniqueInput = {
  eventTime: Scalars['DateTime']['input'];
  game: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
};

export type PlayerHistoryListRelationFilter = {
  every?: InputMaybe<PlayerHistoryWhereInput>;
  none?: InputMaybe<PlayerHistoryWhereInput>;
  some?: InputMaybe<PlayerHistoryWhereInput>;
};

export type PlayerHistoryMaxOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  skillChange?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerHistoryMinOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  skillChange?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerHistoryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum PlayerHistoryOrderByRelevanceFieldEnum {
  Game = 'game'
}

export type PlayerHistoryOrderByRelevanceInput = {
  fields: Array<PlayerHistoryOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type PlayerHistoryOrderByWithAggregationInput = {
  _avg?: InputMaybe<PlayerHistoryAvgOrderByAggregateInput>;
  _count?: InputMaybe<PlayerHistoryCountOrderByAggregateInput>;
  _max?: InputMaybe<PlayerHistoryMaxOrderByAggregateInput>;
  _min?: InputMaybe<PlayerHistoryMinOrderByAggregateInput>;
  _sum?: InputMaybe<PlayerHistorySumOrderByAggregateInput>;
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  skillChange?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerHistoryOrderByWithRelationInput = {
  _relevance?: InputMaybe<PlayerHistoryOrderByRelevanceInput>;
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  eventTime?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  skillChange?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export enum PlayerHistoryScalarFieldEnum {
  ConnectionTime = 'connectionTime',
  DeathStreak = 'deathStreak',
  Deaths = 'deaths',
  EventTime = 'eventTime',
  Game = 'game',
  Headshots = 'headshots',
  Hits = 'hits',
  KillStreak = 'killStreak',
  Kills = 'kills',
  PlayerId = 'playerId',
  Shots = 'shots',
  Skill = 'skill',
  SkillChange = 'skillChange',
  Suicides = 'suicides',
  Teamkills = 'teamkills'
}

export type PlayerHistoryScalarWhereInput = {
  AND?: InputMaybe<Array<PlayerHistoryScalarWhereInput>>;
  NOT?: InputMaybe<Array<PlayerHistoryScalarWhereInput>>;
  OR?: InputMaybe<Array<PlayerHistoryScalarWhereInput>>;
  connectionTime?: InputMaybe<IntFilter>;
  deathStreak?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeFilter>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  hits?: InputMaybe<IntFilter>;
  killStreak?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  playerId?: InputMaybe<IntFilter>;
  shots?: InputMaybe<IntFilter>;
  skill?: InputMaybe<IntFilter>;
  skillChange?: InputMaybe<IntFilter>;
  suicides?: InputMaybe<IntFilter>;
  teamkills?: InputMaybe<IntFilter>;
};

export type PlayerHistoryScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<PlayerHistoryScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<PlayerHistoryScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<PlayerHistoryScalarWhereWithAggregatesInput>>;
  connectionTime?: InputMaybe<IntWithAggregatesFilter>;
  deathStreak?: InputMaybe<IntWithAggregatesFilter>;
  deaths?: InputMaybe<IntWithAggregatesFilter>;
  eventTime?: InputMaybe<DateTimeWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  headshots?: InputMaybe<IntWithAggregatesFilter>;
  hits?: InputMaybe<IntWithAggregatesFilter>;
  killStreak?: InputMaybe<IntWithAggregatesFilter>;
  kills?: InputMaybe<IntWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  shots?: InputMaybe<IntWithAggregatesFilter>;
  skill?: InputMaybe<IntWithAggregatesFilter>;
  skillChange?: InputMaybe<IntWithAggregatesFilter>;
  suicides?: InputMaybe<IntWithAggregatesFilter>;
  teamkills?: InputMaybe<IntWithAggregatesFilter>;
};

export type PlayerHistorySumOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  skillChange?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerHistoryUpdateInput = {
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutHistoryNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  skillChange?: InputMaybe<IntFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PlayerHistoryUpdateManyMutationInput = {
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  skillChange?: InputMaybe<IntFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PlayerHistoryUpdateManyWithWhereWithoutPlayerInput = {
  data: PlayerHistoryUpdateManyMutationInput;
  where: PlayerHistoryScalarWhereInput;
};

export type PlayerHistoryUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<PlayerHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerHistoryCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerHistoryCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerHistoryCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<PlayerHistoryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerHistoryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerHistoryWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerHistoryWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerHistoryUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<PlayerHistoryUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<PlayerHistoryUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type PlayerHistoryUpdateWithWhereUniqueWithoutPlayerInput = {
  data: PlayerHistoryUpdateWithoutPlayerInput;
  where: PlayerHistoryWhereUniqueInput;
};

export type PlayerHistoryUpdateWithoutPlayerInput = {
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  eventTime?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  skillChange?: InputMaybe<IntFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PlayerHistoryUpsertWithWhereUniqueWithoutPlayerInput = {
  create: PlayerHistoryCreateWithoutPlayerInput;
  update: PlayerHistoryUpdateWithoutPlayerInput;
  where: PlayerHistoryWhereUniqueInput;
};

export type PlayerHistoryWhereInput = {
  AND?: InputMaybe<Array<PlayerHistoryWhereInput>>;
  NOT?: InputMaybe<Array<PlayerHistoryWhereInput>>;
  OR?: InputMaybe<Array<PlayerHistoryWhereInput>>;
  connectionTime?: InputMaybe<IntFilter>;
  deathStreak?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeFilter>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  hits?: InputMaybe<IntFilter>;
  killStreak?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  shots?: InputMaybe<IntFilter>;
  skill?: InputMaybe<IntFilter>;
  skillChange?: InputMaybe<IntFilter>;
  suicides?: InputMaybe<IntFilter>;
  teamkills?: InputMaybe<IntFilter>;
};

export type PlayerHistoryWhereUniqueInput = {
  AND?: InputMaybe<Array<PlayerHistoryWhereInput>>;
  NOT?: InputMaybe<Array<PlayerHistoryWhereInput>>;
  OR?: InputMaybe<Array<PlayerHistoryWhereInput>>;
  connectionTime?: InputMaybe<IntFilter>;
  deathStreak?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  eventTime?: InputMaybe<DateTimeFilter>;
  eventTime_playerId_game?: InputMaybe<PlayerHistoryEventTime_PlayerId_GameCompoundUniqueInput>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  hits?: InputMaybe<IntFilter>;
  killStreak?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  shots?: InputMaybe<IntFilter>;
  skill?: InputMaybe<IntFilter>;
  skillChange?: InputMaybe<IntFilter>;
  suicides?: InputMaybe<IntFilter>;
  teamkills?: InputMaybe<IntFilter>;
};

export type PlayerListRelationFilter = {
  every?: InputMaybe<PlayerWhereInput>;
  none?: InputMaybe<PlayerWhereInput>;
  some?: InputMaybe<PlayerWhereInput>;
};

export type PlayerMaxOrderByAggregateInput = {
  activity?: InputMaybe<SortOrder>;
  blockAvatar?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  clanId?: InputMaybe<SortOrder>;
  connectionTime?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  displayEvents?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  flag?: InputMaybe<SortOrder>;
  fullName?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hideRanking?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastAddress?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lastName?: InputMaybe<SortOrder>;
  lastSkillChange?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mmrank?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerMinOrderByAggregateInput = {
  activity?: InputMaybe<SortOrder>;
  blockAvatar?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  clanId?: InputMaybe<SortOrder>;
  connectionTime?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  displayEvents?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  flag?: InputMaybe<SortOrder>;
  fullName?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hideRanking?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastAddress?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lastName?: InputMaybe<SortOrder>;
  lastSkillChange?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mmrank?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerName = {
  __typename?: 'PlayerName';
  connectionTime: Scalars['Int']['output'];
  deaths: Scalars['Int']['output'];
  headshots: Scalars['Int']['output'];
  hits: Scalars['Int']['output'];
  kills: Scalars['Int']['output'];
  lastUse?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  numUses: Scalars['Int']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  shots: Scalars['Int']['output'];
  suicides: Scalars['Int']['output'];
};

export type PlayerNameAvgOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  numUses?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
};

export type PlayerNameCountOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastUse?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  numUses?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
};

export type PlayerNameCreateInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastUse?: InputMaybe<Scalars['DateTime']['input']>;
  name: Scalars['String']['input'];
  numUses?: InputMaybe<Scalars['Int']['input']>;
  player: PlayerCreateNestedOneWithoutNamesInput;
  shots?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerNameCreateManyInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastUse?: InputMaybe<Scalars['DateTime']['input']>;
  name: Scalars['String']['input'];
  numUses?: InputMaybe<Scalars['Int']['input']>;
  playerId: Scalars['Int']['input'];
  shots?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerNameCreateManyPlayerInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastUse?: InputMaybe<Scalars['DateTime']['input']>;
  name: Scalars['String']['input'];
  numUses?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerNameCreateManyPlayerInputEnvelope = {
  data: Array<PlayerNameCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerNameCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<PlayerNameWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerNameCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerNameCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerNameCreateManyPlayerInputEnvelope>;
};

export type PlayerNameCreateOrConnectWithoutPlayerInput = {
  create: PlayerNameCreateWithoutPlayerInput;
  where: PlayerNameWhereUniqueInput;
};

export type PlayerNameCreateWithoutPlayerInput = {
  connectionTime?: InputMaybe<Scalars['Int']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  hits?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastUse?: InputMaybe<Scalars['DateTime']['input']>;
  name: Scalars['String']['input'];
  numUses?: InputMaybe<Scalars['Int']['input']>;
  shots?: InputMaybe<Scalars['Int']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
};

export type PlayerNameListRelationFilter = {
  every?: InputMaybe<PlayerNameWhereInput>;
  none?: InputMaybe<PlayerNameWhereInput>;
  some?: InputMaybe<PlayerNameWhereInput>;
};

export type PlayerNameMaxOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastUse?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  numUses?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
};

export type PlayerNameMinOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastUse?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  numUses?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
};

export type PlayerNameOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum PlayerNameOrderByRelevanceFieldEnum {
  Name = 'name'
}

export type PlayerNameOrderByRelevanceInput = {
  fields: Array<PlayerNameOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type PlayerNameOrderByWithAggregationInput = {
  _avg?: InputMaybe<PlayerNameAvgOrderByAggregateInput>;
  _count?: InputMaybe<PlayerNameCountOrderByAggregateInput>;
  _max?: InputMaybe<PlayerNameMaxOrderByAggregateInput>;
  _min?: InputMaybe<PlayerNameMinOrderByAggregateInput>;
  _sum?: InputMaybe<PlayerNameSumOrderByAggregateInput>;
  connectionTime?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastUse?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  numUses?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
};

export type PlayerNameOrderByWithRelationInput = {
  _relevance?: InputMaybe<PlayerNameOrderByRelevanceInput>;
  connectionTime?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastUse?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  numUses?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
};

export type PlayerNamePlayerIdNameCompoundUniqueInput = {
  name: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
};

export enum PlayerNameScalarFieldEnum {
  ConnectionTime = 'connectionTime',
  Deaths = 'deaths',
  Headshots = 'headshots',
  Hits = 'hits',
  Kills = 'kills',
  LastUse = 'lastUse',
  Name = 'name',
  NumUses = 'numUses',
  PlayerId = 'playerId',
  Shots = 'shots',
  Suicides = 'suicides'
}

export type PlayerNameScalarWhereInput = {
  AND?: InputMaybe<Array<PlayerNameScalarWhereInput>>;
  NOT?: InputMaybe<Array<PlayerNameScalarWhereInput>>;
  OR?: InputMaybe<Array<PlayerNameScalarWhereInput>>;
  connectionTime?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  headshots?: InputMaybe<IntFilter>;
  hits?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastUse?: InputMaybe<DateTimeNullableFilter>;
  name?: InputMaybe<StringFilter>;
  numUses?: InputMaybe<IntFilter>;
  playerId?: InputMaybe<IntFilter>;
  shots?: InputMaybe<IntFilter>;
  suicides?: InputMaybe<IntFilter>;
};

export type PlayerNameScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<PlayerNameScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<PlayerNameScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<PlayerNameScalarWhereWithAggregatesInput>>;
  connectionTime?: InputMaybe<IntWithAggregatesFilter>;
  deaths?: InputMaybe<IntWithAggregatesFilter>;
  headshots?: InputMaybe<IntWithAggregatesFilter>;
  hits?: InputMaybe<IntWithAggregatesFilter>;
  kills?: InputMaybe<IntWithAggregatesFilter>;
  lastUse?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  numUses?: InputMaybe<IntWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  shots?: InputMaybe<IntWithAggregatesFilter>;
  suicides?: InputMaybe<IntWithAggregatesFilter>;
};

export type PlayerNameSumOrderByAggregateInput = {
  connectionTime?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  numUses?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
};

export type PlayerNameUpdateInput = {
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUse?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  numUses?: InputMaybe<IntFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutNamesNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PlayerNameUpdateManyMutationInput = {
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUse?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  numUses?: InputMaybe<IntFieldUpdateOperationsInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PlayerNameUpdateManyWithWhereWithoutPlayerInput = {
  data: PlayerNameUpdateManyMutationInput;
  where: PlayerNameScalarWhereInput;
};

export type PlayerNameUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<PlayerNameWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerNameCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerNameCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerNameCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<PlayerNameWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerNameScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerNameWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerNameWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerNameUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<PlayerNameUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<PlayerNameUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type PlayerNameUpdateWithWhereUniqueWithoutPlayerInput = {
  data: PlayerNameUpdateWithoutPlayerInput;
  where: PlayerNameWhereUniqueInput;
};

export type PlayerNameUpdateWithoutPlayerInput = {
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastUse?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  numUses?: InputMaybe<IntFieldUpdateOperationsInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PlayerNameUpsertWithWhereUniqueWithoutPlayerInput = {
  create: PlayerNameCreateWithoutPlayerInput;
  update: PlayerNameUpdateWithoutPlayerInput;
  where: PlayerNameWhereUniqueInput;
};

export type PlayerNameWhereInput = {
  AND?: InputMaybe<Array<PlayerNameWhereInput>>;
  NOT?: InputMaybe<Array<PlayerNameWhereInput>>;
  OR?: InputMaybe<Array<PlayerNameWhereInput>>;
  connectionTime?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  headshots?: InputMaybe<IntFilter>;
  hits?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastUse?: InputMaybe<DateTimeNullableFilter>;
  name?: InputMaybe<StringFilter>;
  numUses?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  shots?: InputMaybe<IntFilter>;
  suicides?: InputMaybe<IntFilter>;
};

export type PlayerNameWhereUniqueInput = {
  AND?: InputMaybe<Array<PlayerNameWhereInput>>;
  NOT?: InputMaybe<Array<PlayerNameWhereInput>>;
  OR?: InputMaybe<Array<PlayerNameWhereInput>>;
  connectionTime?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  headshots?: InputMaybe<IntFilter>;
  hits?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastUse?: InputMaybe<DateTimeNullableFilter>;
  name?: InputMaybe<StringFilter>;
  numUses?: InputMaybe<IntFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  playerId_name?: InputMaybe<PlayerNamePlayerIdNameCompoundUniqueInput>;
  shots?: InputMaybe<IntFilter>;
  suicides?: InputMaybe<IntFilter>;
};

export type PlayerNullableScalarRelationFilter = {
  is?: InputMaybe<PlayerWhereInput>;
  isNot?: InputMaybe<PlayerWhereInput>;
};

export type PlayerOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum PlayerOrderByRelevanceFieldEnum {
  City = 'city',
  Country = 'country',
  Email = 'email',
  Flag = 'flag',
  FullName = 'fullName',
  Game = 'game',
  LastAddress = 'lastAddress',
  LastName = 'lastName',
  State = 'state'
}

export type PlayerOrderByRelevanceInput = {
  fields: Array<PlayerOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type PlayerOrderByWithAggregationInput = {
  _avg?: InputMaybe<PlayerAvgOrderByAggregateInput>;
  _count?: InputMaybe<PlayerCountOrderByAggregateInput>;
  _max?: InputMaybe<PlayerMaxOrderByAggregateInput>;
  _min?: InputMaybe<PlayerMinOrderByAggregateInput>;
  _sum?: InputMaybe<PlayerSumOrderByAggregateInput>;
  activity?: InputMaybe<SortOrder>;
  blockAvatar?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  clanId?: InputMaybe<SortOrder>;
  connectionTime?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  displayEvents?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  flag?: InputMaybe<SortOrder>;
  fullName?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hideRanking?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastAddress?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lastName?: InputMaybe<SortOrder>;
  lastSkillChange?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mmrank?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerOrderByWithRelationInput = {
  _relevance?: InputMaybe<PlayerOrderByRelevanceInput>;
  activity?: InputMaybe<SortOrder>;
  awards?: InputMaybe<PlayerAwardOrderByRelationAggregateInput>;
  awardsWonAsDWinner?: InputMaybe<AwardOrderByRelationAggregateInput>;
  awardsWonAsGWinner?: InputMaybe<AwardOrderByRelationAggregateInput>;
  blockAvatar?: InputMaybe<SortOrder>;
  chats?: InputMaybe<EventChatOrderByRelationAggregateInput>;
  city?: InputMaybe<SortOrder>;
  clan?: InputMaybe<ClanOrderByWithRelationInput>;
  clanId?: InputMaybe<SortOrder>;
  connectionTime?: InputMaybe<SortOrder>;
  connects?: InputMaybe<EventConnectOrderByRelationAggregateInput>;
  country?: InputMaybe<SortOrder>;
  countryData?: InputMaybe<CountryOrderByWithRelationInput>;
  createdAt?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  disconnects?: InputMaybe<EventDisconnectOrderByRelationAggregateInput>;
  displayEvents?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  entries?: InputMaybe<EventEntryOrderByRelationAggregateInput>;
  flag?: InputMaybe<SortOrder>;
  fragsAsKiller?: InputMaybe<EventFragOrderByRelationAggregateInput>;
  fragsAsVictim?: InputMaybe<EventFragOrderByRelationAggregateInput>;
  fullName?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  gameData?: InputMaybe<GameOrderByWithRelationInput>;
  headshots?: InputMaybe<SortOrder>;
  hideRanking?: InputMaybe<SortOrder>;
  history?: InputMaybe<PlayerHistoryOrderByRelationAggregateInput>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastAddress?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lastName?: InputMaybe<SortOrder>;
  lastSkillChange?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  latencyEvents?: InputMaybe<EventLatencyOrderByRelationAggregateInput>;
  lng?: InputMaybe<SortOrder>;
  mmrank?: InputMaybe<SortOrder>;
  nameChanges?: InputMaybe<EventChangeNameOrderByRelationAggregateInput>;
  names?: InputMaybe<PlayerNameOrderByRelationAggregateInput>;
  playerActions?: InputMaybe<EventPlayerActionOrderByRelationAggregateInput>;
  playerId?: InputMaybe<SortOrder>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionOrderByRelationAggregateInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionOrderByRelationAggregateInput>;
  ribbons?: InputMaybe<PlayerRibbonOrderByRelationAggregateInput>;
  roleChanges?: InputMaybe<EventChangeRoleOrderByRelationAggregateInput>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  state?: InputMaybe<SortOrder>;
  suicideEvents?: InputMaybe<EventSuicideOrderByRelationAggregateInput>;
  suicides?: InputMaybe<SortOrder>;
  teamBonuses?: InputMaybe<EventTeamBonusOrderByRelationAggregateInput>;
  teamChanges?: InputMaybe<EventChangeTeamOrderByRelationAggregateInput>;
  teamkills?: InputMaybe<SortOrder>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillOrderByRelationAggregateInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillOrderByRelationAggregateInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdOrderByRelationAggregateInput>;
};

export type PlayerRibbon = {
  __typename?: 'PlayerRibbon';
  game: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['Int']['output'];
  ribbon: Ribbon;
  ribbonId: Scalars['Int']['output'];
};

export type PlayerRibbonAvgOrderByAggregateInput = {
  playerId?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
};

export type PlayerRibbonCountOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
};

export type PlayerRibbonCreateInput = {
  game: Scalars['String']['input'];
  player: PlayerCreateNestedOneWithoutRibbonsInput;
  ribbon: RibbonCreateNestedOneWithoutPlayerRibbonsInput;
};

export type PlayerRibbonCreateManyInput = {
  game: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
  ribbonId: Scalars['Int']['input'];
};

export type PlayerRibbonCreateManyPlayerInput = {
  game: Scalars['String']['input'];
  ribbonId: Scalars['Int']['input'];
};

export type PlayerRibbonCreateManyPlayerInputEnvelope = {
  data: Array<PlayerRibbonCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerRibbonCreateManyRibbonInput = {
  game: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
};

export type PlayerRibbonCreateManyRibbonInputEnvelope = {
  data: Array<PlayerRibbonCreateManyRibbonInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerRibbonCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerRibbonCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerRibbonCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerRibbonCreateManyPlayerInputEnvelope>;
};

export type PlayerRibbonCreateNestedManyWithoutRibbonInput = {
  connect?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerRibbonCreateOrConnectWithoutRibbonInput>>;
  create?: InputMaybe<Array<PlayerRibbonCreateWithoutRibbonInput>>;
  createMany?: InputMaybe<PlayerRibbonCreateManyRibbonInputEnvelope>;
};

export type PlayerRibbonCreateOrConnectWithoutPlayerInput = {
  create: PlayerRibbonCreateWithoutPlayerInput;
  where: PlayerRibbonWhereUniqueInput;
};

export type PlayerRibbonCreateOrConnectWithoutRibbonInput = {
  create: PlayerRibbonCreateWithoutRibbonInput;
  where: PlayerRibbonWhereUniqueInput;
};

export type PlayerRibbonCreateWithoutPlayerInput = {
  game: Scalars['String']['input'];
  ribbon: RibbonCreateNestedOneWithoutPlayerRibbonsInput;
};

export type PlayerRibbonCreateWithoutRibbonInput = {
  game: Scalars['String']['input'];
  player: PlayerCreateNestedOneWithoutRibbonsInput;
};

export type PlayerRibbonListRelationFilter = {
  every?: InputMaybe<PlayerRibbonWhereInput>;
  none?: InputMaybe<PlayerRibbonWhereInput>;
  some?: InputMaybe<PlayerRibbonWhereInput>;
};

export type PlayerRibbonMaxOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
};

export type PlayerRibbonMinOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
};

export type PlayerRibbonOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum PlayerRibbonOrderByRelevanceFieldEnum {
  Game = 'game'
}

export type PlayerRibbonOrderByRelevanceInput = {
  fields: Array<PlayerRibbonOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type PlayerRibbonOrderByWithAggregationInput = {
  _avg?: InputMaybe<PlayerRibbonAvgOrderByAggregateInput>;
  _count?: InputMaybe<PlayerRibbonCountOrderByAggregateInput>;
  _max?: InputMaybe<PlayerRibbonMaxOrderByAggregateInput>;
  _min?: InputMaybe<PlayerRibbonMinOrderByAggregateInput>;
  _sum?: InputMaybe<PlayerRibbonSumOrderByAggregateInput>;
  game?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
};

export type PlayerRibbonOrderByWithRelationInput = {
  _relevance?: InputMaybe<PlayerRibbonOrderByRelevanceInput>;
  game?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  ribbon?: InputMaybe<RibbonOrderByWithRelationInput>;
  ribbonId?: InputMaybe<SortOrder>;
};

export type PlayerRibbonPlayerIdRibbonIdGameCompoundUniqueInput = {
  game: Scalars['String']['input'];
  playerId: Scalars['Int']['input'];
  ribbonId: Scalars['Int']['input'];
};

export enum PlayerRibbonScalarFieldEnum {
  Game = 'game',
  PlayerId = 'playerId',
  RibbonId = 'ribbonId'
}

export type PlayerRibbonScalarWhereInput = {
  AND?: InputMaybe<Array<PlayerRibbonScalarWhereInput>>;
  NOT?: InputMaybe<Array<PlayerRibbonScalarWhereInput>>;
  OR?: InputMaybe<Array<PlayerRibbonScalarWhereInput>>;
  game?: InputMaybe<StringFilter>;
  playerId?: InputMaybe<IntFilter>;
  ribbonId?: InputMaybe<IntFilter>;
};

export type PlayerRibbonScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<PlayerRibbonScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<PlayerRibbonScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<PlayerRibbonScalarWhereWithAggregatesInput>>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  ribbonId?: InputMaybe<IntWithAggregatesFilter>;
};

export type PlayerRibbonSumOrderByAggregateInput = {
  playerId?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
};

export type PlayerRibbonUpdateInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutRibbonsNestedInput>;
  ribbon?: InputMaybe<RibbonUpdateOneRequiredWithoutPlayerRibbonsNestedInput>;
};

export type PlayerRibbonUpdateManyMutationInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PlayerRibbonUpdateManyWithWhereWithoutPlayerInput = {
  data: PlayerRibbonUpdateManyMutationInput;
  where: PlayerRibbonScalarWhereInput;
};

export type PlayerRibbonUpdateManyWithWhereWithoutRibbonInput = {
  data: PlayerRibbonUpdateManyMutationInput;
  where: PlayerRibbonScalarWhereInput;
};

export type PlayerRibbonUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerRibbonCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerRibbonCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerRibbonCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerRibbonScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerRibbonUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<PlayerRibbonUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<PlayerRibbonUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type PlayerRibbonUpdateManyWithoutRibbonNestedInput = {
  connect?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerRibbonCreateOrConnectWithoutRibbonInput>>;
  create?: InputMaybe<Array<PlayerRibbonCreateWithoutRibbonInput>>;
  createMany?: InputMaybe<PlayerRibbonCreateManyRibbonInputEnvelope>;
  delete?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerRibbonScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerRibbonWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerRibbonUpdateWithWhereUniqueWithoutRibbonInput>>;
  updateMany?: InputMaybe<Array<PlayerRibbonUpdateManyWithWhereWithoutRibbonInput>>;
  upsert?: InputMaybe<Array<PlayerRibbonUpsertWithWhereUniqueWithoutRibbonInput>>;
};

export type PlayerRibbonUpdateWithWhereUniqueWithoutPlayerInput = {
  data: PlayerRibbonUpdateWithoutPlayerInput;
  where: PlayerRibbonWhereUniqueInput;
};

export type PlayerRibbonUpdateWithWhereUniqueWithoutRibbonInput = {
  data: PlayerRibbonUpdateWithoutRibbonInput;
  where: PlayerRibbonWhereUniqueInput;
};

export type PlayerRibbonUpdateWithoutPlayerInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  ribbon?: InputMaybe<RibbonUpdateOneRequiredWithoutPlayerRibbonsNestedInput>;
};

export type PlayerRibbonUpdateWithoutRibbonInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutRibbonsNestedInput>;
};

export type PlayerRibbonUpsertWithWhereUniqueWithoutPlayerInput = {
  create: PlayerRibbonCreateWithoutPlayerInput;
  update: PlayerRibbonUpdateWithoutPlayerInput;
  where: PlayerRibbonWhereUniqueInput;
};

export type PlayerRibbonUpsertWithWhereUniqueWithoutRibbonInput = {
  create: PlayerRibbonCreateWithoutRibbonInput;
  update: PlayerRibbonUpdateWithoutRibbonInput;
  where: PlayerRibbonWhereUniqueInput;
};

export type PlayerRibbonWhereInput = {
  AND?: InputMaybe<Array<PlayerRibbonWhereInput>>;
  NOT?: InputMaybe<Array<PlayerRibbonWhereInput>>;
  OR?: InputMaybe<Array<PlayerRibbonWhereInput>>;
  game?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  ribbon?: InputMaybe<RibbonWhereInput>;
  ribbonId?: InputMaybe<IntFilter>;
};

export type PlayerRibbonWhereUniqueInput = {
  AND?: InputMaybe<Array<PlayerRibbonWhereInput>>;
  NOT?: InputMaybe<Array<PlayerRibbonWhereInput>>;
  OR?: InputMaybe<Array<PlayerRibbonWhereInput>>;
  game?: InputMaybe<StringFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  playerId_ribbonId_game?: InputMaybe<PlayerRibbonPlayerIdRibbonIdGameCompoundUniqueInput>;
  ribbon?: InputMaybe<RibbonWhereInput>;
  ribbonId?: InputMaybe<IntFilter>;
};

export enum PlayerScalarFieldEnum {
  Activity = 'activity',
  BlockAvatar = 'blockAvatar',
  City = 'city',
  ClanId = 'clanId',
  ConnectionTime = 'connectionTime',
  Country = 'country',
  CreatedAt = 'createdAt',
  DeathStreak = 'deathStreak',
  Deaths = 'deaths',
  DisplayEvents = 'displayEvents',
  Email = 'email',
  Flag = 'flag',
  FullName = 'fullName',
  Game = 'game',
  Headshots = 'headshots',
  HideRanking = 'hideRanking',
  Hits = 'hits',
  KillStreak = 'killStreak',
  Kills = 'kills',
  LastAddress = 'lastAddress',
  LastEvent = 'lastEvent',
  LastName = 'lastName',
  LastSkillChange = 'lastSkillChange',
  Lat = 'lat',
  Lng = 'lng',
  Mmrank = 'mmrank',
  PlayerId = 'playerId',
  Shots = 'shots',
  Skill = 'skill',
  State = 'state',
  Suicides = 'suicides',
  Teamkills = 'teamkills'
}

export type PlayerScalarRelationFilter = {
  is?: InputMaybe<PlayerWhereInput>;
  isNot?: InputMaybe<PlayerWhereInput>;
};

export type PlayerScalarWhereInput = {
  AND?: InputMaybe<Array<PlayerScalarWhereInput>>;
  NOT?: InputMaybe<Array<PlayerScalarWhereInput>>;
  OR?: InputMaybe<Array<PlayerScalarWhereInput>>;
  activity?: InputMaybe<IntFilter>;
  blockAvatar?: InputMaybe<IntFilter>;
  city?: InputMaybe<StringFilter>;
  clanId?: InputMaybe<IntNullableFilter>;
  connectionTime?: InputMaybe<IntFilter>;
  country?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  deathStreak?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  displayEvents?: InputMaybe<IntFilter>;
  email?: InputMaybe<StringNullableFilter>;
  flag?: InputMaybe<StringNullableFilter>;
  fullName?: InputMaybe<StringNullableFilter>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  hideRanking?: InputMaybe<IntFilter>;
  hits?: InputMaybe<IntFilter>;
  killStreak?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastAddress?: InputMaybe<StringFilter>;
  lastEvent?: InputMaybe<DateTimeNullableFilter>;
  lastName?: InputMaybe<StringFilter>;
  lastSkillChange?: InputMaybe<DateTimeNullableFilter>;
  lat?: InputMaybe<FloatNullableFilter>;
  lng?: InputMaybe<FloatNullableFilter>;
  mmrank?: InputMaybe<IntNullableFilter>;
  playerId?: InputMaybe<IntFilter>;
  shots?: InputMaybe<IntFilter>;
  skill?: InputMaybe<IntFilter>;
  state?: InputMaybe<StringFilter>;
  suicides?: InputMaybe<IntFilter>;
  teamkills?: InputMaybe<IntFilter>;
};

export type PlayerScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<PlayerScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<PlayerScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<PlayerScalarWhereWithAggregatesInput>>;
  activity?: InputMaybe<IntWithAggregatesFilter>;
  blockAvatar?: InputMaybe<IntWithAggregatesFilter>;
  city?: InputMaybe<StringWithAggregatesFilter>;
  clanId?: InputMaybe<IntNullableWithAggregatesFilter>;
  connectionTime?: InputMaybe<IntWithAggregatesFilter>;
  country?: InputMaybe<StringWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  deathStreak?: InputMaybe<IntWithAggregatesFilter>;
  deaths?: InputMaybe<IntWithAggregatesFilter>;
  displayEvents?: InputMaybe<IntWithAggregatesFilter>;
  email?: InputMaybe<StringNullableWithAggregatesFilter>;
  flag?: InputMaybe<StringNullableWithAggregatesFilter>;
  fullName?: InputMaybe<StringNullableWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  headshots?: InputMaybe<IntWithAggregatesFilter>;
  hideRanking?: InputMaybe<IntWithAggregatesFilter>;
  hits?: InputMaybe<IntWithAggregatesFilter>;
  killStreak?: InputMaybe<IntWithAggregatesFilter>;
  kills?: InputMaybe<IntWithAggregatesFilter>;
  lastAddress?: InputMaybe<StringWithAggregatesFilter>;
  lastEvent?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  lastName?: InputMaybe<StringWithAggregatesFilter>;
  lastSkillChange?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  lat?: InputMaybe<FloatNullableWithAggregatesFilter>;
  lng?: InputMaybe<FloatNullableWithAggregatesFilter>;
  mmrank?: InputMaybe<IntNullableWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  shots?: InputMaybe<IntWithAggregatesFilter>;
  skill?: InputMaybe<IntWithAggregatesFilter>;
  state?: InputMaybe<StringWithAggregatesFilter>;
  suicides?: InputMaybe<IntWithAggregatesFilter>;
  teamkills?: InputMaybe<IntWithAggregatesFilter>;
};

export type PlayerServerStats = {
  __typename?: 'PlayerServerStats';
  accuracyPercentage?: Maybe<Scalars['Float']['output']>;
  activity?: Maybe<Scalars['Int']['output']>;
  connectionTime?: Maybe<Scalars['Int']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  deaths?: Maybe<Scalars['Int']['output']>;
  favoriteServer?: Maybe<Scalars['Boolean']['output']>;
  flag?: Maybe<Scalars['String']['output']>;
  headshotRatio?: Maybe<Scalars['Float']['output']>;
  headshots?: Maybe<Scalars['Int']['output']>;
  isOnline?: Maybe<Scalars['Boolean']['output']>;
  kdRatio?: Maybe<Scalars['Float']['output']>;
  kills?: Maybe<Scalars['Int']['output']>;
  lastEvent?: Maybe<Scalars['DateTime']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  lastSkillChange?: Maybe<Scalars['DateTime']['output']>;
  playerId?: Maybe<Scalars['Int']['output']>;
  rank?: Maybe<Scalars['String']['output']>;
  sessionDuration?: Maybe<Scalars['Int']['output']>;
  skill?: Maybe<Scalars['Int']['output']>;
  suicides?: Maybe<Scalars['Int']['output']>;
  totalSessions?: Maybe<Scalars['Int']['output']>;
};

export type PlayerSumOrderByAggregateInput = {
  activity?: InputMaybe<SortOrder>;
  blockAvatar?: InputMaybe<SortOrder>;
  clanId?: InputMaybe<SortOrder>;
  connectionTime?: InputMaybe<SortOrder>;
  deathStreak?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  displayEvents?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  hideRanking?: InputMaybe<SortOrder>;
  hits?: InputMaybe<SortOrder>;
  killStreak?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mmrank?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  shots?: InputMaybe<SortOrder>;
  skill?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  teamkills?: InputMaybe<SortOrder>;
};

export type PlayerUniqueId = {
  __typename?: 'PlayerUniqueId';
  game: Scalars['String']['output'];
  merge?: Maybe<Scalars['Int']['output']>;
  player: Player;
  playerId: Scalars['Int']['output'];
  uniqueId: Scalars['String']['output'];
};

export type PlayerUniqueIdAvgOrderByAggregateInput = {
  merge?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerUniqueIdCountOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  merge?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  uniqueId?: InputMaybe<SortOrder>;
};

export type PlayerUniqueIdCreateInput = {
  game?: InputMaybe<Scalars['String']['input']>;
  merge?: InputMaybe<Scalars['Int']['input']>;
  player: PlayerCreateNestedOneWithoutUniqueIdsInput;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

export type PlayerUniqueIdCreateManyInput = {
  game?: InputMaybe<Scalars['String']['input']>;
  merge?: InputMaybe<Scalars['Int']['input']>;
  playerId: Scalars['Int']['input'];
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

export type PlayerUniqueIdCreateManyPlayerInput = {
  game?: InputMaybe<Scalars['String']['input']>;
  merge?: InputMaybe<Scalars['Int']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

export type PlayerUniqueIdCreateManyPlayerInputEnvelope = {
  data: Array<PlayerUniqueIdCreateManyPlayerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PlayerUniqueIdCreateNestedManyWithoutPlayerInput = {
  connect?: InputMaybe<Array<PlayerUniqueIdWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerUniqueIdCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerUniqueIdCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerUniqueIdCreateManyPlayerInputEnvelope>;
};

export type PlayerUniqueIdCreateOrConnectWithoutPlayerInput = {
  create: PlayerUniqueIdCreateWithoutPlayerInput;
  where: PlayerUniqueIdWhereUniqueInput;
};

export type PlayerUniqueIdCreateWithoutPlayerInput = {
  game?: InputMaybe<Scalars['String']['input']>;
  merge?: InputMaybe<Scalars['Int']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

export type PlayerUniqueIdListRelationFilter = {
  every?: InputMaybe<PlayerUniqueIdWhereInput>;
  none?: InputMaybe<PlayerUniqueIdWhereInput>;
  some?: InputMaybe<PlayerUniqueIdWhereInput>;
};

export type PlayerUniqueIdMaxOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  merge?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  uniqueId?: InputMaybe<SortOrder>;
};

export type PlayerUniqueIdMinOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  merge?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  uniqueId?: InputMaybe<SortOrder>;
};

export type PlayerUniqueIdOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum PlayerUniqueIdOrderByRelevanceFieldEnum {
  Game = 'game',
  UniqueId = 'uniqueId'
}

export type PlayerUniqueIdOrderByRelevanceInput = {
  fields: Array<PlayerUniqueIdOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type PlayerUniqueIdOrderByWithAggregationInput = {
  _avg?: InputMaybe<PlayerUniqueIdAvgOrderByAggregateInput>;
  _count?: InputMaybe<PlayerUniqueIdCountOrderByAggregateInput>;
  _max?: InputMaybe<PlayerUniqueIdMaxOrderByAggregateInput>;
  _min?: InputMaybe<PlayerUniqueIdMinOrderByAggregateInput>;
  _sum?: InputMaybe<PlayerUniqueIdSumOrderByAggregateInput>;
  game?: InputMaybe<SortOrder>;
  merge?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
  uniqueId?: InputMaybe<SortOrder>;
};

export type PlayerUniqueIdOrderByWithRelationInput = {
  _relevance?: InputMaybe<PlayerUniqueIdOrderByRelevanceInput>;
  game?: InputMaybe<SortOrder>;
  merge?: InputMaybe<SortOrder>;
  player?: InputMaybe<PlayerOrderByWithRelationInput>;
  playerId?: InputMaybe<SortOrder>;
  uniqueId?: InputMaybe<SortOrder>;
};

export enum PlayerUniqueIdScalarFieldEnum {
  Game = 'game',
  Merge = 'merge',
  PlayerId = 'playerId',
  UniqueId = 'uniqueId'
}

export type PlayerUniqueIdScalarWhereInput = {
  AND?: InputMaybe<Array<PlayerUniqueIdScalarWhereInput>>;
  NOT?: InputMaybe<Array<PlayerUniqueIdScalarWhereInput>>;
  OR?: InputMaybe<Array<PlayerUniqueIdScalarWhereInput>>;
  game?: InputMaybe<StringFilter>;
  merge?: InputMaybe<IntNullableFilter>;
  playerId?: InputMaybe<IntFilter>;
  uniqueId?: InputMaybe<StringFilter>;
};

export type PlayerUniqueIdScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<PlayerUniqueIdScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<PlayerUniqueIdScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<PlayerUniqueIdScalarWhereWithAggregatesInput>>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  merge?: InputMaybe<IntNullableWithAggregatesFilter>;
  playerId?: InputMaybe<IntWithAggregatesFilter>;
  uniqueId?: InputMaybe<StringWithAggregatesFilter>;
};

export type PlayerUniqueIdSumOrderByAggregateInput = {
  merge?: InputMaybe<SortOrder>;
  playerId?: InputMaybe<SortOrder>;
};

export type PlayerUniqueIdUniqueIdGameCompoundUniqueInput = {
  game: Scalars['String']['input'];
  uniqueId: Scalars['String']['input'];
};

export type PlayerUniqueIdUpdateInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  merge?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  player?: InputMaybe<PlayerUpdateOneRequiredWithoutUniqueIdsNestedInput>;
  uniqueId?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PlayerUniqueIdUpdateManyMutationInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  merge?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  uniqueId?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PlayerUniqueIdUpdateManyWithWhereWithoutPlayerInput = {
  data: PlayerUniqueIdUpdateManyMutationInput;
  where: PlayerUniqueIdScalarWhereInput;
};

export type PlayerUniqueIdUpdateManyWithoutPlayerNestedInput = {
  connect?: InputMaybe<Array<PlayerUniqueIdWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerUniqueIdCreateOrConnectWithoutPlayerInput>>;
  create?: InputMaybe<Array<PlayerUniqueIdCreateWithoutPlayerInput>>;
  createMany?: InputMaybe<PlayerUniqueIdCreateManyPlayerInputEnvelope>;
  delete?: InputMaybe<Array<PlayerUniqueIdWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerUniqueIdScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerUniqueIdWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerUniqueIdWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerUniqueIdUpdateWithWhereUniqueWithoutPlayerInput>>;
  updateMany?: InputMaybe<Array<PlayerUniqueIdUpdateManyWithWhereWithoutPlayerInput>>;
  upsert?: InputMaybe<Array<PlayerUniqueIdUpsertWithWhereUniqueWithoutPlayerInput>>;
};

export type PlayerUniqueIdUpdateWithWhereUniqueWithoutPlayerInput = {
  data: PlayerUniqueIdUpdateWithoutPlayerInput;
  where: PlayerUniqueIdWhereUniqueInput;
};

export type PlayerUniqueIdUpdateWithoutPlayerInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  merge?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  uniqueId?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PlayerUniqueIdUpsertWithWhereUniqueWithoutPlayerInput = {
  create: PlayerUniqueIdCreateWithoutPlayerInput;
  update: PlayerUniqueIdUpdateWithoutPlayerInput;
  where: PlayerUniqueIdWhereUniqueInput;
};

export type PlayerUniqueIdWhereInput = {
  AND?: InputMaybe<Array<PlayerUniqueIdWhereInput>>;
  NOT?: InputMaybe<Array<PlayerUniqueIdWhereInput>>;
  OR?: InputMaybe<Array<PlayerUniqueIdWhereInput>>;
  game?: InputMaybe<StringFilter>;
  merge?: InputMaybe<IntNullableFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  uniqueId?: InputMaybe<StringFilter>;
};

export type PlayerUniqueIdWhereUniqueInput = {
  AND?: InputMaybe<Array<PlayerUniqueIdWhereInput>>;
  NOT?: InputMaybe<Array<PlayerUniqueIdWhereInput>>;
  OR?: InputMaybe<Array<PlayerUniqueIdWhereInput>>;
  game?: InputMaybe<StringFilter>;
  merge?: InputMaybe<IntNullableFilter>;
  player?: InputMaybe<PlayerWhereInput>;
  playerId?: InputMaybe<IntFilter>;
  uniqueId?: InputMaybe<StringFilter>;
  uniqueId_game?: InputMaybe<PlayerUniqueIdUniqueIdGameCompoundUniqueInput>;
};

export type PlayerUpdateInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateManyMutationInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PlayerUpdateManyWithWhereWithoutClanInput = {
  data: PlayerUpdateManyMutationInput;
  where: PlayerScalarWhereInput;
};

export type PlayerUpdateManyWithWhereWithoutCountryDataInput = {
  data: PlayerUpdateManyMutationInput;
  where: PlayerScalarWhereInput;
};

export type PlayerUpdateManyWithWhereWithoutGameDataInput = {
  data: PlayerUpdateManyMutationInput;
  where: PlayerScalarWhereInput;
};

export type PlayerUpdateManyWithoutClanNestedInput = {
  connect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerCreateOrConnectWithoutClanInput>>;
  create?: InputMaybe<Array<PlayerCreateWithoutClanInput>>;
  createMany?: InputMaybe<PlayerCreateManyClanInputEnvelope>;
  delete?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerUpdateWithWhereUniqueWithoutClanInput>>;
  updateMany?: InputMaybe<Array<PlayerUpdateManyWithWhereWithoutClanInput>>;
  upsert?: InputMaybe<Array<PlayerUpsertWithWhereUniqueWithoutClanInput>>;
};

export type PlayerUpdateManyWithoutCountryDataNestedInput = {
  connect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerCreateOrConnectWithoutCountryDataInput>>;
  create?: InputMaybe<Array<PlayerCreateWithoutCountryDataInput>>;
  createMany?: InputMaybe<PlayerCreateManyCountryDataInputEnvelope>;
  delete?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerUpdateWithWhereUniqueWithoutCountryDataInput>>;
  updateMany?: InputMaybe<Array<PlayerUpdateManyWithWhereWithoutCountryDataInput>>;
  upsert?: InputMaybe<Array<PlayerUpsertWithWhereUniqueWithoutCountryDataInput>>;
};

export type PlayerUpdateManyWithoutGameDataNestedInput = {
  connect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PlayerCreateOrConnectWithoutGameDataInput>>;
  create?: InputMaybe<Array<PlayerCreateWithoutGameDataInput>>;
  createMany?: InputMaybe<PlayerCreateManyGameDataInputEnvelope>;
  delete?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PlayerScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  set?: InputMaybe<Array<PlayerWhereUniqueInput>>;
  update?: InputMaybe<Array<PlayerUpdateWithWhereUniqueWithoutGameDataInput>>;
  updateMany?: InputMaybe<Array<PlayerUpdateManyWithWhereWithoutGameDataInput>>;
  upsert?: InputMaybe<Array<PlayerUpsertWithWhereUniqueWithoutGameDataInput>>;
};

export type PlayerUpdateOneRequiredWithoutAwardsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutAwardsInput>;
  create?: InputMaybe<PlayerCreateWithoutAwardsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutAwardsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutAwardsInput>;
};

export type PlayerUpdateOneRequiredWithoutChatsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutChatsInput>;
  create?: InputMaybe<PlayerCreateWithoutChatsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutChatsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutChatsInput>;
};

export type PlayerUpdateOneRequiredWithoutConnectsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutConnectsInput>;
  create?: InputMaybe<PlayerCreateWithoutConnectsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutConnectsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutConnectsInput>;
};

export type PlayerUpdateOneRequiredWithoutDisconnectsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutDisconnectsInput>;
  create?: InputMaybe<PlayerCreateWithoutDisconnectsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutDisconnectsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutDisconnectsInput>;
};

export type PlayerUpdateOneRequiredWithoutEntriesNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutEntriesInput>;
  create?: InputMaybe<PlayerCreateWithoutEntriesInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutEntriesInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutEntriesInput>;
};

export type PlayerUpdateOneRequiredWithoutFragsAsKillerNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutFragsAsKillerInput>;
  create?: InputMaybe<PlayerCreateWithoutFragsAsKillerInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutFragsAsKillerInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutFragsAsKillerInput>;
};

export type PlayerUpdateOneRequiredWithoutFragsAsVictimNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutFragsAsVictimInput>;
  create?: InputMaybe<PlayerCreateWithoutFragsAsVictimInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutFragsAsVictimInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutFragsAsVictimInput>;
};

export type PlayerUpdateOneRequiredWithoutHistoryNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutHistoryInput>;
  create?: InputMaybe<PlayerCreateWithoutHistoryInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutHistoryInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutHistoryInput>;
};

export type PlayerUpdateOneRequiredWithoutLatencyEventsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutLatencyEventsInput>;
  create?: InputMaybe<PlayerCreateWithoutLatencyEventsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutLatencyEventsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutLatencyEventsInput>;
};

export type PlayerUpdateOneRequiredWithoutNameChangesNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutNameChangesInput>;
  create?: InputMaybe<PlayerCreateWithoutNameChangesInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutNameChangesInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutNameChangesInput>;
};

export type PlayerUpdateOneRequiredWithoutNamesNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutNamesInput>;
  create?: InputMaybe<PlayerCreateWithoutNamesInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutNamesInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutNamesInput>;
};

export type PlayerUpdateOneRequiredWithoutPlayerActionsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutPlayerActionsInput>;
  create?: InputMaybe<PlayerCreateWithoutPlayerActionsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutPlayerActionsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutPlayerActionsInput>;
};

export type PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsActorNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutPlayerPlayerActionsAsActorInput>;
  create?: InputMaybe<PlayerCreateWithoutPlayerPlayerActionsAsActorInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutPlayerPlayerActionsAsActorInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutPlayerPlayerActionsAsActorInput>;
};

export type PlayerUpdateOneRequiredWithoutPlayerPlayerActionsAsVictimNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutPlayerPlayerActionsAsVictimInput>;
  create?: InputMaybe<PlayerCreateWithoutPlayerPlayerActionsAsVictimInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutPlayerPlayerActionsAsVictimInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutPlayerPlayerActionsAsVictimInput>;
};

export type PlayerUpdateOneRequiredWithoutRibbonsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutRibbonsInput>;
  create?: InputMaybe<PlayerCreateWithoutRibbonsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutRibbonsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutRibbonsInput>;
};

export type PlayerUpdateOneRequiredWithoutRoleChangesNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutRoleChangesInput>;
  create?: InputMaybe<PlayerCreateWithoutRoleChangesInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutRoleChangesInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutRoleChangesInput>;
};

export type PlayerUpdateOneRequiredWithoutSuicideEventsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutSuicideEventsInput>;
  create?: InputMaybe<PlayerCreateWithoutSuicideEventsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutSuicideEventsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutSuicideEventsInput>;
};

export type PlayerUpdateOneRequiredWithoutTeamBonusesNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamBonusesInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamBonusesInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutTeamBonusesInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutTeamBonusesInput>;
};

export type PlayerUpdateOneRequiredWithoutTeamChangesNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamChangesInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamChangesInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutTeamChangesInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutTeamChangesInput>;
};

export type PlayerUpdateOneRequiredWithoutTeamkillsAsKillerNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamkillsAsKillerInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamkillsAsKillerInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutTeamkillsAsKillerInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutTeamkillsAsKillerInput>;
};

export type PlayerUpdateOneRequiredWithoutTeamkillsAsVictimNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutTeamkillsAsVictimInput>;
  create?: InputMaybe<PlayerCreateWithoutTeamkillsAsVictimInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutTeamkillsAsVictimInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutTeamkillsAsVictimInput>;
};

export type PlayerUpdateOneRequiredWithoutUniqueIdsNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutUniqueIdsInput>;
  create?: InputMaybe<PlayerCreateWithoutUniqueIdsInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutUniqueIdsInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutUniqueIdsInput>;
};

export type PlayerUpdateOneWithoutAwardsWonAsDWinnerNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutAwardsWonAsDWinnerInput>;
  create?: InputMaybe<PlayerCreateWithoutAwardsWonAsDWinnerInput>;
  delete?: InputMaybe<PlayerWhereInput>;
  disconnect?: InputMaybe<PlayerWhereInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutAwardsWonAsDWinnerInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutAwardsWonAsDWinnerInput>;
};

export type PlayerUpdateOneWithoutAwardsWonAsGWinnerNestedInput = {
  connect?: InputMaybe<PlayerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlayerCreateOrConnectWithoutAwardsWonAsGWinnerInput>;
  create?: InputMaybe<PlayerCreateWithoutAwardsWonAsGWinnerInput>;
  delete?: InputMaybe<PlayerWhereInput>;
  disconnect?: InputMaybe<PlayerWhereInput>;
  update?: InputMaybe<PlayerUpdateToOneWithWhereWithoutAwardsWonAsGWinnerInput>;
  upsert?: InputMaybe<PlayerUpsertWithoutAwardsWonAsGWinnerInput>;
};

export type PlayerUpdateToOneWithWhereWithoutAwardsInput = {
  data: PlayerUpdateWithoutAwardsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutAwardsWonAsDWinnerInput = {
  data: PlayerUpdateWithoutAwardsWonAsDWinnerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutAwardsWonAsGWinnerInput = {
  data: PlayerUpdateWithoutAwardsWonAsGWinnerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutChatsInput = {
  data: PlayerUpdateWithoutChatsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutConnectsInput = {
  data: PlayerUpdateWithoutConnectsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutDisconnectsInput = {
  data: PlayerUpdateWithoutDisconnectsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutEntriesInput = {
  data: PlayerUpdateWithoutEntriesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutFragsAsKillerInput = {
  data: PlayerUpdateWithoutFragsAsKillerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutFragsAsVictimInput = {
  data: PlayerUpdateWithoutFragsAsVictimInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutHistoryInput = {
  data: PlayerUpdateWithoutHistoryInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutLatencyEventsInput = {
  data: PlayerUpdateWithoutLatencyEventsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutNameChangesInput = {
  data: PlayerUpdateWithoutNameChangesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutNamesInput = {
  data: PlayerUpdateWithoutNamesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutPlayerActionsInput = {
  data: PlayerUpdateWithoutPlayerActionsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutPlayerPlayerActionsAsActorInput = {
  data: PlayerUpdateWithoutPlayerPlayerActionsAsActorInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutPlayerPlayerActionsAsVictimInput = {
  data: PlayerUpdateWithoutPlayerPlayerActionsAsVictimInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutRibbonsInput = {
  data: PlayerUpdateWithoutRibbonsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutRoleChangesInput = {
  data: PlayerUpdateWithoutRoleChangesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutSuicideEventsInput = {
  data: PlayerUpdateWithoutSuicideEventsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutTeamBonusesInput = {
  data: PlayerUpdateWithoutTeamBonusesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutTeamChangesInput = {
  data: PlayerUpdateWithoutTeamChangesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutTeamkillsAsKillerInput = {
  data: PlayerUpdateWithoutTeamkillsAsKillerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutTeamkillsAsVictimInput = {
  data: PlayerUpdateWithoutTeamkillsAsVictimInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateToOneWithWhereWithoutUniqueIdsInput = {
  data: PlayerUpdateWithoutUniqueIdsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpdateWithWhereUniqueWithoutClanInput = {
  data: PlayerUpdateWithoutClanInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerUpdateWithWhereUniqueWithoutCountryDataInput = {
  data: PlayerUpdateWithoutCountryDataInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerUpdateWithWhereUniqueWithoutGameDataInput = {
  data: PlayerUpdateWithoutGameDataInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerUpdateWithoutAwardsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutAwardsWonAsDWinnerInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutAwardsWonAsGWinnerInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutChatsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutClanInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutConnectsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutCountryDataInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutDisconnectsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutEntriesInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutFragsAsKillerInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutFragsAsVictimInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutGameDataInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutHistoryInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutLatencyEventsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutNameChangesInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutNamesInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutPlayerActionsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutPlayerPlayerActionsAsActorInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutPlayerPlayerActionsAsVictimInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutRibbonsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutRoleChangesInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutSuicideEventsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutTeamBonusesInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutTeamChangesInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutTeamkillsAsKillerInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutTeamkillsAsVictimInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  uniqueIds?: InputMaybe<PlayerUniqueIdUpdateManyWithoutPlayerNestedInput>;
};

export type PlayerUpdateWithoutUniqueIdsInput = {
  activity?: InputMaybe<IntFieldUpdateOperationsInput>;
  awards?: InputMaybe<PlayerAwardUpdateManyWithoutPlayerNestedInput>;
  awardsWonAsDWinner?: InputMaybe<AwardUpdateManyWithoutDWinnerNestedInput>;
  awardsWonAsGWinner?: InputMaybe<AwardUpdateManyWithoutGWinnerNestedInput>;
  blockAvatar?: InputMaybe<IntFieldUpdateOperationsInput>;
  chats?: InputMaybe<EventChatUpdateManyWithoutPlayerNestedInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  clan?: InputMaybe<ClanUpdateOneWithoutPlayersNestedInput>;
  connectionTime?: InputMaybe<IntFieldUpdateOperationsInput>;
  connects?: InputMaybe<EventConnectUpdateManyWithoutPlayerNestedInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  countryData?: InputMaybe<CountryUpdateOneWithoutPlayersNestedInput>;
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  deathStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  disconnects?: InputMaybe<EventDisconnectUpdateManyWithoutPlayerNestedInput>;
  displayEvents?: InputMaybe<IntFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  entries?: InputMaybe<EventEntryUpdateManyWithoutPlayerNestedInput>;
  fragsAsKiller?: InputMaybe<EventFragUpdateManyWithoutKillerNestedInput>;
  fragsAsVictim?: InputMaybe<EventFragUpdateManyWithoutVictimNestedInput>;
  fullName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  gameData?: InputMaybe<GameUpdateOneRequiredWithoutPlayersNestedInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  hideRanking?: InputMaybe<IntFieldUpdateOperationsInput>;
  history?: InputMaybe<PlayerHistoryUpdateManyWithoutPlayerNestedInput>;
  hits?: InputMaybe<IntFieldUpdateOperationsInput>;
  killStreak?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lastName?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSkillChange?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  latencyEvents?: InputMaybe<EventLatencyUpdateManyWithoutPlayerNestedInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mmrank?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  nameChanges?: InputMaybe<EventChangeNameUpdateManyWithoutPlayerNestedInput>;
  names?: InputMaybe<PlayerNameUpdateManyWithoutPlayerNestedInput>;
  playerActions?: InputMaybe<EventPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutPlayerNestedInput>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutVictimNestedInput>;
  ribbons?: InputMaybe<PlayerRibbonUpdateManyWithoutPlayerNestedInput>;
  roleChanges?: InputMaybe<EventChangeRoleUpdateManyWithoutPlayerNestedInput>;
  shots?: InputMaybe<IntFieldUpdateOperationsInput>;
  skill?: InputMaybe<IntFieldUpdateOperationsInput>;
  state?: InputMaybe<StringFieldUpdateOperationsInput>;
  suicideEvents?: InputMaybe<EventSuicideUpdateManyWithoutPlayerNestedInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamBonuses?: InputMaybe<EventTeamBonusUpdateManyWithoutPlayerNestedInput>;
  teamChanges?: InputMaybe<EventChangeTeamUpdateManyWithoutPlayerNestedInput>;
  teamkills?: InputMaybe<IntFieldUpdateOperationsInput>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillUpdateManyWithoutKillerNestedInput>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillUpdateManyWithoutVictimNestedInput>;
};

export type PlayerUpsertWithWhereUniqueWithoutClanInput = {
  create: PlayerCreateWithoutClanInput;
  update: PlayerUpdateWithoutClanInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerUpsertWithWhereUniqueWithoutCountryDataInput = {
  create: PlayerCreateWithoutCountryDataInput;
  update: PlayerUpdateWithoutCountryDataInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerUpsertWithWhereUniqueWithoutGameDataInput = {
  create: PlayerCreateWithoutGameDataInput;
  update: PlayerUpdateWithoutGameDataInput;
  where: PlayerWhereUniqueInput;
};

export type PlayerUpsertWithoutAwardsInput = {
  create: PlayerCreateWithoutAwardsInput;
  update: PlayerUpdateWithoutAwardsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutAwardsWonAsDWinnerInput = {
  create: PlayerCreateWithoutAwardsWonAsDWinnerInput;
  update: PlayerUpdateWithoutAwardsWonAsDWinnerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutAwardsWonAsGWinnerInput = {
  create: PlayerCreateWithoutAwardsWonAsGWinnerInput;
  update: PlayerUpdateWithoutAwardsWonAsGWinnerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutChatsInput = {
  create: PlayerCreateWithoutChatsInput;
  update: PlayerUpdateWithoutChatsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutConnectsInput = {
  create: PlayerCreateWithoutConnectsInput;
  update: PlayerUpdateWithoutConnectsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutDisconnectsInput = {
  create: PlayerCreateWithoutDisconnectsInput;
  update: PlayerUpdateWithoutDisconnectsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutEntriesInput = {
  create: PlayerCreateWithoutEntriesInput;
  update: PlayerUpdateWithoutEntriesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutFragsAsKillerInput = {
  create: PlayerCreateWithoutFragsAsKillerInput;
  update: PlayerUpdateWithoutFragsAsKillerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutFragsAsVictimInput = {
  create: PlayerCreateWithoutFragsAsVictimInput;
  update: PlayerUpdateWithoutFragsAsVictimInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutHistoryInput = {
  create: PlayerCreateWithoutHistoryInput;
  update: PlayerUpdateWithoutHistoryInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutLatencyEventsInput = {
  create: PlayerCreateWithoutLatencyEventsInput;
  update: PlayerUpdateWithoutLatencyEventsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutNameChangesInput = {
  create: PlayerCreateWithoutNameChangesInput;
  update: PlayerUpdateWithoutNameChangesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutNamesInput = {
  create: PlayerCreateWithoutNamesInput;
  update: PlayerUpdateWithoutNamesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutPlayerActionsInput = {
  create: PlayerCreateWithoutPlayerActionsInput;
  update: PlayerUpdateWithoutPlayerActionsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutPlayerPlayerActionsAsActorInput = {
  create: PlayerCreateWithoutPlayerPlayerActionsAsActorInput;
  update: PlayerUpdateWithoutPlayerPlayerActionsAsActorInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutPlayerPlayerActionsAsVictimInput = {
  create: PlayerCreateWithoutPlayerPlayerActionsAsVictimInput;
  update: PlayerUpdateWithoutPlayerPlayerActionsAsVictimInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutRibbonsInput = {
  create: PlayerCreateWithoutRibbonsInput;
  update: PlayerUpdateWithoutRibbonsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutRoleChangesInput = {
  create: PlayerCreateWithoutRoleChangesInput;
  update: PlayerUpdateWithoutRoleChangesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutSuicideEventsInput = {
  create: PlayerCreateWithoutSuicideEventsInput;
  update: PlayerUpdateWithoutSuicideEventsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutTeamBonusesInput = {
  create: PlayerCreateWithoutTeamBonusesInput;
  update: PlayerUpdateWithoutTeamBonusesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutTeamChangesInput = {
  create: PlayerCreateWithoutTeamChangesInput;
  update: PlayerUpdateWithoutTeamChangesInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutTeamkillsAsKillerInput = {
  create: PlayerCreateWithoutTeamkillsAsKillerInput;
  update: PlayerUpdateWithoutTeamkillsAsKillerInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutTeamkillsAsVictimInput = {
  create: PlayerCreateWithoutTeamkillsAsVictimInput;
  update: PlayerUpdateWithoutTeamkillsAsVictimInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerUpsertWithoutUniqueIdsInput = {
  create: PlayerCreateWithoutUniqueIdsInput;
  update: PlayerUpdateWithoutUniqueIdsInput;
  where?: InputMaybe<PlayerWhereInput>;
};

export type PlayerWhereInput = {
  AND?: InputMaybe<Array<PlayerWhereInput>>;
  NOT?: InputMaybe<Array<PlayerWhereInput>>;
  OR?: InputMaybe<Array<PlayerWhereInput>>;
  activity?: InputMaybe<IntFilter>;
  awards?: InputMaybe<PlayerAwardListRelationFilter>;
  awardsWonAsDWinner?: InputMaybe<AwardListRelationFilter>;
  awardsWonAsGWinner?: InputMaybe<AwardListRelationFilter>;
  blockAvatar?: InputMaybe<IntFilter>;
  chats?: InputMaybe<EventChatListRelationFilter>;
  city?: InputMaybe<StringFilter>;
  clan?: InputMaybe<ClanWhereInput>;
  clanId?: InputMaybe<IntNullableFilter>;
  connectionTime?: InputMaybe<IntFilter>;
  connects?: InputMaybe<EventConnectListRelationFilter>;
  country?: InputMaybe<StringFilter>;
  countryData?: InputMaybe<CountryWhereInput>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  deathStreak?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  disconnects?: InputMaybe<EventDisconnectListRelationFilter>;
  displayEvents?: InputMaybe<IntFilter>;
  email?: InputMaybe<StringNullableFilter>;
  entries?: InputMaybe<EventEntryListRelationFilter>;
  flag?: InputMaybe<StringNullableFilter>;
  fragsAsKiller?: InputMaybe<EventFragListRelationFilter>;
  fragsAsVictim?: InputMaybe<EventFragListRelationFilter>;
  fullName?: InputMaybe<StringNullableFilter>;
  game?: InputMaybe<StringFilter>;
  gameData?: InputMaybe<GameWhereInput>;
  headshots?: InputMaybe<IntFilter>;
  hideRanking?: InputMaybe<IntFilter>;
  history?: InputMaybe<PlayerHistoryListRelationFilter>;
  hits?: InputMaybe<IntFilter>;
  killStreak?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastAddress?: InputMaybe<StringFilter>;
  lastEvent?: InputMaybe<DateTimeNullableFilter>;
  lastName?: InputMaybe<StringFilter>;
  lastSkillChange?: InputMaybe<DateTimeNullableFilter>;
  lat?: InputMaybe<FloatNullableFilter>;
  latencyEvents?: InputMaybe<EventLatencyListRelationFilter>;
  lng?: InputMaybe<FloatNullableFilter>;
  mmrank?: InputMaybe<IntNullableFilter>;
  nameChanges?: InputMaybe<EventChangeNameListRelationFilter>;
  names?: InputMaybe<PlayerNameListRelationFilter>;
  playerActions?: InputMaybe<EventPlayerActionListRelationFilter>;
  playerId?: InputMaybe<IntFilter>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  ribbons?: InputMaybe<PlayerRibbonListRelationFilter>;
  roleChanges?: InputMaybe<EventChangeRoleListRelationFilter>;
  shots?: InputMaybe<IntFilter>;
  skill?: InputMaybe<IntFilter>;
  state?: InputMaybe<StringFilter>;
  suicideEvents?: InputMaybe<EventSuicideListRelationFilter>;
  suicides?: InputMaybe<IntFilter>;
  teamBonuses?: InputMaybe<EventTeamBonusListRelationFilter>;
  teamChanges?: InputMaybe<EventChangeTeamListRelationFilter>;
  teamkills?: InputMaybe<IntFilter>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillListRelationFilter>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillListRelationFilter>;
  uniqueIds?: InputMaybe<PlayerUniqueIdListRelationFilter>;
};

export type PlayerWhereUniqueInput = {
  AND?: InputMaybe<Array<PlayerWhereInput>>;
  NOT?: InputMaybe<Array<PlayerWhereInput>>;
  OR?: InputMaybe<Array<PlayerWhereInput>>;
  activity?: InputMaybe<IntFilter>;
  awards?: InputMaybe<PlayerAwardListRelationFilter>;
  awardsWonAsDWinner?: InputMaybe<AwardListRelationFilter>;
  awardsWonAsGWinner?: InputMaybe<AwardListRelationFilter>;
  blockAvatar?: InputMaybe<IntFilter>;
  chats?: InputMaybe<EventChatListRelationFilter>;
  city?: InputMaybe<StringFilter>;
  clan?: InputMaybe<ClanWhereInput>;
  clanId?: InputMaybe<IntNullableFilter>;
  connectionTime?: InputMaybe<IntFilter>;
  connects?: InputMaybe<EventConnectListRelationFilter>;
  country?: InputMaybe<StringFilter>;
  countryData?: InputMaybe<CountryWhereInput>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  deathStreak?: InputMaybe<IntFilter>;
  deaths?: InputMaybe<IntFilter>;
  disconnects?: InputMaybe<EventDisconnectListRelationFilter>;
  displayEvents?: InputMaybe<IntFilter>;
  email?: InputMaybe<StringNullableFilter>;
  entries?: InputMaybe<EventEntryListRelationFilter>;
  flag?: InputMaybe<StringNullableFilter>;
  fragsAsKiller?: InputMaybe<EventFragListRelationFilter>;
  fragsAsVictim?: InputMaybe<EventFragListRelationFilter>;
  fullName?: InputMaybe<StringNullableFilter>;
  game?: InputMaybe<StringFilter>;
  gameData?: InputMaybe<GameWhereInput>;
  headshots?: InputMaybe<IntFilter>;
  hideRanking?: InputMaybe<IntFilter>;
  history?: InputMaybe<PlayerHistoryListRelationFilter>;
  hits?: InputMaybe<IntFilter>;
  killStreak?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastAddress?: InputMaybe<StringFilter>;
  lastEvent?: InputMaybe<DateTimeNullableFilter>;
  lastName?: InputMaybe<StringFilter>;
  lastSkillChange?: InputMaybe<DateTimeNullableFilter>;
  lat?: InputMaybe<FloatNullableFilter>;
  latencyEvents?: InputMaybe<EventLatencyListRelationFilter>;
  lng?: InputMaybe<FloatNullableFilter>;
  mmrank?: InputMaybe<IntNullableFilter>;
  nameChanges?: InputMaybe<EventChangeNameListRelationFilter>;
  names?: InputMaybe<PlayerNameListRelationFilter>;
  playerActions?: InputMaybe<EventPlayerActionListRelationFilter>;
  playerId?: InputMaybe<Scalars['Int']['input']>;
  playerPlayerActionsAsActor?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  playerPlayerActionsAsVictim?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  ribbons?: InputMaybe<PlayerRibbonListRelationFilter>;
  roleChanges?: InputMaybe<EventChangeRoleListRelationFilter>;
  shots?: InputMaybe<IntFilter>;
  skill?: InputMaybe<IntFilter>;
  state?: InputMaybe<StringFilter>;
  suicideEvents?: InputMaybe<EventSuicideListRelationFilter>;
  suicides?: InputMaybe<IntFilter>;
  teamBonuses?: InputMaybe<EventTeamBonusListRelationFilter>;
  teamChanges?: InputMaybe<EventChangeTeamListRelationFilter>;
  teamkills?: InputMaybe<IntFilter>;
  teamkillsAsKiller?: InputMaybe<EventTeamkillListRelationFilter>;
  teamkillsAsVictim?: InputMaybe<EventTeamkillListRelationFilter>;
  uniqueIds?: InputMaybe<PlayerUniqueIdListRelationFilter>;
};

export type Query = {
  __typename?: 'Query';
  countAccount: Scalars['Int']['output'];
  countAction: Scalars['Int']['output'];
  countAward: Scalars['Int']['output'];
  countClan: Scalars['Int']['output'];
  countClanTag: Scalars['Int']['output'];
  countCountry: Scalars['Int']['output'];
  countEventAdmin: Scalars['Int']['output'];
  countEventChangeName: Scalars['Int']['output'];
  countEventChangeRole: Scalars['Int']['output'];
  countEventChangeTeam: Scalars['Int']['output'];
  countEventChat: Scalars['Int']['output'];
  countEventConnect: Scalars['Int']['output'];
  countEventDisconnect: Scalars['Int']['output'];
  countEventEntry: Scalars['Int']['output'];
  countEventFrag: Scalars['Int']['output'];
  countEventLatency: Scalars['Int']['output'];
  countEventPlayerAction: Scalars['Int']['output'];
  countEventPlayerPlayerAction: Scalars['Int']['output'];
  countEventRcon: Scalars['Int']['output'];
  countEventSuicide: Scalars['Int']['output'];
  countEventTeamBonus: Scalars['Int']['output'];
  countEventTeamkill: Scalars['Int']['output'];
  countEventWorldAction: Scalars['Int']['output'];
  countGame: Scalars['Int']['output'];
  countGameDefault: Scalars['Int']['output'];
  countGameSupported: Scalars['Int']['output'];
  countGeoLiteCityBlock: Scalars['Int']['output'];
  countGeoLiteCityLocation: Scalars['Int']['output'];
  countMapCount: Scalars['Int']['output'];
  countModDefault: Scalars['Int']['output'];
  countModSupported: Scalars['Int']['output'];
  countNotificationConfig: Scalars['Int']['output'];
  countOption: Scalars['Int']['output'];
  countOptionChoice: Scalars['Int']['output'];
  countPlayer: Scalars['Int']['output'];
  countPlayerAward: Scalars['Int']['output'];
  countPlayerHistory: Scalars['Int']['output'];
  countPlayerName: Scalars['Int']['output'];
  countPlayerRibbon: Scalars['Int']['output'];
  countPlayerUniqueId: Scalars['Int']['output'];
  countRank: Scalars['Int']['output'];
  countRibbon: Scalars['Int']['output'];
  countRole: Scalars['Int']['output'];
  countServer: Scalars['Int']['output'];
  countServerConfig: Scalars['Int']['output'];
  countServerConfigDefault: Scalars['Int']['output'];
  countServerLoad: Scalars['Int']['output'];
  countSession: Scalars['Int']['output'];
  countTeam: Scalars['Int']['output'];
  countUser: Scalars['Int']['output'];
  countVerification: Scalars['Int']['output'];
  countWeapon: Scalars['Int']['output'];
  findFirstAccount?: Maybe<Account>;
  findFirstAction?: Maybe<Action>;
  findFirstAward?: Maybe<Award>;
  findFirstClan?: Maybe<Clan>;
  findFirstClanTag?: Maybe<ClanTag>;
  findFirstCountry?: Maybe<Country>;
  findFirstEventAdmin?: Maybe<EventAdmin>;
  findFirstEventChangeName?: Maybe<EventChangeName>;
  findFirstEventChangeRole?: Maybe<EventChangeRole>;
  findFirstEventChangeTeam?: Maybe<EventChangeTeam>;
  findFirstEventChat?: Maybe<EventChat>;
  findFirstEventConnect?: Maybe<EventConnect>;
  findFirstEventDisconnect?: Maybe<EventDisconnect>;
  findFirstEventEntry?: Maybe<EventEntry>;
  findFirstEventFrag?: Maybe<EventFrag>;
  findFirstEventLatency?: Maybe<EventLatency>;
  findFirstEventPlayerAction?: Maybe<EventPlayerAction>;
  findFirstEventPlayerPlayerAction?: Maybe<EventPlayerPlayerAction>;
  findFirstEventRcon?: Maybe<EventRcon>;
  findFirstEventSuicide?: Maybe<EventSuicide>;
  findFirstEventTeamBonus?: Maybe<EventTeamBonus>;
  findFirstEventTeamkill?: Maybe<EventTeamkill>;
  findFirstEventWorldAction?: Maybe<EventWorldAction>;
  findFirstGame?: Maybe<Game>;
  findFirstGameDefault?: Maybe<GameDefault>;
  findFirstGameSupported?: Maybe<GameSupported>;
  findFirstGeoLiteCityBlock?: Maybe<GeoLiteCityBlock>;
  findFirstGeoLiteCityLocation?: Maybe<GeoLiteCityLocation>;
  findFirstMapCount?: Maybe<MapCount>;
  findFirstModDefault?: Maybe<ModDefault>;
  findFirstModSupported?: Maybe<ModSupported>;
  findFirstNotificationConfig?: Maybe<NotificationConfig>;
  findFirstOption?: Maybe<Option>;
  findFirstOptionChoice?: Maybe<OptionChoice>;
  findFirstPlayer?: Maybe<Player>;
  findFirstPlayerAward?: Maybe<PlayerAward>;
  findFirstPlayerHistory?: Maybe<PlayerHistory>;
  findFirstPlayerName?: Maybe<PlayerName>;
  findFirstPlayerRibbon?: Maybe<PlayerRibbon>;
  findFirstPlayerUniqueId?: Maybe<PlayerUniqueId>;
  findFirstRank?: Maybe<Rank>;
  findFirstRibbon?: Maybe<Ribbon>;
  findFirstRole?: Maybe<Role>;
  findFirstServer?: Maybe<Server>;
  findFirstServerConfig?: Maybe<ServerConfig>;
  findFirstServerConfigDefault?: Maybe<ServerConfigDefault>;
  findFirstServerLoad?: Maybe<ServerLoad>;
  findFirstSession?: Maybe<Session>;
  findFirstTeam?: Maybe<Team>;
  findFirstUser?: Maybe<User>;
  findFirstVerification?: Maybe<Verification>;
  findFirstWeapon?: Maybe<Weapon>;
  findManyAccount: Array<Account>;
  findManyAction: Array<Action>;
  findManyAward: Array<Award>;
  findManyClan: Array<Clan>;
  findManyClanTag: Array<ClanTag>;
  findManyCountry: Array<Country>;
  findManyEventAdmin: Array<EventAdmin>;
  findManyEventChangeName: Array<EventChangeName>;
  findManyEventChangeRole: Array<EventChangeRole>;
  findManyEventChangeTeam: Array<EventChangeTeam>;
  findManyEventChat: Array<EventChat>;
  findManyEventConnect: Array<EventConnect>;
  findManyEventDisconnect: Array<EventDisconnect>;
  findManyEventEntry: Array<EventEntry>;
  findManyEventFrag: Array<EventFrag>;
  findManyEventLatency: Array<EventLatency>;
  findManyEventPlayerAction: Array<EventPlayerAction>;
  findManyEventPlayerPlayerAction: Array<EventPlayerPlayerAction>;
  findManyEventRcon: Array<EventRcon>;
  findManyEventSuicide: Array<EventSuicide>;
  findManyEventTeamBonus: Array<EventTeamBonus>;
  findManyEventTeamkill: Array<EventTeamkill>;
  findManyEventWorldAction: Array<EventWorldAction>;
  findManyGame: Array<Game>;
  findManyGameDefault: Array<GameDefault>;
  findManyGameSupported: Array<GameSupported>;
  findManyGeoLiteCityBlock: Array<GeoLiteCityBlock>;
  findManyGeoLiteCityLocation: Array<GeoLiteCityLocation>;
  findManyMapCount: Array<MapCount>;
  findManyModDefault: Array<ModDefault>;
  findManyModSupported: Array<ModSupported>;
  findManyNotificationConfig: Array<NotificationConfig>;
  findManyOption: Array<Option>;
  findManyOptionChoice: Array<OptionChoice>;
  findManyPlayer: Array<Player>;
  findManyPlayerAward: Array<PlayerAward>;
  findManyPlayerHistory: Array<PlayerHistory>;
  findManyPlayerName: Array<PlayerName>;
  findManyPlayerRibbon: Array<PlayerRibbon>;
  findManyPlayerUniqueId: Array<PlayerUniqueId>;
  findManyRank: Array<Rank>;
  findManyRibbon: Array<Ribbon>;
  findManyRole: Array<Role>;
  findManyServer: Array<Server>;
  findManyServerConfig: Array<ServerConfig>;
  findManyServerConfigDefault: Array<ServerConfigDefault>;
  findManyServerLoad: Array<ServerLoad>;
  findManySession: Array<Session>;
  findManyTeam: Array<Team>;
  findManyUser: Array<User>;
  findManyVerification: Array<Verification>;
  findManyWeapon: Array<Weapon>;
  findUniqueAccount?: Maybe<Account>;
  findUniqueAction?: Maybe<Action>;
  findUniqueAward?: Maybe<Award>;
  findUniqueClan?: Maybe<Clan>;
  findUniqueClanTag?: Maybe<ClanTag>;
  findUniqueCountry?: Maybe<Country>;
  findUniqueEventAdmin?: Maybe<EventAdmin>;
  findUniqueEventChangeName?: Maybe<EventChangeName>;
  findUniqueEventChangeRole?: Maybe<EventChangeRole>;
  findUniqueEventChangeTeam?: Maybe<EventChangeTeam>;
  findUniqueEventChat?: Maybe<EventChat>;
  findUniqueEventConnect?: Maybe<EventConnect>;
  findUniqueEventDisconnect?: Maybe<EventDisconnect>;
  findUniqueEventEntry?: Maybe<EventEntry>;
  findUniqueEventFrag?: Maybe<EventFrag>;
  findUniqueEventLatency?: Maybe<EventLatency>;
  findUniqueEventPlayerAction?: Maybe<EventPlayerAction>;
  findUniqueEventPlayerPlayerAction?: Maybe<EventPlayerPlayerAction>;
  findUniqueEventRcon?: Maybe<EventRcon>;
  findUniqueEventSuicide?: Maybe<EventSuicide>;
  findUniqueEventTeamBonus?: Maybe<EventTeamBonus>;
  findUniqueEventTeamkill?: Maybe<EventTeamkill>;
  findUniqueEventWorldAction?: Maybe<EventWorldAction>;
  findUniqueGame?: Maybe<Game>;
  findUniqueGameDefault?: Maybe<GameDefault>;
  findUniqueGameSupported?: Maybe<GameSupported>;
  findUniqueGeoLiteCityBlock?: Maybe<GeoLiteCityBlock>;
  findUniqueGeoLiteCityLocation?: Maybe<GeoLiteCityLocation>;
  findUniqueMapCount?: Maybe<MapCount>;
  findUniqueModDefault?: Maybe<ModDefault>;
  findUniqueModSupported?: Maybe<ModSupported>;
  findUniqueNotificationConfig?: Maybe<NotificationConfig>;
  findUniqueOption?: Maybe<Option>;
  findUniqueOptionChoice?: Maybe<OptionChoice>;
  findUniquePlayer?: Maybe<Player>;
  findUniquePlayerAward?: Maybe<PlayerAward>;
  findUniquePlayerHistory?: Maybe<PlayerHistory>;
  findUniquePlayerName?: Maybe<PlayerName>;
  findUniquePlayerRibbon?: Maybe<PlayerRibbon>;
  findUniquePlayerUniqueId?: Maybe<PlayerUniqueId>;
  findUniqueRank?: Maybe<Rank>;
  findUniqueRibbon?: Maybe<Ribbon>;
  findUniqueRole?: Maybe<Role>;
  findUniqueServer?: Maybe<Server>;
  findUniqueServerConfig?: Maybe<ServerConfig>;
  findUniqueServerConfigDefault?: Maybe<ServerConfigDefault>;
  findUniqueServerLoad?: Maybe<ServerLoad>;
  findUniqueSession?: Maybe<Session>;
  findUniqueTeam?: Maybe<Team>;
  findUniqueUser?: Maybe<User>;
  findUniqueVerification?: Maybe<Verification>;
  findUniqueWeapon?: Maybe<Weapon>;
  getPlayerById?: Maybe<Player>;
  getPlayers?: Maybe<GetPlayersResult>;
  getServerPlayers?: Maybe<GetServerPlayersResult>;
  health?: Maybe<HealthStatus>;
};


export type QueryCountAccountArgs = {
  cursor?: InputMaybe<AccountWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AccountWhereInput>;
};


export type QueryCountActionArgs = {
  cursor?: InputMaybe<ActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<ActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ActionWhereInput>;
};


export type QueryCountAwardArgs = {
  cursor?: InputMaybe<AwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<AwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AwardWhereInput>;
};


export type QueryCountClanArgs = {
  cursor?: InputMaybe<ClanWhereUniqueInput>;
  distinct?: InputMaybe<Array<ClanScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ClanOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ClanWhereInput>;
};


export type QueryCountClanTagArgs = {
  cursor?: InputMaybe<ClanTagWhereUniqueInput>;
  distinct?: InputMaybe<Array<ClanTagScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ClanTagOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ClanTagWhereInput>;
};


export type QueryCountCountryArgs = {
  cursor?: InputMaybe<CountryWhereUniqueInput>;
  distinct?: InputMaybe<Array<CountryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<CountryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CountryWhereInput>;
};


export type QueryCountEventAdminArgs = {
  cursor?: InputMaybe<EventAdminWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventAdminScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventAdminOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventAdminWhereInput>;
};


export type QueryCountEventChangeNameArgs = {
  cursor?: InputMaybe<EventChangeNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeNameWhereInput>;
};


export type QueryCountEventChangeRoleArgs = {
  cursor?: InputMaybe<EventChangeRoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeRoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeRoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeRoleWhereInput>;
};


export type QueryCountEventChangeTeamArgs = {
  cursor?: InputMaybe<EventChangeTeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeTeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeTeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeTeamWhereInput>;
};


export type QueryCountEventChatArgs = {
  cursor?: InputMaybe<EventChatWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChatScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChatOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChatWhereInput>;
};


export type QueryCountEventConnectArgs = {
  cursor?: InputMaybe<EventConnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventConnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventConnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventConnectWhereInput>;
};


export type QueryCountEventDisconnectArgs = {
  cursor?: InputMaybe<EventDisconnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventDisconnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventDisconnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventDisconnectWhereInput>;
};


export type QueryCountEventEntryArgs = {
  cursor?: InputMaybe<EventEntryWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventEntryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventEntryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventEntryWhereInput>;
};


export type QueryCountEventFragArgs = {
  cursor?: InputMaybe<EventFragWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventFragScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventFragOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventFragWhereInput>;
};


export type QueryCountEventLatencyArgs = {
  cursor?: InputMaybe<EventLatencyWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventLatencyScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventLatencyOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventLatencyWhereInput>;
};


export type QueryCountEventPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerActionWhereInput>;
};


export type QueryCountEventPlayerPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type QueryCountEventRconArgs = {
  cursor?: InputMaybe<EventRconWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventRconScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventRconOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventRconWhereInput>;
};


export type QueryCountEventSuicideArgs = {
  cursor?: InputMaybe<EventSuicideWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventSuicideScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventSuicideOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventSuicideWhereInput>;
};


export type QueryCountEventTeamBonusArgs = {
  cursor?: InputMaybe<EventTeamBonusWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamBonusScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamBonusOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamBonusWhereInput>;
};


export type QueryCountEventTeamkillArgs = {
  cursor?: InputMaybe<EventTeamkillWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamkillScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamkillOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamkillWhereInput>;
};


export type QueryCountEventWorldActionArgs = {
  cursor?: InputMaybe<EventWorldActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventWorldActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventWorldActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventWorldActionWhereInput>;
};


export type QueryCountGameArgs = {
  cursor?: InputMaybe<GameWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameWhereInput>;
};


export type QueryCountGameDefaultArgs = {
  cursor?: InputMaybe<GameDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameDefaultWhereInput>;
};


export type QueryCountGameSupportedArgs = {
  cursor?: InputMaybe<GameSupportedWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameSupportedScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameSupportedOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameSupportedWhereInput>;
};


export type QueryCountGeoLiteCityBlockArgs = {
  cursor?: InputMaybe<GeoLiteCityBlockWhereUniqueInput>;
  distinct?: InputMaybe<Array<GeoLiteCityBlockScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GeoLiteCityBlockOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GeoLiteCityBlockWhereInput>;
};


export type QueryCountGeoLiteCityLocationArgs = {
  cursor?: InputMaybe<GeoLiteCityLocationWhereUniqueInput>;
  distinct?: InputMaybe<Array<GeoLiteCityLocationScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GeoLiteCityLocationOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GeoLiteCityLocationWhereInput>;
};


export type QueryCountMapCountArgs = {
  cursor?: InputMaybe<MapCountWhereUniqueInput>;
  distinct?: InputMaybe<Array<MapCountScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MapCountOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<MapCountWhereInput>;
};


export type QueryCountModDefaultArgs = {
  cursor?: InputMaybe<ModDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<ModDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ModDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ModDefaultWhereInput>;
};


export type QueryCountModSupportedArgs = {
  cursor?: InputMaybe<ModSupportedWhereUniqueInput>;
  distinct?: InputMaybe<Array<ModSupportedScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ModSupportedOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ModSupportedWhereInput>;
};


export type QueryCountNotificationConfigArgs = {
  cursor?: InputMaybe<NotificationConfigWhereUniqueInput>;
  distinct?: InputMaybe<Array<NotificationConfigScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<NotificationConfigOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<NotificationConfigWhereInput>;
};


export type QueryCountOptionArgs = {
  cursor?: InputMaybe<OptionWhereUniqueInput>;
  distinct?: InputMaybe<Array<OptionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OptionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OptionWhereInput>;
};


export type QueryCountOptionChoiceArgs = {
  cursor?: InputMaybe<OptionChoiceWhereUniqueInput>;
  distinct?: InputMaybe<Array<OptionChoiceScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OptionChoiceOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OptionChoiceWhereInput>;
};


export type QueryCountPlayerArgs = {
  cursor?: InputMaybe<PlayerWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerWhereInput>;
};


export type QueryCountPlayerAwardArgs = {
  cursor?: InputMaybe<PlayerAwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerAwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerAwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerAwardWhereInput>;
};


export type QueryCountPlayerHistoryArgs = {
  cursor?: InputMaybe<PlayerHistoryWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerHistoryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerHistoryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerHistoryWhereInput>;
};


export type QueryCountPlayerNameArgs = {
  cursor?: InputMaybe<PlayerNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerNameWhereInput>;
};


export type QueryCountPlayerRibbonArgs = {
  cursor?: InputMaybe<PlayerRibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerRibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerRibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerRibbonWhereInput>;
};


export type QueryCountPlayerUniqueIdArgs = {
  cursor?: InputMaybe<PlayerUniqueIdWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerUniqueIdScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerUniqueIdOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerUniqueIdWhereInput>;
};


export type QueryCountRankArgs = {
  cursor?: InputMaybe<RankWhereUniqueInput>;
  distinct?: InputMaybe<Array<RankScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RankOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RankWhereInput>;
};


export type QueryCountRibbonArgs = {
  cursor?: InputMaybe<RibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<RibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RibbonWhereInput>;
};


export type QueryCountRoleArgs = {
  cursor?: InputMaybe<RoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<RoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QueryCountServerArgs = {
  cursor?: InputMaybe<ServerWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerWhereInput>;
};


export type QueryCountServerConfigArgs = {
  cursor?: InputMaybe<ServerConfigWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerConfigScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerConfigOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerConfigWhereInput>;
};


export type QueryCountServerConfigDefaultArgs = {
  cursor?: InputMaybe<ServerConfigDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerConfigDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerConfigDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerConfigDefaultWhereInput>;
};


export type QueryCountServerLoadArgs = {
  cursor?: InputMaybe<ServerLoadWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerLoadScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerLoadOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerLoadWhereInput>;
};


export type QueryCountSessionArgs = {
  cursor?: InputMaybe<SessionWhereUniqueInput>;
  distinct?: InputMaybe<Array<SessionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SessionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<SessionWhereInput>;
};


export type QueryCountTeamArgs = {
  cursor?: InputMaybe<TeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<TeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<TeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TeamWhereInput>;
};


export type QueryCountUserArgs = {
  cursor?: InputMaybe<UserWhereUniqueInput>;
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryCountVerificationArgs = {
  cursor?: InputMaybe<VerificationWhereUniqueInput>;
  distinct?: InputMaybe<Array<VerificationScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<VerificationOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<VerificationWhereInput>;
};


export type QueryCountWeaponArgs = {
  cursor?: InputMaybe<WeaponWhereUniqueInput>;
  distinct?: InputMaybe<Array<WeaponScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WeaponOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<WeaponWhereInput>;
};


export type QueryFindFirstAccountArgs = {
  cursor?: InputMaybe<AccountWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AccountWhereInput>;
};


export type QueryFindFirstActionArgs = {
  cursor?: InputMaybe<ActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<ActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ActionWhereInput>;
};


export type QueryFindFirstAwardArgs = {
  cursor?: InputMaybe<AwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<AwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AwardWhereInput>;
};


export type QueryFindFirstClanArgs = {
  cursor?: InputMaybe<ClanWhereUniqueInput>;
  distinct?: InputMaybe<Array<ClanScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ClanOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ClanWhereInput>;
};


export type QueryFindFirstClanTagArgs = {
  cursor?: InputMaybe<ClanTagWhereUniqueInput>;
  distinct?: InputMaybe<Array<ClanTagScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ClanTagOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ClanTagWhereInput>;
};


export type QueryFindFirstCountryArgs = {
  cursor?: InputMaybe<CountryWhereUniqueInput>;
  distinct?: InputMaybe<Array<CountryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<CountryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CountryWhereInput>;
};


export type QueryFindFirstEventAdminArgs = {
  cursor?: InputMaybe<EventAdminWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventAdminScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventAdminOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventAdminWhereInput>;
};


export type QueryFindFirstEventChangeNameArgs = {
  cursor?: InputMaybe<EventChangeNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeNameWhereInput>;
};


export type QueryFindFirstEventChangeRoleArgs = {
  cursor?: InputMaybe<EventChangeRoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeRoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeRoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeRoleWhereInput>;
};


export type QueryFindFirstEventChangeTeamArgs = {
  cursor?: InputMaybe<EventChangeTeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeTeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeTeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeTeamWhereInput>;
};


export type QueryFindFirstEventChatArgs = {
  cursor?: InputMaybe<EventChatWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChatScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChatOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChatWhereInput>;
};


export type QueryFindFirstEventConnectArgs = {
  cursor?: InputMaybe<EventConnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventConnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventConnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventConnectWhereInput>;
};


export type QueryFindFirstEventDisconnectArgs = {
  cursor?: InputMaybe<EventDisconnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventDisconnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventDisconnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventDisconnectWhereInput>;
};


export type QueryFindFirstEventEntryArgs = {
  cursor?: InputMaybe<EventEntryWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventEntryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventEntryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventEntryWhereInput>;
};


export type QueryFindFirstEventFragArgs = {
  cursor?: InputMaybe<EventFragWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventFragScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventFragOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventFragWhereInput>;
};


export type QueryFindFirstEventLatencyArgs = {
  cursor?: InputMaybe<EventLatencyWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventLatencyScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventLatencyOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventLatencyWhereInput>;
};


export type QueryFindFirstEventPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerActionWhereInput>;
};


export type QueryFindFirstEventPlayerPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type QueryFindFirstEventRconArgs = {
  cursor?: InputMaybe<EventRconWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventRconScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventRconOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventRconWhereInput>;
};


export type QueryFindFirstEventSuicideArgs = {
  cursor?: InputMaybe<EventSuicideWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventSuicideScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventSuicideOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventSuicideWhereInput>;
};


export type QueryFindFirstEventTeamBonusArgs = {
  cursor?: InputMaybe<EventTeamBonusWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamBonusScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamBonusOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamBonusWhereInput>;
};


export type QueryFindFirstEventTeamkillArgs = {
  cursor?: InputMaybe<EventTeamkillWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamkillScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamkillOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamkillWhereInput>;
};


export type QueryFindFirstEventWorldActionArgs = {
  cursor?: InputMaybe<EventWorldActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventWorldActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventWorldActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventWorldActionWhereInput>;
};


export type QueryFindFirstGameArgs = {
  cursor?: InputMaybe<GameWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameWhereInput>;
};


export type QueryFindFirstGameDefaultArgs = {
  cursor?: InputMaybe<GameDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameDefaultWhereInput>;
};


export type QueryFindFirstGameSupportedArgs = {
  cursor?: InputMaybe<GameSupportedWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameSupportedScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameSupportedOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameSupportedWhereInput>;
};


export type QueryFindFirstGeoLiteCityBlockArgs = {
  cursor?: InputMaybe<GeoLiteCityBlockWhereUniqueInput>;
  distinct?: InputMaybe<Array<GeoLiteCityBlockScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GeoLiteCityBlockOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GeoLiteCityBlockWhereInput>;
};


export type QueryFindFirstGeoLiteCityLocationArgs = {
  cursor?: InputMaybe<GeoLiteCityLocationWhereUniqueInput>;
  distinct?: InputMaybe<Array<GeoLiteCityLocationScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GeoLiteCityLocationOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GeoLiteCityLocationWhereInput>;
};


export type QueryFindFirstMapCountArgs = {
  cursor?: InputMaybe<MapCountWhereUniqueInput>;
  distinct?: InputMaybe<Array<MapCountScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MapCountOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<MapCountWhereInput>;
};


export type QueryFindFirstModDefaultArgs = {
  cursor?: InputMaybe<ModDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<ModDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ModDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ModDefaultWhereInput>;
};


export type QueryFindFirstModSupportedArgs = {
  cursor?: InputMaybe<ModSupportedWhereUniqueInput>;
  distinct?: InputMaybe<Array<ModSupportedScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ModSupportedOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ModSupportedWhereInput>;
};


export type QueryFindFirstNotificationConfigArgs = {
  cursor?: InputMaybe<NotificationConfigWhereUniqueInput>;
  distinct?: InputMaybe<Array<NotificationConfigScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<NotificationConfigOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<NotificationConfigWhereInput>;
};


export type QueryFindFirstOptionArgs = {
  cursor?: InputMaybe<OptionWhereUniqueInput>;
  distinct?: InputMaybe<Array<OptionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OptionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OptionWhereInput>;
};


export type QueryFindFirstOptionChoiceArgs = {
  cursor?: InputMaybe<OptionChoiceWhereUniqueInput>;
  distinct?: InputMaybe<Array<OptionChoiceScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OptionChoiceOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OptionChoiceWhereInput>;
};


export type QueryFindFirstPlayerArgs = {
  cursor?: InputMaybe<PlayerWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerWhereInput>;
};


export type QueryFindFirstPlayerAwardArgs = {
  cursor?: InputMaybe<PlayerAwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerAwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerAwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerAwardWhereInput>;
};


export type QueryFindFirstPlayerHistoryArgs = {
  cursor?: InputMaybe<PlayerHistoryWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerHistoryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerHistoryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerHistoryWhereInput>;
};


export type QueryFindFirstPlayerNameArgs = {
  cursor?: InputMaybe<PlayerNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerNameWhereInput>;
};


export type QueryFindFirstPlayerRibbonArgs = {
  cursor?: InputMaybe<PlayerRibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerRibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerRibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerRibbonWhereInput>;
};


export type QueryFindFirstPlayerUniqueIdArgs = {
  cursor?: InputMaybe<PlayerUniqueIdWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerUniqueIdScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerUniqueIdOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerUniqueIdWhereInput>;
};


export type QueryFindFirstRankArgs = {
  cursor?: InputMaybe<RankWhereUniqueInput>;
  distinct?: InputMaybe<Array<RankScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RankOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RankWhereInput>;
};


export type QueryFindFirstRibbonArgs = {
  cursor?: InputMaybe<RibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<RibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RibbonWhereInput>;
};


export type QueryFindFirstRoleArgs = {
  cursor?: InputMaybe<RoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<RoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QueryFindFirstServerArgs = {
  cursor?: InputMaybe<ServerWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerWhereInput>;
};


export type QueryFindFirstServerConfigArgs = {
  cursor?: InputMaybe<ServerConfigWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerConfigScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerConfigOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerConfigWhereInput>;
};


export type QueryFindFirstServerConfigDefaultArgs = {
  cursor?: InputMaybe<ServerConfigDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerConfigDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerConfigDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerConfigDefaultWhereInput>;
};


export type QueryFindFirstServerLoadArgs = {
  cursor?: InputMaybe<ServerLoadWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerLoadScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerLoadOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerLoadWhereInput>;
};


export type QueryFindFirstSessionArgs = {
  cursor?: InputMaybe<SessionWhereUniqueInput>;
  distinct?: InputMaybe<Array<SessionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SessionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<SessionWhereInput>;
};


export type QueryFindFirstTeamArgs = {
  cursor?: InputMaybe<TeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<TeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<TeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TeamWhereInput>;
};


export type QueryFindFirstUserArgs = {
  cursor?: InputMaybe<UserWhereUniqueInput>;
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryFindFirstVerificationArgs = {
  cursor?: InputMaybe<VerificationWhereUniqueInput>;
  distinct?: InputMaybe<Array<VerificationScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<VerificationOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<VerificationWhereInput>;
};


export type QueryFindFirstWeaponArgs = {
  cursor?: InputMaybe<WeaponWhereUniqueInput>;
  distinct?: InputMaybe<Array<WeaponScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WeaponOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<WeaponWhereInput>;
};


export type QueryFindManyAccountArgs = {
  cursor?: InputMaybe<AccountWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AccountWhereInput>;
};


export type QueryFindManyActionArgs = {
  cursor?: InputMaybe<ActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<ActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ActionWhereInput>;
};


export type QueryFindManyAwardArgs = {
  cursor?: InputMaybe<AwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<AwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AwardWhereInput>;
};


export type QueryFindManyClanArgs = {
  cursor?: InputMaybe<ClanWhereUniqueInput>;
  distinct?: InputMaybe<Array<ClanScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ClanOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ClanWhereInput>;
};


export type QueryFindManyClanTagArgs = {
  cursor?: InputMaybe<ClanTagWhereUniqueInput>;
  distinct?: InputMaybe<Array<ClanTagScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ClanTagOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ClanTagWhereInput>;
};


export type QueryFindManyCountryArgs = {
  cursor?: InputMaybe<CountryWhereUniqueInput>;
  distinct?: InputMaybe<Array<CountryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<CountryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CountryWhereInput>;
};


export type QueryFindManyEventAdminArgs = {
  cursor?: InputMaybe<EventAdminWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventAdminScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventAdminOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventAdminWhereInput>;
};


export type QueryFindManyEventChangeNameArgs = {
  cursor?: InputMaybe<EventChangeNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeNameWhereInput>;
};


export type QueryFindManyEventChangeRoleArgs = {
  cursor?: InputMaybe<EventChangeRoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeRoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeRoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeRoleWhereInput>;
};


export type QueryFindManyEventChangeTeamArgs = {
  cursor?: InputMaybe<EventChangeTeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeTeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeTeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeTeamWhereInput>;
};


export type QueryFindManyEventChatArgs = {
  cursor?: InputMaybe<EventChatWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChatScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChatOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChatWhereInput>;
};


export type QueryFindManyEventConnectArgs = {
  cursor?: InputMaybe<EventConnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventConnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventConnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventConnectWhereInput>;
};


export type QueryFindManyEventDisconnectArgs = {
  cursor?: InputMaybe<EventDisconnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventDisconnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventDisconnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventDisconnectWhereInput>;
};


export type QueryFindManyEventEntryArgs = {
  cursor?: InputMaybe<EventEntryWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventEntryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventEntryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventEntryWhereInput>;
};


export type QueryFindManyEventFragArgs = {
  cursor?: InputMaybe<EventFragWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventFragScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventFragOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventFragWhereInput>;
};


export type QueryFindManyEventLatencyArgs = {
  cursor?: InputMaybe<EventLatencyWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventLatencyScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventLatencyOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventLatencyWhereInput>;
};


export type QueryFindManyEventPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerActionWhereInput>;
};


export type QueryFindManyEventPlayerPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type QueryFindManyEventRconArgs = {
  cursor?: InputMaybe<EventRconWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventRconScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventRconOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventRconWhereInput>;
};


export type QueryFindManyEventSuicideArgs = {
  cursor?: InputMaybe<EventSuicideWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventSuicideScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventSuicideOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventSuicideWhereInput>;
};


export type QueryFindManyEventTeamBonusArgs = {
  cursor?: InputMaybe<EventTeamBonusWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamBonusScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamBonusOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamBonusWhereInput>;
};


export type QueryFindManyEventTeamkillArgs = {
  cursor?: InputMaybe<EventTeamkillWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamkillScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamkillOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamkillWhereInput>;
};


export type QueryFindManyEventWorldActionArgs = {
  cursor?: InputMaybe<EventWorldActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventWorldActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventWorldActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventWorldActionWhereInput>;
};


export type QueryFindManyGameArgs = {
  cursor?: InputMaybe<GameWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameWhereInput>;
};


export type QueryFindManyGameDefaultArgs = {
  cursor?: InputMaybe<GameDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameDefaultWhereInput>;
};


export type QueryFindManyGameSupportedArgs = {
  cursor?: InputMaybe<GameSupportedWhereUniqueInput>;
  distinct?: InputMaybe<Array<GameSupportedScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GameSupportedOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GameSupportedWhereInput>;
};


export type QueryFindManyGeoLiteCityBlockArgs = {
  cursor?: InputMaybe<GeoLiteCityBlockWhereUniqueInput>;
  distinct?: InputMaybe<Array<GeoLiteCityBlockScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GeoLiteCityBlockOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GeoLiteCityBlockWhereInput>;
};


export type QueryFindManyGeoLiteCityLocationArgs = {
  cursor?: InputMaybe<GeoLiteCityLocationWhereUniqueInput>;
  distinct?: InputMaybe<Array<GeoLiteCityLocationScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<GeoLiteCityLocationOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<GeoLiteCityLocationWhereInput>;
};


export type QueryFindManyMapCountArgs = {
  cursor?: InputMaybe<MapCountWhereUniqueInput>;
  distinct?: InputMaybe<Array<MapCountScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<MapCountOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<MapCountWhereInput>;
};


export type QueryFindManyModDefaultArgs = {
  cursor?: InputMaybe<ModDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<ModDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ModDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ModDefaultWhereInput>;
};


export type QueryFindManyModSupportedArgs = {
  cursor?: InputMaybe<ModSupportedWhereUniqueInput>;
  distinct?: InputMaybe<Array<ModSupportedScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ModSupportedOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ModSupportedWhereInput>;
};


export type QueryFindManyNotificationConfigArgs = {
  cursor?: InputMaybe<NotificationConfigWhereUniqueInput>;
  distinct?: InputMaybe<Array<NotificationConfigScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<NotificationConfigOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<NotificationConfigWhereInput>;
};


export type QueryFindManyOptionArgs = {
  cursor?: InputMaybe<OptionWhereUniqueInput>;
  distinct?: InputMaybe<Array<OptionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OptionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OptionWhereInput>;
};


export type QueryFindManyOptionChoiceArgs = {
  cursor?: InputMaybe<OptionChoiceWhereUniqueInput>;
  distinct?: InputMaybe<Array<OptionChoiceScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OptionChoiceOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OptionChoiceWhereInput>;
};


export type QueryFindManyPlayerArgs = {
  cursor?: InputMaybe<PlayerWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerWhereInput>;
};


export type QueryFindManyPlayerAwardArgs = {
  cursor?: InputMaybe<PlayerAwardWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerAwardScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerAwardOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerAwardWhereInput>;
};


export type QueryFindManyPlayerHistoryArgs = {
  cursor?: InputMaybe<PlayerHistoryWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerHistoryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerHistoryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerHistoryWhereInput>;
};


export type QueryFindManyPlayerNameArgs = {
  cursor?: InputMaybe<PlayerNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerNameWhereInput>;
};


export type QueryFindManyPlayerRibbonArgs = {
  cursor?: InputMaybe<PlayerRibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerRibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerRibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerRibbonWhereInput>;
};


export type QueryFindManyPlayerUniqueIdArgs = {
  cursor?: InputMaybe<PlayerUniqueIdWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerUniqueIdScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerUniqueIdOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerUniqueIdWhereInput>;
};


export type QueryFindManyRankArgs = {
  cursor?: InputMaybe<RankWhereUniqueInput>;
  distinct?: InputMaybe<Array<RankScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RankOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RankWhereInput>;
};


export type QueryFindManyRibbonArgs = {
  cursor?: InputMaybe<RibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<RibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RibbonWhereInput>;
};


export type QueryFindManyRoleArgs = {
  cursor?: InputMaybe<RoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<RoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QueryFindManyServerArgs = {
  cursor?: InputMaybe<ServerWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerWhereInput>;
};


export type QueryFindManyServerConfigArgs = {
  cursor?: InputMaybe<ServerConfigWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerConfigScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerConfigOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerConfigWhereInput>;
};


export type QueryFindManyServerConfigDefaultArgs = {
  cursor?: InputMaybe<ServerConfigDefaultWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerConfigDefaultScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerConfigDefaultOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerConfigDefaultWhereInput>;
};


export type QueryFindManyServerLoadArgs = {
  cursor?: InputMaybe<ServerLoadWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerLoadScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerLoadOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerLoadWhereInput>;
};


export type QueryFindManySessionArgs = {
  cursor?: InputMaybe<SessionWhereUniqueInput>;
  distinct?: InputMaybe<Array<SessionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SessionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<SessionWhereInput>;
};


export type QueryFindManyTeamArgs = {
  cursor?: InputMaybe<TeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<TeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<TeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TeamWhereInput>;
};


export type QueryFindManyUserArgs = {
  cursor?: InputMaybe<UserWhereUniqueInput>;
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryFindManyVerificationArgs = {
  cursor?: InputMaybe<VerificationWhereUniqueInput>;
  distinct?: InputMaybe<Array<VerificationScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<VerificationOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<VerificationWhereInput>;
};


export type QueryFindManyWeaponArgs = {
  cursor?: InputMaybe<WeaponWhereUniqueInput>;
  distinct?: InputMaybe<Array<WeaponScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<WeaponOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<WeaponWhereInput>;
};


export type QueryFindUniqueAccountArgs = {
  where: AccountWhereUniqueInput;
};


export type QueryFindUniqueActionArgs = {
  where: ActionWhereUniqueInput;
};


export type QueryFindUniqueAwardArgs = {
  where: AwardWhereUniqueInput;
};


export type QueryFindUniqueClanArgs = {
  where: ClanWhereUniqueInput;
};


export type QueryFindUniqueClanTagArgs = {
  where: ClanTagWhereUniqueInput;
};


export type QueryFindUniqueCountryArgs = {
  where: CountryWhereUniqueInput;
};


export type QueryFindUniqueEventAdminArgs = {
  where: EventAdminWhereUniqueInput;
};


export type QueryFindUniqueEventChangeNameArgs = {
  where: EventChangeNameWhereUniqueInput;
};


export type QueryFindUniqueEventChangeRoleArgs = {
  where: EventChangeRoleWhereUniqueInput;
};


export type QueryFindUniqueEventChangeTeamArgs = {
  where: EventChangeTeamWhereUniqueInput;
};


export type QueryFindUniqueEventChatArgs = {
  where: EventChatWhereUniqueInput;
};


export type QueryFindUniqueEventConnectArgs = {
  where: EventConnectWhereUniqueInput;
};


export type QueryFindUniqueEventDisconnectArgs = {
  where: EventDisconnectWhereUniqueInput;
};


export type QueryFindUniqueEventEntryArgs = {
  where: EventEntryWhereUniqueInput;
};


export type QueryFindUniqueEventFragArgs = {
  where: EventFragWhereUniqueInput;
};


export type QueryFindUniqueEventLatencyArgs = {
  where: EventLatencyWhereUniqueInput;
};


export type QueryFindUniqueEventPlayerActionArgs = {
  where: EventPlayerActionWhereUniqueInput;
};


export type QueryFindUniqueEventPlayerPlayerActionArgs = {
  where: EventPlayerPlayerActionWhereUniqueInput;
};


export type QueryFindUniqueEventRconArgs = {
  where: EventRconWhereUniqueInput;
};


export type QueryFindUniqueEventSuicideArgs = {
  where: EventSuicideWhereUniqueInput;
};


export type QueryFindUniqueEventTeamBonusArgs = {
  where: EventTeamBonusWhereUniqueInput;
};


export type QueryFindUniqueEventTeamkillArgs = {
  where: EventTeamkillWhereUniqueInput;
};


export type QueryFindUniqueEventWorldActionArgs = {
  where: EventWorldActionWhereUniqueInput;
};


export type QueryFindUniqueGameArgs = {
  where: GameWhereUniqueInput;
};


export type QueryFindUniqueGameDefaultArgs = {
  where: GameDefaultWhereUniqueInput;
};


export type QueryFindUniqueGameSupportedArgs = {
  where: GameSupportedWhereUniqueInput;
};


export type QueryFindUniqueGeoLiteCityBlockArgs = {
  where: GeoLiteCityBlockWhereUniqueInput;
};


export type QueryFindUniqueGeoLiteCityLocationArgs = {
  where: GeoLiteCityLocationWhereUniqueInput;
};


export type QueryFindUniqueMapCountArgs = {
  where: MapCountWhereUniqueInput;
};


export type QueryFindUniqueModDefaultArgs = {
  where: ModDefaultWhereUniqueInput;
};


export type QueryFindUniqueModSupportedArgs = {
  where: ModSupportedWhereUniqueInput;
};


export type QueryFindUniqueNotificationConfigArgs = {
  where: NotificationConfigWhereUniqueInput;
};


export type QueryFindUniqueOptionArgs = {
  where: OptionWhereUniqueInput;
};


export type QueryFindUniqueOptionChoiceArgs = {
  where: OptionChoiceWhereUniqueInput;
};


export type QueryFindUniquePlayerArgs = {
  where: PlayerWhereUniqueInput;
};


export type QueryFindUniquePlayerAwardArgs = {
  where: PlayerAwardWhereUniqueInput;
};


export type QueryFindUniquePlayerHistoryArgs = {
  where: PlayerHistoryWhereUniqueInput;
};


export type QueryFindUniquePlayerNameArgs = {
  where: PlayerNameWhereUniqueInput;
};


export type QueryFindUniquePlayerRibbonArgs = {
  where: PlayerRibbonWhereUniqueInput;
};


export type QueryFindUniquePlayerUniqueIdArgs = {
  where: PlayerUniqueIdWhereUniqueInput;
};


export type QueryFindUniqueRankArgs = {
  where: RankWhereUniqueInput;
};


export type QueryFindUniqueRibbonArgs = {
  where: RibbonWhereUniqueInput;
};


export type QueryFindUniqueRoleArgs = {
  where: RoleWhereUniqueInput;
};


export type QueryFindUniqueServerArgs = {
  where: ServerWhereUniqueInput;
};


export type QueryFindUniqueServerConfigArgs = {
  where: ServerConfigWhereUniqueInput;
};


export type QueryFindUniqueServerConfigDefaultArgs = {
  where: ServerConfigDefaultWhereUniqueInput;
};


export type QueryFindUniqueServerLoadArgs = {
  where: ServerLoadWhereUniqueInput;
};


export type QueryFindUniqueSessionArgs = {
  where: SessionWhereUniqueInput;
};


export type QueryFindUniqueTeamArgs = {
  where: TeamWhereUniqueInput;
};


export type QueryFindUniqueUserArgs = {
  where: UserWhereUniqueInput;
};


export type QueryFindUniqueVerificationArgs = {
  where: VerificationWhereUniqueInput;
};


export type QueryFindUniqueWeaponArgs = {
  where: WeaponWhereUniqueInput;
};


export type QueryGetPlayerByIdArgs = {
  playerId: Scalars['Int']['input'];
};


export type QueryGetPlayersArgs = {
  filters?: InputMaybe<GetPlayersFiltersInput>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryGetServerPlayersArgs = {
  filters?: InputMaybe<GetServerPlayersFiltersInput>;
  serverId: Scalars['Int']['input'];
  skip?: InputMaybe<Scalars['Int']['input']>;
  sortField?: InputMaybe<Scalars['String']['input']>;
  sortOrder?: InputMaybe<Scalars['String']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type Rank = {
  __typename?: 'Rank';
  game: Scalars['String']['output'];
  image: Scalars['String']['output'];
  maxKills: Scalars['Int']['output'];
  minKills: Scalars['Int']['output'];
  rankId: Scalars['ID']['output'];
  rankName: Scalars['String']['output'];
};

export type RankAvgOrderByAggregateInput = {
  maxKills?: InputMaybe<SortOrder>;
  minKills?: InputMaybe<SortOrder>;
  rankId?: InputMaybe<SortOrder>;
};

export type RankCountOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  maxKills?: InputMaybe<SortOrder>;
  minKills?: InputMaybe<SortOrder>;
  rankId?: InputMaybe<SortOrder>;
  rankName?: InputMaybe<SortOrder>;
};

export type RankCreateInput = {
  game: Scalars['String']['input'];
  image: Scalars['String']['input'];
  maxKills?: InputMaybe<Scalars['Int']['input']>;
  minKills?: InputMaybe<Scalars['Int']['input']>;
  rankName: Scalars['String']['input'];
};

export type RankCreateManyInput = {
  game: Scalars['String']['input'];
  image: Scalars['String']['input'];
  maxKills?: InputMaybe<Scalars['Int']['input']>;
  minKills?: InputMaybe<Scalars['Int']['input']>;
  rankId?: InputMaybe<Scalars['Int']['input']>;
  rankName: Scalars['String']['input'];
};

export type RankMaxOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  maxKills?: InputMaybe<SortOrder>;
  minKills?: InputMaybe<SortOrder>;
  rankId?: InputMaybe<SortOrder>;
  rankName?: InputMaybe<SortOrder>;
};

export type RankMinOrderByAggregateInput = {
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  maxKills?: InputMaybe<SortOrder>;
  minKills?: InputMaybe<SortOrder>;
  rankId?: InputMaybe<SortOrder>;
  rankName?: InputMaybe<SortOrder>;
};

export enum RankOrderByRelevanceFieldEnum {
  Game = 'game',
  Image = 'image',
  RankName = 'rankName'
}

export type RankOrderByRelevanceInput = {
  fields: Array<RankOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type RankOrderByWithAggregationInput = {
  _avg?: InputMaybe<RankAvgOrderByAggregateInput>;
  _count?: InputMaybe<RankCountOrderByAggregateInput>;
  _max?: InputMaybe<RankMaxOrderByAggregateInput>;
  _min?: InputMaybe<RankMinOrderByAggregateInput>;
  _sum?: InputMaybe<RankSumOrderByAggregateInput>;
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  maxKills?: InputMaybe<SortOrder>;
  minKills?: InputMaybe<SortOrder>;
  rankId?: InputMaybe<SortOrder>;
  rankName?: InputMaybe<SortOrder>;
};

export type RankOrderByWithRelationInput = {
  _relevance?: InputMaybe<RankOrderByRelevanceInput>;
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  maxKills?: InputMaybe<SortOrder>;
  minKills?: InputMaybe<SortOrder>;
  rankId?: InputMaybe<SortOrder>;
  rankName?: InputMaybe<SortOrder>;
};

export type RankRankgameCompoundUniqueInput = {
  game: Scalars['String']['input'];
  image: Scalars['String']['input'];
};

export enum RankScalarFieldEnum {
  Game = 'game',
  Image = 'image',
  MaxKills = 'maxKills',
  MinKills = 'minKills',
  RankId = 'rankId',
  RankName = 'rankName'
}

export type RankScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<RankScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<RankScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<RankScalarWhereWithAggregatesInput>>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  image?: InputMaybe<StringWithAggregatesFilter>;
  maxKills?: InputMaybe<IntWithAggregatesFilter>;
  minKills?: InputMaybe<IntWithAggregatesFilter>;
  rankId?: InputMaybe<IntWithAggregatesFilter>;
  rankName?: InputMaybe<StringWithAggregatesFilter>;
};

export type RankSumOrderByAggregateInput = {
  maxKills?: InputMaybe<SortOrder>;
  minKills?: InputMaybe<SortOrder>;
  rankId?: InputMaybe<SortOrder>;
};

export type RankUpdateInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<StringFieldUpdateOperationsInput>;
  maxKills?: InputMaybe<IntFieldUpdateOperationsInput>;
  minKills?: InputMaybe<IntFieldUpdateOperationsInput>;
  rankName?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type RankUpdateManyMutationInput = {
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<StringFieldUpdateOperationsInput>;
  maxKills?: InputMaybe<IntFieldUpdateOperationsInput>;
  minKills?: InputMaybe<IntFieldUpdateOperationsInput>;
  rankName?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type RankWhereInput = {
  AND?: InputMaybe<Array<RankWhereInput>>;
  NOT?: InputMaybe<Array<RankWhereInput>>;
  OR?: InputMaybe<Array<RankWhereInput>>;
  game?: InputMaybe<StringFilter>;
  image?: InputMaybe<StringFilter>;
  maxKills?: InputMaybe<IntFilter>;
  minKills?: InputMaybe<IntFilter>;
  rankId?: InputMaybe<IntFilter>;
  rankName?: InputMaybe<StringFilter>;
};

export type RankWhereUniqueInput = {
  AND?: InputMaybe<Array<RankWhereInput>>;
  NOT?: InputMaybe<Array<RankWhereInput>>;
  OR?: InputMaybe<Array<RankWhereInput>>;
  game?: InputMaybe<StringFilter>;
  image?: InputMaybe<StringFilter>;
  maxKills?: InputMaybe<IntFilter>;
  minKills?: InputMaybe<IntFilter>;
  rankId?: InputMaybe<Scalars['Int']['input']>;
  rankName?: InputMaybe<StringFilter>;
  rankgame?: InputMaybe<RankRankgameCompoundUniqueInput>;
};

export type Ribbon = {
  __typename?: 'Ribbon';
  awardCode: Scalars['String']['output'];
  awardCount: Scalars['Int']['output'];
  game: Scalars['String']['output'];
  image: Scalars['String']['output'];
  playerRibbons: Array<PlayerRibbon>;
  ribbonId: Scalars['ID']['output'];
  ribbonName: Scalars['String']['output'];
  special: Scalars['Int']['output'];
};


export type RibbonPlayerRibbonsArgs = {
  cursor?: InputMaybe<PlayerRibbonWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlayerRibbonScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlayerRibbonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PlayerRibbonWhereInput>;
};

export type RibbonAvgOrderByAggregateInput = {
  awardCount?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
  special?: InputMaybe<SortOrder>;
};

export type RibbonAwardCompoundUniqueInput = {
  awardCode: Scalars['String']['input'];
  awardCount: Scalars['Int']['input'];
  game: Scalars['String']['input'];
  special: Scalars['Int']['input'];
};

export type RibbonCountOrderByAggregateInput = {
  awardCode?: InputMaybe<SortOrder>;
  awardCount?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
  ribbonName?: InputMaybe<SortOrder>;
  special?: InputMaybe<SortOrder>;
};

export type RibbonCreateInput = {
  awardCode: Scalars['String']['input'];
  awardCount?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
  image: Scalars['String']['input'];
  playerRibbons?: InputMaybe<PlayerRibbonCreateNestedManyWithoutRibbonInput>;
  ribbonName: Scalars['String']['input'];
  special?: InputMaybe<Scalars['Int']['input']>;
};

export type RibbonCreateManyInput = {
  awardCode: Scalars['String']['input'];
  awardCount?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
  image: Scalars['String']['input'];
  ribbonId?: InputMaybe<Scalars['Int']['input']>;
  ribbonName: Scalars['String']['input'];
  special?: InputMaybe<Scalars['Int']['input']>;
};

export type RibbonCreateNestedOneWithoutPlayerRibbonsInput = {
  connect?: InputMaybe<RibbonWhereUniqueInput>;
  connectOrCreate?: InputMaybe<RibbonCreateOrConnectWithoutPlayerRibbonsInput>;
  create?: InputMaybe<RibbonCreateWithoutPlayerRibbonsInput>;
};

export type RibbonCreateOrConnectWithoutPlayerRibbonsInput = {
  create: RibbonCreateWithoutPlayerRibbonsInput;
  where: RibbonWhereUniqueInput;
};

export type RibbonCreateWithoutPlayerRibbonsInput = {
  awardCode: Scalars['String']['input'];
  awardCount?: InputMaybe<Scalars['Int']['input']>;
  game: Scalars['String']['input'];
  image: Scalars['String']['input'];
  ribbonName: Scalars['String']['input'];
  special?: InputMaybe<Scalars['Int']['input']>;
};

export type RibbonMaxOrderByAggregateInput = {
  awardCode?: InputMaybe<SortOrder>;
  awardCount?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
  ribbonName?: InputMaybe<SortOrder>;
  special?: InputMaybe<SortOrder>;
};

export type RibbonMinOrderByAggregateInput = {
  awardCode?: InputMaybe<SortOrder>;
  awardCount?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
  ribbonName?: InputMaybe<SortOrder>;
  special?: InputMaybe<SortOrder>;
};

export enum RibbonOrderByRelevanceFieldEnum {
  AwardCode = 'awardCode',
  Game = 'game',
  Image = 'image',
  RibbonName = 'ribbonName'
}

export type RibbonOrderByRelevanceInput = {
  fields: Array<RibbonOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type RibbonOrderByWithAggregationInput = {
  _avg?: InputMaybe<RibbonAvgOrderByAggregateInput>;
  _count?: InputMaybe<RibbonCountOrderByAggregateInput>;
  _max?: InputMaybe<RibbonMaxOrderByAggregateInput>;
  _min?: InputMaybe<RibbonMinOrderByAggregateInput>;
  _sum?: InputMaybe<RibbonSumOrderByAggregateInput>;
  awardCode?: InputMaybe<SortOrder>;
  awardCount?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
  ribbonName?: InputMaybe<SortOrder>;
  special?: InputMaybe<SortOrder>;
};

export type RibbonOrderByWithRelationInput = {
  _relevance?: InputMaybe<RibbonOrderByRelevanceInput>;
  awardCode?: InputMaybe<SortOrder>;
  awardCount?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  playerRibbons?: InputMaybe<PlayerRibbonOrderByRelationAggregateInput>;
  ribbonId?: InputMaybe<SortOrder>;
  ribbonName?: InputMaybe<SortOrder>;
  special?: InputMaybe<SortOrder>;
};

export enum RibbonScalarFieldEnum {
  AwardCode = 'awardCode',
  AwardCount = 'awardCount',
  Game = 'game',
  Image = 'image',
  RibbonId = 'ribbonId',
  RibbonName = 'ribbonName',
  Special = 'special'
}

export type RibbonScalarRelationFilter = {
  is?: InputMaybe<RibbonWhereInput>;
  isNot?: InputMaybe<RibbonWhereInput>;
};

export type RibbonScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<RibbonScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<RibbonScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<RibbonScalarWhereWithAggregatesInput>>;
  awardCode?: InputMaybe<StringWithAggregatesFilter>;
  awardCount?: InputMaybe<IntWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  image?: InputMaybe<StringWithAggregatesFilter>;
  ribbonId?: InputMaybe<IntWithAggregatesFilter>;
  ribbonName?: InputMaybe<StringWithAggregatesFilter>;
  special?: InputMaybe<IntWithAggregatesFilter>;
};

export type RibbonSumOrderByAggregateInput = {
  awardCount?: InputMaybe<SortOrder>;
  ribbonId?: InputMaybe<SortOrder>;
  special?: InputMaybe<SortOrder>;
};

export type RibbonUpdateInput = {
  awardCode?: InputMaybe<StringFieldUpdateOperationsInput>;
  awardCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerRibbons?: InputMaybe<PlayerRibbonUpdateManyWithoutRibbonNestedInput>;
  ribbonName?: InputMaybe<StringFieldUpdateOperationsInput>;
  special?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type RibbonUpdateManyMutationInput = {
  awardCode?: InputMaybe<StringFieldUpdateOperationsInput>;
  awardCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<StringFieldUpdateOperationsInput>;
  ribbonName?: InputMaybe<StringFieldUpdateOperationsInput>;
  special?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type RibbonUpdateOneRequiredWithoutPlayerRibbonsNestedInput = {
  connect?: InputMaybe<RibbonWhereUniqueInput>;
  connectOrCreate?: InputMaybe<RibbonCreateOrConnectWithoutPlayerRibbonsInput>;
  create?: InputMaybe<RibbonCreateWithoutPlayerRibbonsInput>;
  update?: InputMaybe<RibbonUpdateToOneWithWhereWithoutPlayerRibbonsInput>;
  upsert?: InputMaybe<RibbonUpsertWithoutPlayerRibbonsInput>;
};

export type RibbonUpdateToOneWithWhereWithoutPlayerRibbonsInput = {
  data: RibbonUpdateWithoutPlayerRibbonsInput;
  where?: InputMaybe<RibbonWhereInput>;
};

export type RibbonUpdateWithoutPlayerRibbonsInput = {
  awardCode?: InputMaybe<StringFieldUpdateOperationsInput>;
  awardCount?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<StringFieldUpdateOperationsInput>;
  ribbonName?: InputMaybe<StringFieldUpdateOperationsInput>;
  special?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type RibbonUpsertWithoutPlayerRibbonsInput = {
  create: RibbonCreateWithoutPlayerRibbonsInput;
  update: RibbonUpdateWithoutPlayerRibbonsInput;
  where?: InputMaybe<RibbonWhereInput>;
};

export type RibbonWhereInput = {
  AND?: InputMaybe<Array<RibbonWhereInput>>;
  NOT?: InputMaybe<Array<RibbonWhereInput>>;
  OR?: InputMaybe<Array<RibbonWhereInput>>;
  awardCode?: InputMaybe<StringFilter>;
  awardCount?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  image?: InputMaybe<StringFilter>;
  playerRibbons?: InputMaybe<PlayerRibbonListRelationFilter>;
  ribbonId?: InputMaybe<IntFilter>;
  ribbonName?: InputMaybe<StringFilter>;
  special?: InputMaybe<IntFilter>;
};

export type RibbonWhereUniqueInput = {
  AND?: InputMaybe<Array<RibbonWhereInput>>;
  NOT?: InputMaybe<Array<RibbonWhereInput>>;
  OR?: InputMaybe<Array<RibbonWhereInput>>;
  award?: InputMaybe<RibbonAwardCompoundUniqueInput>;
  awardCode?: InputMaybe<StringFilter>;
  awardCount?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  image?: InputMaybe<StringFilter>;
  playerRibbons?: InputMaybe<PlayerRibbonListRelationFilter>;
  ribbonId?: InputMaybe<Scalars['Int']['input']>;
  ribbonName?: InputMaybe<StringFilter>;
  special?: InputMaybe<IntFilter>;
};

export type Role = {
  __typename?: 'Role';
  code: Scalars['String']['output'];
  deaths: Scalars['Int']['output'];
  game: Scalars['String']['output'];
  hidden: Scalars['String']['output'];
  kills: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  picked: Scalars['Int']['output'];
  roleId: Scalars['ID']['output'];
};

export type RoleAvgOrderByAggregateInput = {
  deaths?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  picked?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
};

export type RoleCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  picked?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
};

export type RoleCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<Scalars['String']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  picked?: InputMaybe<Scalars['Int']['input']>;
};

export type RoleCreateManyInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  deaths?: InputMaybe<Scalars['Int']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<Scalars['String']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  picked?: InputMaybe<Scalars['Int']['input']>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
};

export type RoleGamecodeCompoundUniqueInput = {
  code: Scalars['String']['input'];
  game: Scalars['String']['input'];
};

export type RoleMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  picked?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
};

export type RoleMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  picked?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
};

export enum RoleOrderByRelevanceFieldEnum {
  Code = 'code',
  Game = 'game',
  Hidden = 'hidden',
  Name = 'name'
}

export type RoleOrderByRelevanceInput = {
  fields: Array<RoleOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type RoleOrderByWithAggregationInput = {
  _avg?: InputMaybe<RoleAvgOrderByAggregateInput>;
  _count?: InputMaybe<RoleCountOrderByAggregateInput>;
  _max?: InputMaybe<RoleMaxOrderByAggregateInput>;
  _min?: InputMaybe<RoleMinOrderByAggregateInput>;
  _sum?: InputMaybe<RoleSumOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  picked?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
};

export type RoleOrderByWithRelationInput = {
  _relevance?: InputMaybe<RoleOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  deaths?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  picked?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
};

export enum RoleScalarFieldEnum {
  Code = 'code',
  Deaths = 'deaths',
  Game = 'game',
  Hidden = 'hidden',
  Kills = 'kills',
  Name = 'name',
  Picked = 'picked',
  RoleId = 'roleId'
}

export type RoleScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<RoleScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<RoleScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<RoleScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  deaths?: InputMaybe<IntWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  hidden?: InputMaybe<StringWithAggregatesFilter>;
  kills?: InputMaybe<IntWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  picked?: InputMaybe<IntWithAggregatesFilter>;
  roleId?: InputMaybe<IntWithAggregatesFilter>;
};

export type RoleSumOrderByAggregateInput = {
  deaths?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  picked?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
};

export type RoleUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  picked?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type RoleUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  deaths?: InputMaybe<IntFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  picked?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type RoleWhereInput = {
  AND?: InputMaybe<Array<RoleWhereInput>>;
  NOT?: InputMaybe<Array<RoleWhereInput>>;
  OR?: InputMaybe<Array<RoleWhereInput>>;
  code?: InputMaybe<StringFilter>;
  deaths?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  hidden?: InputMaybe<StringFilter>;
  kills?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  picked?: InputMaybe<IntFilter>;
  roleId?: InputMaybe<IntFilter>;
};

export type RoleWhereUniqueInput = {
  AND?: InputMaybe<Array<RoleWhereInput>>;
  NOT?: InputMaybe<Array<RoleWhereInput>>;
  OR?: InputMaybe<Array<RoleWhereInput>>;
  code?: InputMaybe<StringFilter>;
  deaths?: InputMaybe<IntFilter>;
  game?: InputMaybe<StringFilter>;
  gamecode?: InputMaybe<RoleGamecodeCompoundUniqueInput>;
  hidden?: InputMaybe<StringFilter>;
  kills?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  picked?: InputMaybe<IntFilter>;
  roleId?: InputMaybe<Scalars['Int']['input']>;
};

export type SafeServer = {
  __typename?: 'SafeServer';
  address?: Maybe<Scalars['String']['output']>;
  connectionType?: Maybe<Scalars['String']['output']>;
  dockerHost?: Maybe<Scalars['String']['output']>;
  game?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  port?: Maybe<Scalars['Int']['output']>;
  publicAddress?: Maybe<Scalars['String']['output']>;
  serverId?: Maybe<Scalars['Int']['output']>;
  sortOrder?: Maybe<Scalars['Int']['output']>;
  statusUrl?: Maybe<Scalars['String']['output']>;
};

export type Server = {
  __typename?: 'Server';
  activeMap: Scalars['String']['output'];
  activePlayers: Scalars['Int']['output'];
  address: Scalars['String']['output'];
  bombsDefused: Scalars['Int']['output'];
  bombsPlanted: Scalars['Int']['output'];
  city: Scalars['String']['output'];
  configs: Array<ServerConfig>;
  connectionType: Scalars['String']['output'];
  country: Scalars['String']['output'];
  ctHits: Scalars['Int']['output'];
  ctShots: Scalars['Int']['output'];
  ctWins: Scalars['Int']['output'];
  dockerHost?: Maybe<Scalars['String']['output']>;
  eventsAdmin: Array<EventAdmin>;
  eventsChangeName: Array<EventChangeName>;
  eventsChangeRole: Array<EventChangeRole>;
  eventsChangeTeam: Array<EventChangeTeam>;
  eventsChat: Array<EventChat>;
  eventsConnect: Array<EventConnect>;
  eventsDisconnect: Array<EventDisconnect>;
  eventsEntry: Array<EventEntry>;
  eventsFrag: Array<EventFrag>;
  eventsLatency: Array<EventLatency>;
  eventsPlayerAction: Array<EventPlayerAction>;
  eventsPlayerPlayerAction: Array<EventPlayerPlayerAction>;
  eventsRcon: Array<EventRcon>;
  eventsSuicide: Array<EventSuicide>;
  eventsTeamBonus: Array<EventTeamBonus>;
  eventsTeamkill: Array<EventTeamkill>;
  game: Scalars['String']['output'];
  headshots: Scalars['Int']['output'];
  kills: Scalars['Int']['output'];
  lastEvent?: Maybe<Scalars['DateTime']['output']>;
  lat?: Maybe<Scalars['Float']['output']>;
  lng?: Maybe<Scalars['Float']['output']>;
  loads: Array<ServerLoad>;
  mapChanges: Scalars['Int']['output'];
  mapCtHits: Scalars['Int']['output'];
  mapCtShots: Scalars['Int']['output'];
  mapCtWins: Scalars['Int']['output'];
  mapRounds: Scalars['Int']['output'];
  mapStarted: Scalars['Int']['output'];
  mapTsHits: Scalars['Int']['output'];
  mapTsShots: Scalars['Int']['output'];
  mapTsWins: Scalars['Int']['output'];
  maxPlayers: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  notificationConfig?: Maybe<NotificationConfig>;
  players: Scalars['Int']['output'];
  port: Scalars['Int']['output'];
  publicAddress: Scalars['String']['output'];
  rconPassword: Scalars['String']['output'];
  rounds: Scalars['Int']['output'];
  serverId: Scalars['ID']['output'];
  sortOrder: Scalars['Int']['output'];
  statusUrl?: Maybe<Scalars['String']['output']>;
  suicides: Scalars['Int']['output'];
  tsHits: Scalars['Int']['output'];
  tsShots: Scalars['Int']['output'];
  tsWins: Scalars['Int']['output'];
};


export type ServerConfigsArgs = {
  cursor?: InputMaybe<ServerConfigWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerConfigScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerConfigOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerConfigWhereInput>;
};


export type ServerEventsAdminArgs = {
  cursor?: InputMaybe<EventAdminWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventAdminScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventAdminOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventAdminWhereInput>;
};


export type ServerEventsChangeNameArgs = {
  cursor?: InputMaybe<EventChangeNameWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeNameScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeNameOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeNameWhereInput>;
};


export type ServerEventsChangeRoleArgs = {
  cursor?: InputMaybe<EventChangeRoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeRoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeRoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeRoleWhereInput>;
};


export type ServerEventsChangeTeamArgs = {
  cursor?: InputMaybe<EventChangeTeamWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChangeTeamScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChangeTeamOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChangeTeamWhereInput>;
};


export type ServerEventsChatArgs = {
  cursor?: InputMaybe<EventChatWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventChatScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventChatOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventChatWhereInput>;
};


export type ServerEventsConnectArgs = {
  cursor?: InputMaybe<EventConnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventConnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventConnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventConnectWhereInput>;
};


export type ServerEventsDisconnectArgs = {
  cursor?: InputMaybe<EventDisconnectWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventDisconnectScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventDisconnectOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventDisconnectWhereInput>;
};


export type ServerEventsEntryArgs = {
  cursor?: InputMaybe<EventEntryWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventEntryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventEntryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventEntryWhereInput>;
};


export type ServerEventsFragArgs = {
  cursor?: InputMaybe<EventFragWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventFragScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventFragOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventFragWhereInput>;
};


export type ServerEventsLatencyArgs = {
  cursor?: InputMaybe<EventLatencyWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventLatencyScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventLatencyOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventLatencyWhereInput>;
};


export type ServerEventsPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerActionWhereInput>;
};


export type ServerEventsPlayerPlayerActionArgs = {
  cursor?: InputMaybe<EventPlayerPlayerActionWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventPlayerPlayerActionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventPlayerPlayerActionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventPlayerPlayerActionWhereInput>;
};


export type ServerEventsRconArgs = {
  cursor?: InputMaybe<EventRconWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventRconScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventRconOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventRconWhereInput>;
};


export type ServerEventsSuicideArgs = {
  cursor?: InputMaybe<EventSuicideWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventSuicideScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventSuicideOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventSuicideWhereInput>;
};


export type ServerEventsTeamBonusArgs = {
  cursor?: InputMaybe<EventTeamBonusWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamBonusScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamBonusOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamBonusWhereInput>;
};


export type ServerEventsTeamkillArgs = {
  cursor?: InputMaybe<EventTeamkillWhereUniqueInput>;
  distinct?: InputMaybe<Array<EventTeamkillScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<EventTeamkillOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EventTeamkillWhereInput>;
};


export type ServerLoadsArgs = {
  cursor?: InputMaybe<ServerLoadWhereUniqueInput>;
  distinct?: InputMaybe<Array<ServerLoadScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ServerLoadOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ServerLoadWhereInput>;
};

export type ServerAvgOrderByAggregateInput = {
  activePlayers?: InputMaybe<SortOrder>;
  bombsDefused?: InputMaybe<SortOrder>;
  bombsPlanted?: InputMaybe<SortOrder>;
  ctHits?: InputMaybe<SortOrder>;
  ctShots?: InputMaybe<SortOrder>;
  ctWins?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mapChanges?: InputMaybe<SortOrder>;
  mapCtHits?: InputMaybe<SortOrder>;
  mapCtShots?: InputMaybe<SortOrder>;
  mapCtWins?: InputMaybe<SortOrder>;
  mapRounds?: InputMaybe<SortOrder>;
  mapStarted?: InputMaybe<SortOrder>;
  mapTsHits?: InputMaybe<SortOrder>;
  mapTsShots?: InputMaybe<SortOrder>;
  mapTsWins?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  players?: InputMaybe<SortOrder>;
  port?: InputMaybe<SortOrder>;
  rounds?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  sortOrder?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  tsHits?: InputMaybe<SortOrder>;
  tsShots?: InputMaybe<SortOrder>;
  tsWins?: InputMaybe<SortOrder>;
};

export type ServerConfig = {
  __typename?: 'ServerConfig';
  parameter: Scalars['String']['output'];
  server: Server;
  serverConfigId: Scalars['Int']['output'];
  serverId: Scalars['Int']['output'];
  value: Scalars['String']['output'];
};

export type ServerConfigAvgOrderByAggregateInput = {
  serverConfigId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type ServerConfigCountOrderByAggregateInput = {
  parameter?: InputMaybe<SortOrder>;
  serverConfigId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ServerConfigCreateInput = {
  parameter: Scalars['String']['input'];
  server: ServerCreateNestedOneWithoutConfigsInput;
  serverConfigId?: InputMaybe<Scalars['Int']['input']>;
  value: Scalars['String']['input'];
};

export type ServerConfigCreateManyInput = {
  parameter: Scalars['String']['input'];
  serverConfigId?: InputMaybe<Scalars['Int']['input']>;
  serverId: Scalars['Int']['input'];
  value: Scalars['String']['input'];
};

export type ServerConfigCreateManyServerInput = {
  parameter: Scalars['String']['input'];
  serverConfigId?: InputMaybe<Scalars['Int']['input']>;
  value: Scalars['String']['input'];
};

export type ServerConfigCreateManyServerInputEnvelope = {
  data: Array<ServerConfigCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ServerConfigCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<ServerConfigWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ServerConfigCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<ServerConfigCreateWithoutServerInput>>;
  createMany?: InputMaybe<ServerConfigCreateManyServerInputEnvelope>;
};

export type ServerConfigCreateOrConnectWithoutServerInput = {
  create: ServerConfigCreateWithoutServerInput;
  where: ServerConfigWhereUniqueInput;
};

export type ServerConfigCreateWithoutServerInput = {
  parameter: Scalars['String']['input'];
  serverConfigId?: InputMaybe<Scalars['Int']['input']>;
  value: Scalars['String']['input'];
};

export type ServerConfigDefault = {
  __typename?: 'ServerConfigDefault';
  description?: Maybe<Scalars['String']['output']>;
  parameter: Scalars['ID']['output'];
  value: Scalars['String']['output'];
};

export type ServerConfigDefaultCountOrderByAggregateInput = {
  description?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ServerConfigDefaultCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  parameter: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ServerConfigDefaultCreateManyInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  parameter: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ServerConfigDefaultMaxOrderByAggregateInput = {
  description?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ServerConfigDefaultMinOrderByAggregateInput = {
  description?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum ServerConfigDefaultOrderByRelevanceFieldEnum {
  Description = 'description',
  Parameter = 'parameter',
  Value = 'value'
}

export type ServerConfigDefaultOrderByRelevanceInput = {
  fields: Array<ServerConfigDefaultOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ServerConfigDefaultOrderByWithAggregationInput = {
  _count?: InputMaybe<ServerConfigDefaultCountOrderByAggregateInput>;
  _max?: InputMaybe<ServerConfigDefaultMaxOrderByAggregateInput>;
  _min?: InputMaybe<ServerConfigDefaultMinOrderByAggregateInput>;
  description?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ServerConfigDefaultOrderByWithRelationInput = {
  _relevance?: InputMaybe<ServerConfigDefaultOrderByRelevanceInput>;
  description?: InputMaybe<SortOrder>;
  parameter?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum ServerConfigDefaultScalarFieldEnum {
  Description = 'description',
  Parameter = 'parameter',
  Value = 'value'
}

export type ServerConfigDefaultScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ServerConfigDefaultScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ServerConfigDefaultScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ServerConfigDefaultScalarWhereWithAggregatesInput>>;
  description?: InputMaybe<StringNullableWithAggregatesFilter>;
  parameter?: InputMaybe<StringWithAggregatesFilter>;
  value?: InputMaybe<StringWithAggregatesFilter>;
};

export type ServerConfigDefaultUpdateInput = {
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerConfigDefaultUpdateManyMutationInput = {
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerConfigDefaultWhereInput = {
  AND?: InputMaybe<Array<ServerConfigDefaultWhereInput>>;
  NOT?: InputMaybe<Array<ServerConfigDefaultWhereInput>>;
  OR?: InputMaybe<Array<ServerConfigDefaultWhereInput>>;
  description?: InputMaybe<StringNullableFilter>;
  parameter?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type ServerConfigDefaultWhereUniqueInput = {
  AND?: InputMaybe<Array<ServerConfigDefaultWhereInput>>;
  NOT?: InputMaybe<Array<ServerConfigDefaultWhereInput>>;
  OR?: InputMaybe<Array<ServerConfigDefaultWhereInput>>;
  description?: InputMaybe<StringNullableFilter>;
  parameter?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<StringFilter>;
};

export type ServerConfigListRelationFilter = {
  every?: InputMaybe<ServerConfigWhereInput>;
  none?: InputMaybe<ServerConfigWhereInput>;
  some?: InputMaybe<ServerConfigWhereInput>;
};

export type ServerConfigMaxOrderByAggregateInput = {
  parameter?: InputMaybe<SortOrder>;
  serverConfigId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ServerConfigMinOrderByAggregateInput = {
  parameter?: InputMaybe<SortOrder>;
  serverConfigId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ServerConfigOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum ServerConfigOrderByRelevanceFieldEnum {
  Parameter = 'parameter',
  Value = 'value'
}

export type ServerConfigOrderByRelevanceInput = {
  fields: Array<ServerConfigOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ServerConfigOrderByWithAggregationInput = {
  _avg?: InputMaybe<ServerConfigAvgOrderByAggregateInput>;
  _count?: InputMaybe<ServerConfigCountOrderByAggregateInput>;
  _max?: InputMaybe<ServerConfigMaxOrderByAggregateInput>;
  _min?: InputMaybe<ServerConfigMinOrderByAggregateInput>;
  _sum?: InputMaybe<ServerConfigSumOrderByAggregateInput>;
  parameter?: InputMaybe<SortOrder>;
  serverConfigId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type ServerConfigOrderByWithRelationInput = {
  _relevance?: InputMaybe<ServerConfigOrderByRelevanceInput>;
  parameter?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverConfigId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum ServerConfigScalarFieldEnum {
  Parameter = 'parameter',
  ServerConfigId = 'serverConfigId',
  ServerId = 'serverId',
  Value = 'value'
}

export type ServerConfigScalarWhereInput = {
  AND?: InputMaybe<Array<ServerConfigScalarWhereInput>>;
  NOT?: InputMaybe<Array<ServerConfigScalarWhereInput>>;
  OR?: InputMaybe<Array<ServerConfigScalarWhereInput>>;
  parameter?: InputMaybe<StringFilter>;
  serverConfigId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
  value?: InputMaybe<StringFilter>;
};

export type ServerConfigScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ServerConfigScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ServerConfigScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ServerConfigScalarWhereWithAggregatesInput>>;
  parameter?: InputMaybe<StringWithAggregatesFilter>;
  serverConfigId?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  value?: InputMaybe<StringWithAggregatesFilter>;
};

export type ServerConfigServerIdParameterCompoundUniqueInput = {
  parameter: Scalars['String']['input'];
  serverId: Scalars['Int']['input'];
};

export type ServerConfigSumOrderByAggregateInput = {
  serverConfigId?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
};

export type ServerConfigUpdateInput = {
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutConfigsNestedInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerConfigUpdateManyMutationInput = {
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerConfigUpdateManyWithWhereWithoutServerInput = {
  data: ServerConfigUpdateManyMutationInput;
  where: ServerConfigScalarWhereInput;
};

export type ServerConfigUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<ServerConfigWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ServerConfigCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<ServerConfigCreateWithoutServerInput>>;
  createMany?: InputMaybe<ServerConfigCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<ServerConfigWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ServerConfigScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ServerConfigWhereUniqueInput>>;
  set?: InputMaybe<Array<ServerConfigWhereUniqueInput>>;
  update?: InputMaybe<Array<ServerConfigUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<ServerConfigUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<ServerConfigUpsertWithWhereUniqueWithoutServerInput>>;
};

export type ServerConfigUpdateWithWhereUniqueWithoutServerInput = {
  data: ServerConfigUpdateWithoutServerInput;
  where: ServerConfigWhereUniqueInput;
};

export type ServerConfigUpdateWithoutServerInput = {
  parameter?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerConfigUpsertWithWhereUniqueWithoutServerInput = {
  create: ServerConfigCreateWithoutServerInput;
  update: ServerConfigUpdateWithoutServerInput;
  where: ServerConfigWhereUniqueInput;
};

export type ServerConfigWhereInput = {
  AND?: InputMaybe<Array<ServerConfigWhereInput>>;
  NOT?: InputMaybe<Array<ServerConfigWhereInput>>;
  OR?: InputMaybe<Array<ServerConfigWhereInput>>;
  parameter?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverConfigId?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
  value?: InputMaybe<StringFilter>;
};

export type ServerConfigWhereUniqueInput = {
  AND?: InputMaybe<Array<ServerConfigWhereInput>>;
  NOT?: InputMaybe<Array<ServerConfigWhereInput>>;
  OR?: InputMaybe<Array<ServerConfigWhereInput>>;
  parameter?: InputMaybe<StringFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverConfigId?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<IntFilter>;
  serverId_parameter?: InputMaybe<ServerConfigServerIdParameterCompoundUniqueInput>;
  value?: InputMaybe<StringFilter>;
};

export type ServerCountOrderByAggregateInput = {
  activeMap?: InputMaybe<SortOrder>;
  activePlayers?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  bombsDefused?: InputMaybe<SortOrder>;
  bombsPlanted?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  connectionType?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  ctHits?: InputMaybe<SortOrder>;
  ctShots?: InputMaybe<SortOrder>;
  ctWins?: InputMaybe<SortOrder>;
  dockerHost?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mapChanges?: InputMaybe<SortOrder>;
  mapCtHits?: InputMaybe<SortOrder>;
  mapCtShots?: InputMaybe<SortOrder>;
  mapCtWins?: InputMaybe<SortOrder>;
  mapRounds?: InputMaybe<SortOrder>;
  mapStarted?: InputMaybe<SortOrder>;
  mapTsHits?: InputMaybe<SortOrder>;
  mapTsShots?: InputMaybe<SortOrder>;
  mapTsWins?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  players?: InputMaybe<SortOrder>;
  port?: InputMaybe<SortOrder>;
  publicAddress?: InputMaybe<SortOrder>;
  rconPassword?: InputMaybe<SortOrder>;
  rounds?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  sortOrder?: InputMaybe<SortOrder>;
  statusUrl?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  tsHits?: InputMaybe<SortOrder>;
  tsShots?: InputMaybe<SortOrder>;
  tsWins?: InputMaybe<SortOrder>;
};

export type ServerCreateInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateManyInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateNestedOneWithoutConfigsInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutConfigsInput>;
  create?: InputMaybe<ServerCreateWithoutConfigsInput>;
};

export type ServerCreateNestedOneWithoutEventsAdminInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsAdminInput>;
  create?: InputMaybe<ServerCreateWithoutEventsAdminInput>;
};

export type ServerCreateNestedOneWithoutEventsChangeNameInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChangeNameInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChangeNameInput>;
};

export type ServerCreateNestedOneWithoutEventsChangeRoleInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChangeRoleInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChangeRoleInput>;
};

export type ServerCreateNestedOneWithoutEventsChangeTeamInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChangeTeamInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChangeTeamInput>;
};

export type ServerCreateNestedOneWithoutEventsChatInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChatInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChatInput>;
};

export type ServerCreateNestedOneWithoutEventsConnectInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsConnectInput>;
  create?: InputMaybe<ServerCreateWithoutEventsConnectInput>;
};

export type ServerCreateNestedOneWithoutEventsDisconnectInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsDisconnectInput>;
  create?: InputMaybe<ServerCreateWithoutEventsDisconnectInput>;
};

export type ServerCreateNestedOneWithoutEventsEntryInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsEntryInput>;
  create?: InputMaybe<ServerCreateWithoutEventsEntryInput>;
};

export type ServerCreateNestedOneWithoutEventsFragInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsFragInput>;
  create?: InputMaybe<ServerCreateWithoutEventsFragInput>;
};

export type ServerCreateNestedOneWithoutEventsLatencyInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsLatencyInput>;
  create?: InputMaybe<ServerCreateWithoutEventsLatencyInput>;
};

export type ServerCreateNestedOneWithoutEventsPlayerActionInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsPlayerActionInput>;
  create?: InputMaybe<ServerCreateWithoutEventsPlayerActionInput>;
};

export type ServerCreateNestedOneWithoutEventsPlayerPlayerActionInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsPlayerPlayerActionInput>;
  create?: InputMaybe<ServerCreateWithoutEventsPlayerPlayerActionInput>;
};

export type ServerCreateNestedOneWithoutEventsRconInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsRconInput>;
  create?: InputMaybe<ServerCreateWithoutEventsRconInput>;
};

export type ServerCreateNestedOneWithoutEventsSuicideInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsSuicideInput>;
  create?: InputMaybe<ServerCreateWithoutEventsSuicideInput>;
};

export type ServerCreateNestedOneWithoutEventsTeamBonusInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsTeamBonusInput>;
  create?: InputMaybe<ServerCreateWithoutEventsTeamBonusInput>;
};

export type ServerCreateNestedOneWithoutEventsTeamkillInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsTeamkillInput>;
  create?: InputMaybe<ServerCreateWithoutEventsTeamkillInput>;
};

export type ServerCreateNestedOneWithoutLoadsInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutLoadsInput>;
  create?: InputMaybe<ServerCreateWithoutLoadsInput>;
};

export type ServerCreateNestedOneWithoutNotificationConfigInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutNotificationConfigInput>;
  create?: InputMaybe<ServerCreateWithoutNotificationConfigInput>;
};

export type ServerCreateOrConnectWithoutConfigsInput = {
  create: ServerCreateWithoutConfigsInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsAdminInput = {
  create: ServerCreateWithoutEventsAdminInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsChangeNameInput = {
  create: ServerCreateWithoutEventsChangeNameInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsChangeRoleInput = {
  create: ServerCreateWithoutEventsChangeRoleInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsChangeTeamInput = {
  create: ServerCreateWithoutEventsChangeTeamInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsChatInput = {
  create: ServerCreateWithoutEventsChatInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsConnectInput = {
  create: ServerCreateWithoutEventsConnectInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsDisconnectInput = {
  create: ServerCreateWithoutEventsDisconnectInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsEntryInput = {
  create: ServerCreateWithoutEventsEntryInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsFragInput = {
  create: ServerCreateWithoutEventsFragInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsLatencyInput = {
  create: ServerCreateWithoutEventsLatencyInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsPlayerActionInput = {
  create: ServerCreateWithoutEventsPlayerActionInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsPlayerPlayerActionInput = {
  create: ServerCreateWithoutEventsPlayerPlayerActionInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsRconInput = {
  create: ServerCreateWithoutEventsRconInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsSuicideInput = {
  create: ServerCreateWithoutEventsSuicideInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsTeamBonusInput = {
  create: ServerCreateWithoutEventsTeamBonusInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutEventsTeamkillInput = {
  create: ServerCreateWithoutEventsTeamkillInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutLoadsInput = {
  create: ServerCreateWithoutLoadsInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateOrConnectWithoutNotificationConfigInput = {
  create: ServerCreateWithoutNotificationConfigInput;
  where: ServerWhereUniqueInput;
};

export type ServerCreateWithoutConfigsInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsAdminInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsChangeNameInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsChangeRoleInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsChangeTeamInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsChatInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsConnectInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsDisconnectInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsEntryInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsFragInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsLatencyInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsPlayerActionInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsPlayerPlayerActionInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsRconInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsSuicideInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsTeamBonusInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutEventsTeamkillInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutLoadsInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationConfig?: InputMaybe<NotificationConfigCreateNestedOneWithoutServerInput>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerCreateWithoutNotificationConfigInput = {
  activeMap?: InputMaybe<Scalars['String']['input']>;
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  bombsDefused?: InputMaybe<Scalars['Int']['input']>;
  bombsPlanted?: InputMaybe<Scalars['Int']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  configs?: InputMaybe<ServerConfigCreateNestedManyWithoutServerInput>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  ctHits?: InputMaybe<Scalars['Int']['input']>;
  ctShots?: InputMaybe<Scalars['Int']['input']>;
  ctWins?: InputMaybe<Scalars['Int']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  eventsAdmin?: InputMaybe<EventAdminCreateNestedManyWithoutServerInput>;
  eventsChangeName?: InputMaybe<EventChangeNameCreateNestedManyWithoutServerInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleCreateNestedManyWithoutServerInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamCreateNestedManyWithoutServerInput>;
  eventsChat?: InputMaybe<EventChatCreateNestedManyWithoutServerInput>;
  eventsConnect?: InputMaybe<EventConnectCreateNestedManyWithoutServerInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectCreateNestedManyWithoutServerInput>;
  eventsEntry?: InputMaybe<EventEntryCreateNestedManyWithoutServerInput>;
  eventsFrag?: InputMaybe<EventFragCreateNestedManyWithoutServerInput>;
  eventsLatency?: InputMaybe<EventLatencyCreateNestedManyWithoutServerInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionCreateNestedManyWithoutServerInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionCreateNestedManyWithoutServerInput>;
  eventsRcon?: InputMaybe<EventRconCreateNestedManyWithoutServerInput>;
  eventsSuicide?: InputMaybe<EventSuicideCreateNestedManyWithoutServerInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusCreateNestedManyWithoutServerInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillCreateNestedManyWithoutServerInput>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  lastEvent?: InputMaybe<Scalars['DateTime']['input']>;
  lat?: InputMaybe<Scalars['Float']['input']>;
  lng?: InputMaybe<Scalars['Float']['input']>;
  loads?: InputMaybe<ServerLoadCreateNestedManyWithoutServerInput>;
  mapChanges?: InputMaybe<Scalars['Int']['input']>;
  mapCtHits?: InputMaybe<Scalars['Int']['input']>;
  mapCtShots?: InputMaybe<Scalars['Int']['input']>;
  mapCtWins?: InputMaybe<Scalars['Int']['input']>;
  mapRounds?: InputMaybe<Scalars['Int']['input']>;
  mapStarted?: InputMaybe<Scalars['Int']['input']>;
  mapTsHits?: InputMaybe<Scalars['Int']['input']>;
  mapTsShots?: InputMaybe<Scalars['Int']['input']>;
  mapTsWins?: InputMaybe<Scalars['Int']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  players?: InputMaybe<Scalars['Int']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  rounds?: InputMaybe<Scalars['Int']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
  suicides?: InputMaybe<Scalars['Int']['input']>;
  tsHits?: InputMaybe<Scalars['Int']['input']>;
  tsShots?: InputMaybe<Scalars['Int']['input']>;
  tsWins?: InputMaybe<Scalars['Int']['input']>;
};

export type ServerLoad = {
  __typename?: 'ServerLoad';
  activePlayers: Scalars['Int']['output'];
  fps: Scalars['String']['output'];
  map?: Maybe<Scalars['String']['output']>;
  maxPlayers: Scalars['Int']['output'];
  minPlayers: Scalars['Int']['output'];
  server: Server;
  serverId: Scalars['Int']['output'];
  timestamp: Scalars['Int']['output'];
  uptime: Scalars['String']['output'];
};

export type ServerLoadAvgOrderByAggregateInput = {
  activePlayers?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  minPlayers?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
};

export type ServerLoadCountOrderByAggregateInput = {
  activePlayers?: InputMaybe<SortOrder>;
  fps?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  minPlayers?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  uptime?: InputMaybe<SortOrder>;
};

export type ServerLoadCreateInput = {
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  fps?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  minPlayers?: InputMaybe<Scalars['Int']['input']>;
  server?: InputMaybe<ServerCreateNestedOneWithoutLoadsInput>;
  timestamp?: InputMaybe<Scalars['Int']['input']>;
  uptime?: InputMaybe<Scalars['String']['input']>;
};

export type ServerLoadCreateManyInput = {
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  fps?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  minPlayers?: InputMaybe<Scalars['Int']['input']>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Int']['input']>;
  uptime?: InputMaybe<Scalars['String']['input']>;
};

export type ServerLoadCreateManyServerInput = {
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  fps?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  minPlayers?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Int']['input']>;
  uptime?: InputMaybe<Scalars['String']['input']>;
};

export type ServerLoadCreateManyServerInputEnvelope = {
  data: Array<ServerLoadCreateManyServerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ServerLoadCreateNestedManyWithoutServerInput = {
  connect?: InputMaybe<Array<ServerLoadWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ServerLoadCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<ServerLoadCreateWithoutServerInput>>;
  createMany?: InputMaybe<ServerLoadCreateManyServerInputEnvelope>;
};

export type ServerLoadCreateOrConnectWithoutServerInput = {
  create: ServerLoadCreateWithoutServerInput;
  where: ServerLoadWhereUniqueInput;
};

export type ServerLoadCreateWithoutServerInput = {
  activePlayers?: InputMaybe<Scalars['Int']['input']>;
  fps?: InputMaybe<Scalars['String']['input']>;
  map?: InputMaybe<Scalars['String']['input']>;
  maxPlayers?: InputMaybe<Scalars['Int']['input']>;
  minPlayers?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Int']['input']>;
  uptime?: InputMaybe<Scalars['String']['input']>;
};

export type ServerLoadListRelationFilter = {
  every?: InputMaybe<ServerLoadWhereInput>;
  none?: InputMaybe<ServerLoadWhereInput>;
  some?: InputMaybe<ServerLoadWhereInput>;
};

export type ServerLoadMaxOrderByAggregateInput = {
  activePlayers?: InputMaybe<SortOrder>;
  fps?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  minPlayers?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  uptime?: InputMaybe<SortOrder>;
};

export type ServerLoadMinOrderByAggregateInput = {
  activePlayers?: InputMaybe<SortOrder>;
  fps?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  minPlayers?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  uptime?: InputMaybe<SortOrder>;
};

export type ServerLoadOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum ServerLoadOrderByRelevanceFieldEnum {
  Fps = 'fps',
  Map = 'map',
  Uptime = 'uptime'
}

export type ServerLoadOrderByRelevanceInput = {
  fields: Array<ServerLoadOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ServerLoadOrderByWithAggregationInput = {
  _avg?: InputMaybe<ServerLoadAvgOrderByAggregateInput>;
  _count?: InputMaybe<ServerLoadCountOrderByAggregateInput>;
  _max?: InputMaybe<ServerLoadMaxOrderByAggregateInput>;
  _min?: InputMaybe<ServerLoadMinOrderByAggregateInput>;
  _sum?: InputMaybe<ServerLoadSumOrderByAggregateInput>;
  activePlayers?: InputMaybe<SortOrder>;
  fps?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  minPlayers?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  uptime?: InputMaybe<SortOrder>;
};

export type ServerLoadOrderByWithRelationInput = {
  _relevance?: InputMaybe<ServerLoadOrderByRelevanceInput>;
  activePlayers?: InputMaybe<SortOrder>;
  fps?: InputMaybe<SortOrder>;
  map?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  minPlayers?: InputMaybe<SortOrder>;
  server?: InputMaybe<ServerOrderByWithRelationInput>;
  serverId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
  uptime?: InputMaybe<SortOrder>;
};

export enum ServerLoadScalarFieldEnum {
  ActivePlayers = 'activePlayers',
  Fps = 'fps',
  Map = 'map',
  MaxPlayers = 'maxPlayers',
  MinPlayers = 'minPlayers',
  ServerId = 'serverId',
  Timestamp = 'timestamp',
  Uptime = 'uptime'
}

export type ServerLoadScalarWhereInput = {
  AND?: InputMaybe<Array<ServerLoadScalarWhereInput>>;
  NOT?: InputMaybe<Array<ServerLoadScalarWhereInput>>;
  OR?: InputMaybe<Array<ServerLoadScalarWhereInput>>;
  activePlayers?: InputMaybe<IntFilter>;
  fps?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringNullableFilter>;
  maxPlayers?: InputMaybe<IntFilter>;
  minPlayers?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
  timestamp?: InputMaybe<IntFilter>;
  uptime?: InputMaybe<StringFilter>;
};

export type ServerLoadScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ServerLoadScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ServerLoadScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ServerLoadScalarWhereWithAggregatesInput>>;
  activePlayers?: InputMaybe<IntWithAggregatesFilter>;
  fps?: InputMaybe<StringWithAggregatesFilter>;
  map?: InputMaybe<StringNullableWithAggregatesFilter>;
  maxPlayers?: InputMaybe<IntWithAggregatesFilter>;
  minPlayers?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  timestamp?: InputMaybe<IntWithAggregatesFilter>;
  uptime?: InputMaybe<StringWithAggregatesFilter>;
};

export type ServerLoadServerIdTimestampCompoundUniqueInput = {
  serverId: Scalars['Int']['input'];
  timestamp: Scalars['Int']['input'];
};

export type ServerLoadSumOrderByAggregateInput = {
  activePlayers?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  minPlayers?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  timestamp?: InputMaybe<SortOrder>;
};

export type ServerLoadUpdateInput = {
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  fps?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  minPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  server?: InputMaybe<ServerUpdateOneRequiredWithoutLoadsNestedInput>;
  timestamp?: InputMaybe<IntFieldUpdateOperationsInput>;
  uptime?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerLoadUpdateManyMutationInput = {
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  fps?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  minPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<IntFieldUpdateOperationsInput>;
  uptime?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerLoadUpdateManyWithWhereWithoutServerInput = {
  data: ServerLoadUpdateManyMutationInput;
  where: ServerLoadScalarWhereInput;
};

export type ServerLoadUpdateManyWithoutServerNestedInput = {
  connect?: InputMaybe<Array<ServerLoadWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ServerLoadCreateOrConnectWithoutServerInput>>;
  create?: InputMaybe<Array<ServerLoadCreateWithoutServerInput>>;
  createMany?: InputMaybe<ServerLoadCreateManyServerInputEnvelope>;
  delete?: InputMaybe<Array<ServerLoadWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ServerLoadScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ServerLoadWhereUniqueInput>>;
  set?: InputMaybe<Array<ServerLoadWhereUniqueInput>>;
  update?: InputMaybe<Array<ServerLoadUpdateWithWhereUniqueWithoutServerInput>>;
  updateMany?: InputMaybe<Array<ServerLoadUpdateManyWithWhereWithoutServerInput>>;
  upsert?: InputMaybe<Array<ServerLoadUpsertWithWhereUniqueWithoutServerInput>>;
};

export type ServerLoadUpdateWithWhereUniqueWithoutServerInput = {
  data: ServerLoadUpdateWithoutServerInput;
  where: ServerLoadWhereUniqueInput;
};

export type ServerLoadUpdateWithoutServerInput = {
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  fps?: InputMaybe<StringFieldUpdateOperationsInput>;
  map?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  minPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<IntFieldUpdateOperationsInput>;
  uptime?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ServerLoadUpsertWithWhereUniqueWithoutServerInput = {
  create: ServerLoadCreateWithoutServerInput;
  update: ServerLoadUpdateWithoutServerInput;
  where: ServerLoadWhereUniqueInput;
};

export type ServerLoadWhereInput = {
  AND?: InputMaybe<Array<ServerLoadWhereInput>>;
  NOT?: InputMaybe<Array<ServerLoadWhereInput>>;
  OR?: InputMaybe<Array<ServerLoadWhereInput>>;
  activePlayers?: InputMaybe<IntFilter>;
  fps?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringNullableFilter>;
  maxPlayers?: InputMaybe<IntFilter>;
  minPlayers?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  timestamp?: InputMaybe<IntFilter>;
  uptime?: InputMaybe<StringFilter>;
};

export type ServerLoadWhereUniqueInput = {
  AND?: InputMaybe<Array<ServerLoadWhereInput>>;
  NOT?: InputMaybe<Array<ServerLoadWhereInput>>;
  OR?: InputMaybe<Array<ServerLoadWhereInput>>;
  activePlayers?: InputMaybe<IntFilter>;
  fps?: InputMaybe<StringFilter>;
  map?: InputMaybe<StringNullableFilter>;
  maxPlayers?: InputMaybe<IntFilter>;
  minPlayers?: InputMaybe<IntFilter>;
  server?: InputMaybe<ServerWhereInput>;
  serverId?: InputMaybe<IntFilter>;
  serverId_timestamp?: InputMaybe<ServerLoadServerIdTimestampCompoundUniqueInput>;
  timestamp?: InputMaybe<IntFilter>;
  uptime?: InputMaybe<StringFilter>;
};

export type ServerMaxOrderByAggregateInput = {
  activeMap?: InputMaybe<SortOrder>;
  activePlayers?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  bombsDefused?: InputMaybe<SortOrder>;
  bombsPlanted?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  connectionType?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  ctHits?: InputMaybe<SortOrder>;
  ctShots?: InputMaybe<SortOrder>;
  ctWins?: InputMaybe<SortOrder>;
  dockerHost?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mapChanges?: InputMaybe<SortOrder>;
  mapCtHits?: InputMaybe<SortOrder>;
  mapCtShots?: InputMaybe<SortOrder>;
  mapCtWins?: InputMaybe<SortOrder>;
  mapRounds?: InputMaybe<SortOrder>;
  mapStarted?: InputMaybe<SortOrder>;
  mapTsHits?: InputMaybe<SortOrder>;
  mapTsShots?: InputMaybe<SortOrder>;
  mapTsWins?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  players?: InputMaybe<SortOrder>;
  port?: InputMaybe<SortOrder>;
  publicAddress?: InputMaybe<SortOrder>;
  rconPassword?: InputMaybe<SortOrder>;
  rounds?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  sortOrder?: InputMaybe<SortOrder>;
  statusUrl?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  tsHits?: InputMaybe<SortOrder>;
  tsShots?: InputMaybe<SortOrder>;
  tsWins?: InputMaybe<SortOrder>;
};

export type ServerMinOrderByAggregateInput = {
  activeMap?: InputMaybe<SortOrder>;
  activePlayers?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  bombsDefused?: InputMaybe<SortOrder>;
  bombsPlanted?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  connectionType?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  ctHits?: InputMaybe<SortOrder>;
  ctShots?: InputMaybe<SortOrder>;
  ctWins?: InputMaybe<SortOrder>;
  dockerHost?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mapChanges?: InputMaybe<SortOrder>;
  mapCtHits?: InputMaybe<SortOrder>;
  mapCtShots?: InputMaybe<SortOrder>;
  mapCtWins?: InputMaybe<SortOrder>;
  mapRounds?: InputMaybe<SortOrder>;
  mapStarted?: InputMaybe<SortOrder>;
  mapTsHits?: InputMaybe<SortOrder>;
  mapTsShots?: InputMaybe<SortOrder>;
  mapTsWins?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  players?: InputMaybe<SortOrder>;
  port?: InputMaybe<SortOrder>;
  publicAddress?: InputMaybe<SortOrder>;
  rconPassword?: InputMaybe<SortOrder>;
  rounds?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  sortOrder?: InputMaybe<SortOrder>;
  statusUrl?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  tsHits?: InputMaybe<SortOrder>;
  tsShots?: InputMaybe<SortOrder>;
  tsWins?: InputMaybe<SortOrder>;
};

export type ServerOperationResult = {
  __typename?: 'ServerOperationResult';
  configsCount?: Maybe<Scalars['Int']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  server?: Maybe<SafeServer>;
  success?: Maybe<Scalars['Boolean']['output']>;
};

export enum ServerOrderByRelevanceFieldEnum {
  ActiveMap = 'activeMap',
  Address = 'address',
  City = 'city',
  ConnectionType = 'connectionType',
  Country = 'country',
  DockerHost = 'dockerHost',
  Game = 'game',
  Name = 'name',
  PublicAddress = 'publicAddress',
  RconPassword = 'rconPassword',
  StatusUrl = 'statusUrl'
}

export type ServerOrderByRelevanceInput = {
  fields: Array<ServerOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type ServerOrderByWithAggregationInput = {
  _avg?: InputMaybe<ServerAvgOrderByAggregateInput>;
  _count?: InputMaybe<ServerCountOrderByAggregateInput>;
  _max?: InputMaybe<ServerMaxOrderByAggregateInput>;
  _min?: InputMaybe<ServerMinOrderByAggregateInput>;
  _sum?: InputMaybe<ServerSumOrderByAggregateInput>;
  activeMap?: InputMaybe<SortOrder>;
  activePlayers?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  bombsDefused?: InputMaybe<SortOrder>;
  bombsPlanted?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  connectionType?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  ctHits?: InputMaybe<SortOrder>;
  ctShots?: InputMaybe<SortOrder>;
  ctWins?: InputMaybe<SortOrder>;
  dockerHost?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mapChanges?: InputMaybe<SortOrder>;
  mapCtHits?: InputMaybe<SortOrder>;
  mapCtShots?: InputMaybe<SortOrder>;
  mapCtWins?: InputMaybe<SortOrder>;
  mapRounds?: InputMaybe<SortOrder>;
  mapStarted?: InputMaybe<SortOrder>;
  mapTsHits?: InputMaybe<SortOrder>;
  mapTsShots?: InputMaybe<SortOrder>;
  mapTsWins?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  players?: InputMaybe<SortOrder>;
  port?: InputMaybe<SortOrder>;
  publicAddress?: InputMaybe<SortOrder>;
  rconPassword?: InputMaybe<SortOrder>;
  rounds?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  sortOrder?: InputMaybe<SortOrder>;
  statusUrl?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  tsHits?: InputMaybe<SortOrder>;
  tsShots?: InputMaybe<SortOrder>;
  tsWins?: InputMaybe<SortOrder>;
};

export type ServerOrderByWithRelationInput = {
  _relevance?: InputMaybe<ServerOrderByRelevanceInput>;
  activeMap?: InputMaybe<SortOrder>;
  activePlayers?: InputMaybe<SortOrder>;
  address?: InputMaybe<SortOrder>;
  bombsDefused?: InputMaybe<SortOrder>;
  bombsPlanted?: InputMaybe<SortOrder>;
  city?: InputMaybe<SortOrder>;
  configs?: InputMaybe<ServerConfigOrderByRelationAggregateInput>;
  connectionType?: InputMaybe<SortOrder>;
  country?: InputMaybe<SortOrder>;
  ctHits?: InputMaybe<SortOrder>;
  ctShots?: InputMaybe<SortOrder>;
  ctWins?: InputMaybe<SortOrder>;
  dockerHost?: InputMaybe<SortOrder>;
  eventsAdmin?: InputMaybe<EventAdminOrderByRelationAggregateInput>;
  eventsChangeName?: InputMaybe<EventChangeNameOrderByRelationAggregateInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleOrderByRelationAggregateInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamOrderByRelationAggregateInput>;
  eventsChat?: InputMaybe<EventChatOrderByRelationAggregateInput>;
  eventsConnect?: InputMaybe<EventConnectOrderByRelationAggregateInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectOrderByRelationAggregateInput>;
  eventsEntry?: InputMaybe<EventEntryOrderByRelationAggregateInput>;
  eventsFrag?: InputMaybe<EventFragOrderByRelationAggregateInput>;
  eventsLatency?: InputMaybe<EventLatencyOrderByRelationAggregateInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionOrderByRelationAggregateInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionOrderByRelationAggregateInput>;
  eventsRcon?: InputMaybe<EventRconOrderByRelationAggregateInput>;
  eventsSuicide?: InputMaybe<EventSuicideOrderByRelationAggregateInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusOrderByRelationAggregateInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillOrderByRelationAggregateInput>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lastEvent?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  loads?: InputMaybe<ServerLoadOrderByRelationAggregateInput>;
  mapChanges?: InputMaybe<SortOrder>;
  mapCtHits?: InputMaybe<SortOrder>;
  mapCtShots?: InputMaybe<SortOrder>;
  mapCtWins?: InputMaybe<SortOrder>;
  mapRounds?: InputMaybe<SortOrder>;
  mapStarted?: InputMaybe<SortOrder>;
  mapTsHits?: InputMaybe<SortOrder>;
  mapTsShots?: InputMaybe<SortOrder>;
  mapTsWins?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  notificationConfig?: InputMaybe<NotificationConfigOrderByWithRelationInput>;
  players?: InputMaybe<SortOrder>;
  port?: InputMaybe<SortOrder>;
  publicAddress?: InputMaybe<SortOrder>;
  rconPassword?: InputMaybe<SortOrder>;
  rounds?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  sortOrder?: InputMaybe<SortOrder>;
  statusUrl?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  tsHits?: InputMaybe<SortOrder>;
  tsShots?: InputMaybe<SortOrder>;
  tsWins?: InputMaybe<SortOrder>;
};

export enum ServerScalarFieldEnum {
  ActiveMap = 'activeMap',
  ActivePlayers = 'activePlayers',
  Address = 'address',
  BombsDefused = 'bombsDefused',
  BombsPlanted = 'bombsPlanted',
  City = 'city',
  ConnectionType = 'connectionType',
  Country = 'country',
  CtHits = 'ctHits',
  CtShots = 'ctShots',
  CtWins = 'ctWins',
  DockerHost = 'dockerHost',
  Game = 'game',
  Headshots = 'headshots',
  Kills = 'kills',
  LastEvent = 'lastEvent',
  Lat = 'lat',
  Lng = 'lng',
  MapChanges = 'mapChanges',
  MapCtHits = 'mapCtHits',
  MapCtShots = 'mapCtShots',
  MapCtWins = 'mapCtWins',
  MapRounds = 'mapRounds',
  MapStarted = 'mapStarted',
  MapTsHits = 'mapTsHits',
  MapTsShots = 'mapTsShots',
  MapTsWins = 'mapTsWins',
  MaxPlayers = 'maxPlayers',
  Name = 'name',
  Players = 'players',
  Port = 'port',
  PublicAddress = 'publicAddress',
  RconPassword = 'rconPassword',
  Rounds = 'rounds',
  ServerId = 'serverId',
  SortOrder = 'sortOrder',
  StatusUrl = 'statusUrl',
  Suicides = 'suicides',
  TsHits = 'tsHits',
  TsShots = 'tsShots',
  TsWins = 'tsWins'
}

export type ServerScalarRelationFilter = {
  is?: InputMaybe<ServerWhereInput>;
  isNot?: InputMaybe<ServerWhereInput>;
};

export type ServerScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ServerScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ServerScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ServerScalarWhereWithAggregatesInput>>;
  activeMap?: InputMaybe<StringWithAggregatesFilter>;
  activePlayers?: InputMaybe<IntWithAggregatesFilter>;
  address?: InputMaybe<StringWithAggregatesFilter>;
  bombsDefused?: InputMaybe<IntWithAggregatesFilter>;
  bombsPlanted?: InputMaybe<IntWithAggregatesFilter>;
  city?: InputMaybe<StringWithAggregatesFilter>;
  connectionType?: InputMaybe<StringWithAggregatesFilter>;
  country?: InputMaybe<StringWithAggregatesFilter>;
  ctHits?: InputMaybe<IntWithAggregatesFilter>;
  ctShots?: InputMaybe<IntWithAggregatesFilter>;
  ctWins?: InputMaybe<IntWithAggregatesFilter>;
  dockerHost?: InputMaybe<StringNullableWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  headshots?: InputMaybe<IntWithAggregatesFilter>;
  kills?: InputMaybe<IntWithAggregatesFilter>;
  lastEvent?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  lat?: InputMaybe<FloatNullableWithAggregatesFilter>;
  lng?: InputMaybe<FloatNullableWithAggregatesFilter>;
  mapChanges?: InputMaybe<IntWithAggregatesFilter>;
  mapCtHits?: InputMaybe<IntWithAggregatesFilter>;
  mapCtShots?: InputMaybe<IntWithAggregatesFilter>;
  mapCtWins?: InputMaybe<IntWithAggregatesFilter>;
  mapRounds?: InputMaybe<IntWithAggregatesFilter>;
  mapStarted?: InputMaybe<IntWithAggregatesFilter>;
  mapTsHits?: InputMaybe<IntWithAggregatesFilter>;
  mapTsShots?: InputMaybe<IntWithAggregatesFilter>;
  mapTsWins?: InputMaybe<IntWithAggregatesFilter>;
  maxPlayers?: InputMaybe<IntWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  players?: InputMaybe<IntWithAggregatesFilter>;
  port?: InputMaybe<IntWithAggregatesFilter>;
  publicAddress?: InputMaybe<StringWithAggregatesFilter>;
  rconPassword?: InputMaybe<StringWithAggregatesFilter>;
  rounds?: InputMaybe<IntWithAggregatesFilter>;
  serverId?: InputMaybe<IntWithAggregatesFilter>;
  sortOrder?: InputMaybe<IntWithAggregatesFilter>;
  statusUrl?: InputMaybe<StringNullableWithAggregatesFilter>;
  suicides?: InputMaybe<IntWithAggregatesFilter>;
  tsHits?: InputMaybe<IntWithAggregatesFilter>;
  tsShots?: InputMaybe<IntWithAggregatesFilter>;
  tsWins?: InputMaybe<IntWithAggregatesFilter>;
};

export type ServerServers_Docker_UniqueCompoundUniqueInput = {
  connectionType: Scalars['String']['input'];
  dockerHost: Scalars['String']['input'];
  port: Scalars['Int']['input'];
};

export type ServerServers_External_UniqueCompoundUniqueInput = {
  address: Scalars['String']['input'];
  connectionType: Scalars['String']['input'];
  port: Scalars['Int']['input'];
};

export type ServerSumOrderByAggregateInput = {
  activePlayers?: InputMaybe<SortOrder>;
  bombsDefused?: InputMaybe<SortOrder>;
  bombsPlanted?: InputMaybe<SortOrder>;
  ctHits?: InputMaybe<SortOrder>;
  ctShots?: InputMaybe<SortOrder>;
  ctWins?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  lat?: InputMaybe<SortOrder>;
  lng?: InputMaybe<SortOrder>;
  mapChanges?: InputMaybe<SortOrder>;
  mapCtHits?: InputMaybe<SortOrder>;
  mapCtShots?: InputMaybe<SortOrder>;
  mapCtWins?: InputMaybe<SortOrder>;
  mapRounds?: InputMaybe<SortOrder>;
  mapStarted?: InputMaybe<SortOrder>;
  mapTsHits?: InputMaybe<SortOrder>;
  mapTsShots?: InputMaybe<SortOrder>;
  mapTsWins?: InputMaybe<SortOrder>;
  maxPlayers?: InputMaybe<SortOrder>;
  players?: InputMaybe<SortOrder>;
  port?: InputMaybe<SortOrder>;
  rounds?: InputMaybe<SortOrder>;
  serverId?: InputMaybe<SortOrder>;
  sortOrder?: InputMaybe<SortOrder>;
  suicides?: InputMaybe<SortOrder>;
  tsHits?: InputMaybe<SortOrder>;
  tsShots?: InputMaybe<SortOrder>;
  tsWins?: InputMaybe<SortOrder>;
};

export type ServerUpdateInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateManyMutationInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateOneRequiredWithoutConfigsNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutConfigsInput>;
  create?: InputMaybe<ServerCreateWithoutConfigsInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutConfigsInput>;
  upsert?: InputMaybe<ServerUpsertWithoutConfigsInput>;
};

export type ServerUpdateOneRequiredWithoutEventsAdminNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsAdminInput>;
  create?: InputMaybe<ServerCreateWithoutEventsAdminInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsAdminInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsAdminInput>;
};

export type ServerUpdateOneRequiredWithoutEventsChangeNameNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChangeNameInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChangeNameInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsChangeNameInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsChangeNameInput>;
};

export type ServerUpdateOneRequiredWithoutEventsChangeRoleNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChangeRoleInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChangeRoleInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsChangeRoleInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsChangeRoleInput>;
};

export type ServerUpdateOneRequiredWithoutEventsChangeTeamNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChangeTeamInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChangeTeamInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsChangeTeamInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsChangeTeamInput>;
};

export type ServerUpdateOneRequiredWithoutEventsChatNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsChatInput>;
  create?: InputMaybe<ServerCreateWithoutEventsChatInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsChatInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsChatInput>;
};

export type ServerUpdateOneRequiredWithoutEventsConnectNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsConnectInput>;
  create?: InputMaybe<ServerCreateWithoutEventsConnectInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsConnectInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsConnectInput>;
};

export type ServerUpdateOneRequiredWithoutEventsDisconnectNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsDisconnectInput>;
  create?: InputMaybe<ServerCreateWithoutEventsDisconnectInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsDisconnectInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsDisconnectInput>;
};

export type ServerUpdateOneRequiredWithoutEventsEntryNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsEntryInput>;
  create?: InputMaybe<ServerCreateWithoutEventsEntryInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsEntryInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsEntryInput>;
};

export type ServerUpdateOneRequiredWithoutEventsFragNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsFragInput>;
  create?: InputMaybe<ServerCreateWithoutEventsFragInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsFragInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsFragInput>;
};

export type ServerUpdateOneRequiredWithoutEventsLatencyNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsLatencyInput>;
  create?: InputMaybe<ServerCreateWithoutEventsLatencyInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsLatencyInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsLatencyInput>;
};

export type ServerUpdateOneRequiredWithoutEventsPlayerActionNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsPlayerActionInput>;
  create?: InputMaybe<ServerCreateWithoutEventsPlayerActionInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsPlayerActionInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsPlayerActionInput>;
};

export type ServerUpdateOneRequiredWithoutEventsPlayerPlayerActionNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsPlayerPlayerActionInput>;
  create?: InputMaybe<ServerCreateWithoutEventsPlayerPlayerActionInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsPlayerPlayerActionInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsPlayerPlayerActionInput>;
};

export type ServerUpdateOneRequiredWithoutEventsRconNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsRconInput>;
  create?: InputMaybe<ServerCreateWithoutEventsRconInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsRconInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsRconInput>;
};

export type ServerUpdateOneRequiredWithoutEventsSuicideNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsSuicideInput>;
  create?: InputMaybe<ServerCreateWithoutEventsSuicideInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsSuicideInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsSuicideInput>;
};

export type ServerUpdateOneRequiredWithoutEventsTeamBonusNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsTeamBonusInput>;
  create?: InputMaybe<ServerCreateWithoutEventsTeamBonusInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsTeamBonusInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsTeamBonusInput>;
};

export type ServerUpdateOneRequiredWithoutEventsTeamkillNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutEventsTeamkillInput>;
  create?: InputMaybe<ServerCreateWithoutEventsTeamkillInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutEventsTeamkillInput>;
  upsert?: InputMaybe<ServerUpsertWithoutEventsTeamkillInput>;
};

export type ServerUpdateOneRequiredWithoutLoadsNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutLoadsInput>;
  create?: InputMaybe<ServerCreateWithoutLoadsInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutLoadsInput>;
  upsert?: InputMaybe<ServerUpsertWithoutLoadsInput>;
};

export type ServerUpdateOneRequiredWithoutNotificationConfigNestedInput = {
  connect?: InputMaybe<ServerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ServerCreateOrConnectWithoutNotificationConfigInput>;
  create?: InputMaybe<ServerCreateWithoutNotificationConfigInput>;
  update?: InputMaybe<ServerUpdateToOneWithWhereWithoutNotificationConfigInput>;
  upsert?: InputMaybe<ServerUpsertWithoutNotificationConfigInput>;
};

export type ServerUpdateToOneWithWhereWithoutConfigsInput = {
  data: ServerUpdateWithoutConfigsInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsAdminInput = {
  data: ServerUpdateWithoutEventsAdminInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsChangeNameInput = {
  data: ServerUpdateWithoutEventsChangeNameInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsChangeRoleInput = {
  data: ServerUpdateWithoutEventsChangeRoleInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsChangeTeamInput = {
  data: ServerUpdateWithoutEventsChangeTeamInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsChatInput = {
  data: ServerUpdateWithoutEventsChatInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsConnectInput = {
  data: ServerUpdateWithoutEventsConnectInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsDisconnectInput = {
  data: ServerUpdateWithoutEventsDisconnectInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsEntryInput = {
  data: ServerUpdateWithoutEventsEntryInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsFragInput = {
  data: ServerUpdateWithoutEventsFragInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsLatencyInput = {
  data: ServerUpdateWithoutEventsLatencyInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsPlayerActionInput = {
  data: ServerUpdateWithoutEventsPlayerActionInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsPlayerPlayerActionInput = {
  data: ServerUpdateWithoutEventsPlayerPlayerActionInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsRconInput = {
  data: ServerUpdateWithoutEventsRconInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsSuicideInput = {
  data: ServerUpdateWithoutEventsSuicideInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsTeamBonusInput = {
  data: ServerUpdateWithoutEventsTeamBonusInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutEventsTeamkillInput = {
  data: ServerUpdateWithoutEventsTeamkillInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutLoadsInput = {
  data: ServerUpdateWithoutLoadsInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateToOneWithWhereWithoutNotificationConfigInput = {
  data: ServerUpdateWithoutNotificationConfigInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpdateWithoutConfigsInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsAdminInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsChangeNameInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsChangeRoleInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsChangeTeamInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsChatInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsConnectInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsDisconnectInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsEntryInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsFragInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsLatencyInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsPlayerActionInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsPlayerPlayerActionInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsRconInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsSuicideInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsTeamBonusInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutEventsTeamkillInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutLoadsInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notificationConfig?: InputMaybe<NotificationConfigUpdateOneWithoutServerNestedInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpdateWithoutNotificationConfigInput = {
  activeMap?: InputMaybe<StringFieldUpdateOperationsInput>;
  activePlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  address?: InputMaybe<StringFieldUpdateOperationsInput>;
  bombsDefused?: InputMaybe<IntFieldUpdateOperationsInput>;
  bombsPlanted?: InputMaybe<IntFieldUpdateOperationsInput>;
  city?: InputMaybe<StringFieldUpdateOperationsInput>;
  configs?: InputMaybe<ServerConfigUpdateManyWithoutServerNestedInput>;
  connectionType?: InputMaybe<StringFieldUpdateOperationsInput>;
  country?: InputMaybe<StringFieldUpdateOperationsInput>;
  ctHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  ctWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  dockerHost?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  eventsAdmin?: InputMaybe<EventAdminUpdateManyWithoutServerNestedInput>;
  eventsChangeName?: InputMaybe<EventChangeNameUpdateManyWithoutServerNestedInput>;
  eventsChangeRole?: InputMaybe<EventChangeRoleUpdateManyWithoutServerNestedInput>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamUpdateManyWithoutServerNestedInput>;
  eventsChat?: InputMaybe<EventChatUpdateManyWithoutServerNestedInput>;
  eventsConnect?: InputMaybe<EventConnectUpdateManyWithoutServerNestedInput>;
  eventsDisconnect?: InputMaybe<EventDisconnectUpdateManyWithoutServerNestedInput>;
  eventsEntry?: InputMaybe<EventEntryUpdateManyWithoutServerNestedInput>;
  eventsFrag?: InputMaybe<EventFragUpdateManyWithoutServerNestedInput>;
  eventsLatency?: InputMaybe<EventLatencyUpdateManyWithoutServerNestedInput>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionUpdateManyWithoutServerNestedInput>;
  eventsRcon?: InputMaybe<EventRconUpdateManyWithoutServerNestedInput>;
  eventsSuicide?: InputMaybe<EventSuicideUpdateManyWithoutServerNestedInput>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusUpdateManyWithoutServerNestedInput>;
  eventsTeamkill?: InputMaybe<EventTeamkillUpdateManyWithoutServerNestedInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  lastEvent?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  lat?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  lng?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  loads?: InputMaybe<ServerLoadUpdateManyWithoutServerNestedInput>;
  mapChanges?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapCtWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapRounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapStarted?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  mapTsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
  maxPlayers?: InputMaybe<IntFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  players?: InputMaybe<IntFieldUpdateOperationsInput>;
  port?: InputMaybe<IntFieldUpdateOperationsInput>;
  publicAddress?: InputMaybe<StringFieldUpdateOperationsInput>;
  rconPassword?: InputMaybe<StringFieldUpdateOperationsInput>;
  rounds?: InputMaybe<IntFieldUpdateOperationsInput>;
  sortOrder?: InputMaybe<IntFieldUpdateOperationsInput>;
  statusUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  suicides?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsHits?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsShots?: InputMaybe<IntFieldUpdateOperationsInput>;
  tsWins?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ServerUpsertWithoutConfigsInput = {
  create: ServerCreateWithoutConfigsInput;
  update: ServerUpdateWithoutConfigsInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsAdminInput = {
  create: ServerCreateWithoutEventsAdminInput;
  update: ServerUpdateWithoutEventsAdminInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsChangeNameInput = {
  create: ServerCreateWithoutEventsChangeNameInput;
  update: ServerUpdateWithoutEventsChangeNameInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsChangeRoleInput = {
  create: ServerCreateWithoutEventsChangeRoleInput;
  update: ServerUpdateWithoutEventsChangeRoleInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsChangeTeamInput = {
  create: ServerCreateWithoutEventsChangeTeamInput;
  update: ServerUpdateWithoutEventsChangeTeamInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsChatInput = {
  create: ServerCreateWithoutEventsChatInput;
  update: ServerUpdateWithoutEventsChatInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsConnectInput = {
  create: ServerCreateWithoutEventsConnectInput;
  update: ServerUpdateWithoutEventsConnectInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsDisconnectInput = {
  create: ServerCreateWithoutEventsDisconnectInput;
  update: ServerUpdateWithoutEventsDisconnectInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsEntryInput = {
  create: ServerCreateWithoutEventsEntryInput;
  update: ServerUpdateWithoutEventsEntryInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsFragInput = {
  create: ServerCreateWithoutEventsFragInput;
  update: ServerUpdateWithoutEventsFragInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsLatencyInput = {
  create: ServerCreateWithoutEventsLatencyInput;
  update: ServerUpdateWithoutEventsLatencyInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsPlayerActionInput = {
  create: ServerCreateWithoutEventsPlayerActionInput;
  update: ServerUpdateWithoutEventsPlayerActionInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsPlayerPlayerActionInput = {
  create: ServerCreateWithoutEventsPlayerPlayerActionInput;
  update: ServerUpdateWithoutEventsPlayerPlayerActionInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsRconInput = {
  create: ServerCreateWithoutEventsRconInput;
  update: ServerUpdateWithoutEventsRconInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsSuicideInput = {
  create: ServerCreateWithoutEventsSuicideInput;
  update: ServerUpdateWithoutEventsSuicideInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsTeamBonusInput = {
  create: ServerCreateWithoutEventsTeamBonusInput;
  update: ServerUpdateWithoutEventsTeamBonusInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutEventsTeamkillInput = {
  create: ServerCreateWithoutEventsTeamkillInput;
  update: ServerUpdateWithoutEventsTeamkillInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutLoadsInput = {
  create: ServerCreateWithoutLoadsInput;
  update: ServerUpdateWithoutLoadsInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerUpsertWithoutNotificationConfigInput = {
  create: ServerCreateWithoutNotificationConfigInput;
  update: ServerUpdateWithoutNotificationConfigInput;
  where?: InputMaybe<ServerWhereInput>;
};

export type ServerWhereInput = {
  AND?: InputMaybe<Array<ServerWhereInput>>;
  NOT?: InputMaybe<Array<ServerWhereInput>>;
  OR?: InputMaybe<Array<ServerWhereInput>>;
  activeMap?: InputMaybe<StringFilter>;
  activePlayers?: InputMaybe<IntFilter>;
  address?: InputMaybe<StringFilter>;
  bombsDefused?: InputMaybe<IntFilter>;
  bombsPlanted?: InputMaybe<IntFilter>;
  city?: InputMaybe<StringFilter>;
  configs?: InputMaybe<ServerConfigListRelationFilter>;
  connectionType?: InputMaybe<StringFilter>;
  country?: InputMaybe<StringFilter>;
  ctHits?: InputMaybe<IntFilter>;
  ctShots?: InputMaybe<IntFilter>;
  ctWins?: InputMaybe<IntFilter>;
  dockerHost?: InputMaybe<StringNullableFilter>;
  eventsAdmin?: InputMaybe<EventAdminListRelationFilter>;
  eventsChangeName?: InputMaybe<EventChangeNameListRelationFilter>;
  eventsChangeRole?: InputMaybe<EventChangeRoleListRelationFilter>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamListRelationFilter>;
  eventsChat?: InputMaybe<EventChatListRelationFilter>;
  eventsConnect?: InputMaybe<EventConnectListRelationFilter>;
  eventsDisconnect?: InputMaybe<EventDisconnectListRelationFilter>;
  eventsEntry?: InputMaybe<EventEntryListRelationFilter>;
  eventsFrag?: InputMaybe<EventFragListRelationFilter>;
  eventsLatency?: InputMaybe<EventLatencyListRelationFilter>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionListRelationFilter>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  eventsRcon?: InputMaybe<EventRconListRelationFilter>;
  eventsSuicide?: InputMaybe<EventSuicideListRelationFilter>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusListRelationFilter>;
  eventsTeamkill?: InputMaybe<EventTeamkillListRelationFilter>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastEvent?: InputMaybe<DateTimeNullableFilter>;
  lat?: InputMaybe<FloatNullableFilter>;
  lng?: InputMaybe<FloatNullableFilter>;
  loads?: InputMaybe<ServerLoadListRelationFilter>;
  mapChanges?: InputMaybe<IntFilter>;
  mapCtHits?: InputMaybe<IntFilter>;
  mapCtShots?: InputMaybe<IntFilter>;
  mapCtWins?: InputMaybe<IntFilter>;
  mapRounds?: InputMaybe<IntFilter>;
  mapStarted?: InputMaybe<IntFilter>;
  mapTsHits?: InputMaybe<IntFilter>;
  mapTsShots?: InputMaybe<IntFilter>;
  mapTsWins?: InputMaybe<IntFilter>;
  maxPlayers?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  notificationConfig?: InputMaybe<NotificationConfigWhereInput>;
  players?: InputMaybe<IntFilter>;
  port?: InputMaybe<IntFilter>;
  publicAddress?: InputMaybe<StringFilter>;
  rconPassword?: InputMaybe<StringFilter>;
  rounds?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<IntFilter>;
  sortOrder?: InputMaybe<IntFilter>;
  statusUrl?: InputMaybe<StringNullableFilter>;
  suicides?: InputMaybe<IntFilter>;
  tsHits?: InputMaybe<IntFilter>;
  tsShots?: InputMaybe<IntFilter>;
  tsWins?: InputMaybe<IntFilter>;
};

export type ServerWhereUniqueInput = {
  AND?: InputMaybe<Array<ServerWhereInput>>;
  NOT?: InputMaybe<Array<ServerWhereInput>>;
  OR?: InputMaybe<Array<ServerWhereInput>>;
  activeMap?: InputMaybe<StringFilter>;
  activePlayers?: InputMaybe<IntFilter>;
  address?: InputMaybe<StringFilter>;
  bombsDefused?: InputMaybe<IntFilter>;
  bombsPlanted?: InputMaybe<IntFilter>;
  city?: InputMaybe<StringFilter>;
  configs?: InputMaybe<ServerConfigListRelationFilter>;
  connectionType?: InputMaybe<StringFilter>;
  country?: InputMaybe<StringFilter>;
  ctHits?: InputMaybe<IntFilter>;
  ctShots?: InputMaybe<IntFilter>;
  ctWins?: InputMaybe<IntFilter>;
  dockerHost?: InputMaybe<StringNullableFilter>;
  eventsAdmin?: InputMaybe<EventAdminListRelationFilter>;
  eventsChangeName?: InputMaybe<EventChangeNameListRelationFilter>;
  eventsChangeRole?: InputMaybe<EventChangeRoleListRelationFilter>;
  eventsChangeTeam?: InputMaybe<EventChangeTeamListRelationFilter>;
  eventsChat?: InputMaybe<EventChatListRelationFilter>;
  eventsConnect?: InputMaybe<EventConnectListRelationFilter>;
  eventsDisconnect?: InputMaybe<EventDisconnectListRelationFilter>;
  eventsEntry?: InputMaybe<EventEntryListRelationFilter>;
  eventsFrag?: InputMaybe<EventFragListRelationFilter>;
  eventsLatency?: InputMaybe<EventLatencyListRelationFilter>;
  eventsPlayerAction?: InputMaybe<EventPlayerActionListRelationFilter>;
  eventsPlayerPlayerAction?: InputMaybe<EventPlayerPlayerActionListRelationFilter>;
  eventsRcon?: InputMaybe<EventRconListRelationFilter>;
  eventsSuicide?: InputMaybe<EventSuicideListRelationFilter>;
  eventsTeamBonus?: InputMaybe<EventTeamBonusListRelationFilter>;
  eventsTeamkill?: InputMaybe<EventTeamkillListRelationFilter>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  lastEvent?: InputMaybe<DateTimeNullableFilter>;
  lat?: InputMaybe<FloatNullableFilter>;
  lng?: InputMaybe<FloatNullableFilter>;
  loads?: InputMaybe<ServerLoadListRelationFilter>;
  mapChanges?: InputMaybe<IntFilter>;
  mapCtHits?: InputMaybe<IntFilter>;
  mapCtShots?: InputMaybe<IntFilter>;
  mapCtWins?: InputMaybe<IntFilter>;
  mapRounds?: InputMaybe<IntFilter>;
  mapStarted?: InputMaybe<IntFilter>;
  mapTsHits?: InputMaybe<IntFilter>;
  mapTsShots?: InputMaybe<IntFilter>;
  mapTsWins?: InputMaybe<IntFilter>;
  maxPlayers?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  notificationConfig?: InputMaybe<NotificationConfigWhereInput>;
  players?: InputMaybe<IntFilter>;
  port?: InputMaybe<IntFilter>;
  publicAddress?: InputMaybe<StringFilter>;
  rconPassword?: InputMaybe<StringFilter>;
  rounds?: InputMaybe<IntFilter>;
  serverId?: InputMaybe<Scalars['Int']['input']>;
  servers_docker_unique?: InputMaybe<ServerServers_Docker_UniqueCompoundUniqueInput>;
  servers_external_unique?: InputMaybe<ServerServers_External_UniqueCompoundUniqueInput>;
  sortOrder?: InputMaybe<IntFilter>;
  statusUrl?: InputMaybe<StringNullableFilter>;
  suicides?: InputMaybe<IntFilter>;
  tsHits?: InputMaybe<IntFilter>;
  tsShots?: InputMaybe<IntFilter>;
  tsWins?: InputMaybe<IntFilter>;
};

export type Session = {
  __typename?: 'Session';
  createdAt: Scalars['DateTime']['output'];
  expiresAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  impersonatedBy?: Maybe<Scalars['String']['output']>;
  ipAddress?: Maybe<Scalars['String']['output']>;
  token: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  user: User;
  userAgent?: Maybe<Scalars['String']['output']>;
  userId: Scalars['String']['output'];
};

export type SessionCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  impersonatedBy?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  token?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAgent?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type SessionCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  expiresAt: Scalars['DateTime']['input'];
  id: Scalars['String']['input'];
  impersonatedBy?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user: UserCreateNestedOneWithoutSessionsInput;
  userAgent?: InputMaybe<Scalars['String']['input']>;
};

export type SessionCreateManyInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  expiresAt: Scalars['DateTime']['input'];
  id: Scalars['String']['input'];
  impersonatedBy?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['String']['input'];
};

export type SessionCreateManyUserInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  expiresAt: Scalars['DateTime']['input'];
  id: Scalars['String']['input'];
  impersonatedBy?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
};

export type SessionCreateManyUserInputEnvelope = {
  data: Array<SessionCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SessionCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<SessionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SessionCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SessionCreateWithoutUserInput>>;
  createMany?: InputMaybe<SessionCreateManyUserInputEnvelope>;
};

export type SessionCreateOrConnectWithoutUserInput = {
  create: SessionCreateWithoutUserInput;
  where: SessionWhereUniqueInput;
};

export type SessionCreateWithoutUserInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  expiresAt: Scalars['DateTime']['input'];
  id: Scalars['String']['input'];
  impersonatedBy?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
};

export type SessionListRelationFilter = {
  every?: InputMaybe<SessionWhereInput>;
  none?: InputMaybe<SessionWhereInput>;
  some?: InputMaybe<SessionWhereInput>;
};

export type SessionMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  impersonatedBy?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  token?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAgent?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type SessionMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  impersonatedBy?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  token?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAgent?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type SessionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum SessionOrderByRelevanceFieldEnum {
  Id = 'id',
  ImpersonatedBy = 'impersonatedBy',
  IpAddress = 'ipAddress',
  Token = 'token',
  UserAgent = 'userAgent',
  UserId = 'userId'
}

export type SessionOrderByRelevanceInput = {
  fields: Array<SessionOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type SessionOrderByWithAggregationInput = {
  _count?: InputMaybe<SessionCountOrderByAggregateInput>;
  _max?: InputMaybe<SessionMaxOrderByAggregateInput>;
  _min?: InputMaybe<SessionMinOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  impersonatedBy?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  token?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  userAgent?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export type SessionOrderByWithRelationInput = {
  _relevance?: InputMaybe<SessionOrderByRelevanceInput>;
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  impersonatedBy?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  token?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userAgent?: InputMaybe<SortOrder>;
  userId?: InputMaybe<SortOrder>;
};

export enum SessionScalarFieldEnum {
  CreatedAt = 'createdAt',
  ExpiresAt = 'expiresAt',
  Id = 'id',
  ImpersonatedBy = 'impersonatedBy',
  IpAddress = 'ipAddress',
  Token = 'token',
  UpdatedAt = 'updatedAt',
  UserAgent = 'userAgent',
  UserId = 'userId'
}

export type SessionScalarWhereInput = {
  AND?: InputMaybe<Array<SessionScalarWhereInput>>;
  NOT?: InputMaybe<Array<SessionScalarWhereInput>>;
  OR?: InputMaybe<Array<SessionScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  expiresAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  impersonatedBy?: InputMaybe<StringNullableFilter>;
  ipAddress?: InputMaybe<StringNullableFilter>;
  token?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userAgent?: InputMaybe<StringNullableFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type SessionScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<SessionScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<SessionScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<SessionScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  expiresAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  impersonatedBy?: InputMaybe<StringNullableWithAggregatesFilter>;
  ipAddress?: InputMaybe<StringNullableWithAggregatesFilter>;
  token?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  userAgent?: InputMaybe<StringNullableWithAggregatesFilter>;
  userId?: InputMaybe<StringWithAggregatesFilter>;
};

export type SessionUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  expiresAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  impersonatedBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  ipAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  token?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutSessionsNestedInput>;
  userAgent?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type SessionUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  expiresAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  impersonatedBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  ipAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  token?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAgent?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type SessionUpdateManyWithWhereWithoutUserInput = {
  data: SessionUpdateManyMutationInput;
  where: SessionScalarWhereInput;
};

export type SessionUpdateManyWithoutUserNestedInput = {
  connect?: InputMaybe<Array<SessionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SessionCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SessionCreateWithoutUserInput>>;
  createMany?: InputMaybe<SessionCreateManyUserInputEnvelope>;
  delete?: InputMaybe<Array<SessionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SessionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SessionWhereUniqueInput>>;
  set?: InputMaybe<Array<SessionWhereUniqueInput>>;
  update?: InputMaybe<Array<SessionUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: InputMaybe<Array<SessionUpdateManyWithWhereWithoutUserInput>>;
  upsert?: InputMaybe<Array<SessionUpsertWithWhereUniqueWithoutUserInput>>;
};

export type SessionUpdateWithWhereUniqueWithoutUserInput = {
  data: SessionUpdateWithoutUserInput;
  where: SessionWhereUniqueInput;
};

export type SessionUpdateWithoutUserInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  expiresAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  impersonatedBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  ipAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  token?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  userAgent?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type SessionUpsertWithWhereUniqueWithoutUserInput = {
  create: SessionCreateWithoutUserInput;
  update: SessionUpdateWithoutUserInput;
  where: SessionWhereUniqueInput;
};

export type SessionWhereInput = {
  AND?: InputMaybe<Array<SessionWhereInput>>;
  NOT?: InputMaybe<Array<SessionWhereInput>>;
  OR?: InputMaybe<Array<SessionWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  expiresAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  impersonatedBy?: InputMaybe<StringNullableFilter>;
  ipAddress?: InputMaybe<StringNullableFilter>;
  token?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userAgent?: InputMaybe<StringNullableFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type SessionWhereUniqueInput = {
  AND?: InputMaybe<Array<SessionWhereInput>>;
  NOT?: InputMaybe<Array<SessionWhereInput>>;
  OR?: InputMaybe<Array<SessionWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  expiresAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  impersonatedBy?: InputMaybe<StringNullableFilter>;
  ipAddress?: InputMaybe<StringNullableFilter>;
  token?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userAgent?: InputMaybe<StringNullableFilter>;
  userId?: InputMaybe<StringFilter>;
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']['input']>;
};

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type StringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type StringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  search?: InputMaybe<Scalars['String']['input']>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type Team = {
  __typename?: 'Team';
  code: Scalars['String']['output'];
  game: Scalars['String']['output'];
  hidden: Scalars['String']['output'];
  name: Scalars['String']['output'];
  playerlistBgcolor?: Maybe<Scalars['String']['output']>;
  playerlistColor?: Maybe<Scalars['String']['output']>;
  playerlistIndex: Scalars['Int']['output'];
  teamId: Scalars['ID']['output'];
};

export type TeamAvgOrderByAggregateInput = {
  playerlistIndex?: InputMaybe<SortOrder>;
  teamId?: InputMaybe<SortOrder>;
};

export type TeamCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  playerlistBgcolor?: InputMaybe<SortOrder>;
  playerlistColor?: InputMaybe<SortOrder>;
  playerlistIndex?: InputMaybe<SortOrder>;
  teamId?: InputMaybe<SortOrder>;
};

export type TeamCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  playerlistBgcolor?: InputMaybe<Scalars['String']['input']>;
  playerlistColor?: InputMaybe<Scalars['String']['input']>;
  playerlistIndex?: InputMaybe<Scalars['Int']['input']>;
};

export type TeamCreateManyInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  hidden?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  playerlistBgcolor?: InputMaybe<Scalars['String']['input']>;
  playerlistColor?: InputMaybe<Scalars['String']['input']>;
  playerlistIndex?: InputMaybe<Scalars['Int']['input']>;
  teamId?: InputMaybe<Scalars['Int']['input']>;
};

export type TeamGamecodeCompoundUniqueInput = {
  code: Scalars['String']['input'];
  game: Scalars['String']['input'];
};

export type TeamMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  playerlistBgcolor?: InputMaybe<SortOrder>;
  playerlistColor?: InputMaybe<SortOrder>;
  playerlistIndex?: InputMaybe<SortOrder>;
  teamId?: InputMaybe<SortOrder>;
};

export type TeamMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  playerlistBgcolor?: InputMaybe<SortOrder>;
  playerlistColor?: InputMaybe<SortOrder>;
  playerlistIndex?: InputMaybe<SortOrder>;
  teamId?: InputMaybe<SortOrder>;
};

export enum TeamOrderByRelevanceFieldEnum {
  Code = 'code',
  Game = 'game',
  Hidden = 'hidden',
  Name = 'name',
  PlayerlistBgcolor = 'playerlistBgcolor',
  PlayerlistColor = 'playerlistColor'
}

export type TeamOrderByRelevanceInput = {
  fields: Array<TeamOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type TeamOrderByWithAggregationInput = {
  _avg?: InputMaybe<TeamAvgOrderByAggregateInput>;
  _count?: InputMaybe<TeamCountOrderByAggregateInput>;
  _max?: InputMaybe<TeamMaxOrderByAggregateInput>;
  _min?: InputMaybe<TeamMinOrderByAggregateInput>;
  _sum?: InputMaybe<TeamSumOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  playerlistBgcolor?: InputMaybe<SortOrder>;
  playerlistColor?: InputMaybe<SortOrder>;
  playerlistIndex?: InputMaybe<SortOrder>;
  teamId?: InputMaybe<SortOrder>;
};

export type TeamOrderByWithRelationInput = {
  _relevance?: InputMaybe<TeamOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  hidden?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  playerlistBgcolor?: InputMaybe<SortOrder>;
  playerlistColor?: InputMaybe<SortOrder>;
  playerlistIndex?: InputMaybe<SortOrder>;
  teamId?: InputMaybe<SortOrder>;
};

export enum TeamScalarFieldEnum {
  Code = 'code',
  Game = 'game',
  Hidden = 'hidden',
  Name = 'name',
  PlayerlistBgcolor = 'playerlistBgcolor',
  PlayerlistColor = 'playerlistColor',
  PlayerlistIndex = 'playerlistIndex',
  TeamId = 'teamId'
}

export type TeamScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<TeamScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<TeamScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<TeamScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  hidden?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  playerlistBgcolor?: InputMaybe<StringNullableWithAggregatesFilter>;
  playerlistColor?: InputMaybe<StringNullableWithAggregatesFilter>;
  playerlistIndex?: InputMaybe<IntWithAggregatesFilter>;
  teamId?: InputMaybe<IntWithAggregatesFilter>;
};

export type TeamSumOrderByAggregateInput = {
  playerlistIndex?: InputMaybe<SortOrder>;
  teamId?: InputMaybe<SortOrder>;
};

export type TeamUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerlistBgcolor?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  playerlistColor?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  playerlistIndex?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type TeamUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  hidden?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  playerlistBgcolor?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  playerlistColor?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  playerlistIndex?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type TeamWhereInput = {
  AND?: InputMaybe<Array<TeamWhereInput>>;
  NOT?: InputMaybe<Array<TeamWhereInput>>;
  OR?: InputMaybe<Array<TeamWhereInput>>;
  code?: InputMaybe<StringFilter>;
  game?: InputMaybe<StringFilter>;
  hidden?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  playerlistBgcolor?: InputMaybe<StringNullableFilter>;
  playerlistColor?: InputMaybe<StringNullableFilter>;
  playerlistIndex?: InputMaybe<IntFilter>;
  teamId?: InputMaybe<IntFilter>;
};

export type TeamWhereUniqueInput = {
  AND?: InputMaybe<Array<TeamWhereInput>>;
  NOT?: InputMaybe<Array<TeamWhereInput>>;
  OR?: InputMaybe<Array<TeamWhereInput>>;
  code?: InputMaybe<StringFilter>;
  game?: InputMaybe<StringFilter>;
  gamecode?: InputMaybe<TeamGamecodeCompoundUniqueInput>;
  hidden?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  playerlistBgcolor?: InputMaybe<StringNullableFilter>;
  playerlistColor?: InputMaybe<StringNullableFilter>;
  playerlistIndex?: InputMaybe<IntFilter>;
  teamId?: InputMaybe<Scalars['Int']['input']>;
};

export enum TransactionIsolationLevel {
  ReadCommitted = 'ReadCommitted',
  ReadUncommitted = 'ReadUncommitted',
  RepeatableRead = 'RepeatableRead',
  Serializable = 'Serializable'
}

export type UpdateServerInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  connectionType?: InputMaybe<Scalars['String']['input']>;
  dockerHost?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  mod?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  port?: InputMaybe<Scalars['Int']['input']>;
  publicAddress?: InputMaybe<Scalars['String']['input']>;
  rconPassword?: InputMaybe<Scalars['String']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  statusUrl?: InputMaybe<Scalars['String']['input']>;
};

export type User = {
  __typename?: 'User';
  accounts: Array<Account>;
  banExpires?: Maybe<Scalars['DateTime']['output']>;
  banReason?: Maybe<Scalars['String']['output']>;
  banned?: Maybe<Scalars['Boolean']['output']>;
  createdAt: Scalars['DateTime']['output'];
  email: Scalars['String']['output'];
  emailVerified: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  role?: Maybe<Scalars['String']['output']>;
  sessions: Array<Session>;
  updatedAt: Scalars['DateTime']['output'];
};


export type UserAccountsArgs = {
  cursor?: InputMaybe<AccountWhereUniqueInput>;
  distinct?: InputMaybe<Array<AccountScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AccountOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AccountWhereInput>;
};


export type UserSessionsArgs = {
  cursor?: InputMaybe<SessionWhereUniqueInput>;
  distinct?: InputMaybe<Array<SessionScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SessionOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<SessionWhereInput>;
};

export type UserCountOrderByAggregateInput = {
  banExpires?: InputMaybe<SortOrder>;
  banReason?: InputMaybe<SortOrder>;
  banned?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserCreateInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  banExpires?: InputMaybe<Scalars['DateTime']['input']>;
  banReason?: InputMaybe<Scalars['String']['input']>;
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  email: Scalars['String']['input'];
  emailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['String']['input'];
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  role?: InputMaybe<Scalars['String']['input']>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateManyInput = {
  banExpires?: InputMaybe<Scalars['DateTime']['input']>;
  banReason?: InputMaybe<Scalars['String']['input']>;
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  email: Scalars['String']['input'];
  emailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['String']['input'];
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  role?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateNestedOneWithoutAccountsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutAccountsInput>;
  create?: InputMaybe<UserCreateWithoutAccountsInput>;
};

export type UserCreateNestedOneWithoutSessionsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSessionsInput>;
  create?: InputMaybe<UserCreateWithoutSessionsInput>;
};

export type UserCreateOrConnectWithoutAccountsInput = {
  create: UserCreateWithoutAccountsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutSessionsInput = {
  create: UserCreateWithoutSessionsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateWithoutAccountsInput = {
  banExpires?: InputMaybe<Scalars['DateTime']['input']>;
  banReason?: InputMaybe<Scalars['String']['input']>;
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  email: Scalars['String']['input'];
  emailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['String']['input'];
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  role?: InputMaybe<Scalars['String']['input']>;
  sessions?: InputMaybe<SessionCreateNestedManyWithoutUserInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutSessionsInput = {
  accounts?: InputMaybe<AccountCreateNestedManyWithoutUserInput>;
  banExpires?: InputMaybe<Scalars['DateTime']['input']>;
  banReason?: InputMaybe<Scalars['String']['input']>;
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  email: Scalars['String']['input'];
  emailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['String']['input'];
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  role?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserMaxOrderByAggregateInput = {
  banExpires?: InputMaybe<SortOrder>;
  banReason?: InputMaybe<SortOrder>;
  banned?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserMinOrderByAggregateInput = {
  banExpires?: InputMaybe<SortOrder>;
  banReason?: InputMaybe<SortOrder>;
  banned?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum UserOrderByRelevanceFieldEnum {
  BanReason = 'banReason',
  Email = 'email',
  Id = 'id',
  Image = 'image',
  Name = 'name',
  Role = 'role'
}

export type UserOrderByRelevanceInput = {
  fields: Array<UserOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type UserOrderByWithAggregationInput = {
  _count?: InputMaybe<UserCountOrderByAggregateInput>;
  _max?: InputMaybe<UserMaxOrderByAggregateInput>;
  _min?: InputMaybe<UserMinOrderByAggregateInput>;
  banExpires?: InputMaybe<SortOrder>;
  banReason?: InputMaybe<SortOrder>;
  banned?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserOrderByWithRelationInput = {
  _relevance?: InputMaybe<UserOrderByRelevanceInput>;
  accounts?: InputMaybe<AccountOrderByRelationAggregateInput>;
  banExpires?: InputMaybe<SortOrder>;
  banReason?: InputMaybe<SortOrder>;
  banned?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  role?: InputMaybe<SortOrder>;
  sessions?: InputMaybe<SessionOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum UserScalarFieldEnum {
  BanExpires = 'banExpires',
  BanReason = 'banReason',
  Banned = 'banned',
  CreatedAt = 'createdAt',
  Email = 'email',
  EmailVerified = 'emailVerified',
  Id = 'id',
  Image = 'image',
  Name = 'name',
  Role = 'role',
  UpdatedAt = 'updatedAt'
}

export type UserScalarRelationFilter = {
  is?: InputMaybe<UserWhereInput>;
  isNot?: InputMaybe<UserWhereInput>;
};

export type UserScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<UserScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<UserScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<UserScalarWhereWithAggregatesInput>>;
  banExpires?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  banReason?: InputMaybe<StringNullableWithAggregatesFilter>;
  banned?: InputMaybe<BoolNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  email?: InputMaybe<StringWithAggregatesFilter>;
  emailVerified?: InputMaybe<BoolWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  image?: InputMaybe<StringNullableWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  role?: InputMaybe<StringNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type UserUpdateInput = {
  accounts?: InputMaybe<AccountUpdateManyWithoutUserNestedInput>;
  banExpires?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  banReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  banned?: InputMaybe<NullableBoolFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  role?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  sessions?: InputMaybe<SessionUpdateManyWithoutUserNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateManyMutationInput = {
  banExpires?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  banReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  banned?: InputMaybe<NullableBoolFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  role?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutAccountsInput>;
  create?: InputMaybe<UserCreateWithoutAccountsInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutAccountsInput>;
  upsert?: InputMaybe<UserUpsertWithoutAccountsInput>;
};

export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSessionsInput>;
  create?: InputMaybe<UserCreateWithoutSessionsInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutSessionsInput>;
  upsert?: InputMaybe<UserUpsertWithoutSessionsInput>;
};

export type UserUpdateToOneWithWhereWithoutAccountsInput = {
  data: UserUpdateWithoutAccountsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutSessionsInput = {
  data: UserUpdateWithoutSessionsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateWithoutAccountsInput = {
  banExpires?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  banReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  banned?: InputMaybe<NullableBoolFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  role?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  sessions?: InputMaybe<SessionUpdateManyWithoutUserNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutSessionsInput = {
  accounts?: InputMaybe<AccountUpdateManyWithoutUserNestedInput>;
  banExpires?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  banReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  banned?: InputMaybe<NullableBoolFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  image?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  role?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpsertWithoutAccountsInput = {
  create: UserCreateWithoutAccountsInput;
  update: UserUpdateWithoutAccountsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutSessionsInput = {
  create: UserCreateWithoutSessionsInput;
  update: UserUpdateWithoutSessionsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserWhereInput = {
  AND?: InputMaybe<Array<UserWhereInput>>;
  NOT?: InputMaybe<Array<UserWhereInput>>;
  OR?: InputMaybe<Array<UserWhereInput>>;
  accounts?: InputMaybe<AccountListRelationFilter>;
  banExpires?: InputMaybe<DateTimeNullableFilter>;
  banReason?: InputMaybe<StringNullableFilter>;
  banned?: InputMaybe<BoolNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  email?: InputMaybe<StringFilter>;
  emailVerified?: InputMaybe<BoolFilter>;
  id?: InputMaybe<StringFilter>;
  image?: InputMaybe<StringNullableFilter>;
  name?: InputMaybe<StringFilter>;
  role?: InputMaybe<StringNullableFilter>;
  sessions?: InputMaybe<SessionListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type UserWhereUniqueInput = {
  AND?: InputMaybe<Array<UserWhereInput>>;
  NOT?: InputMaybe<Array<UserWhereInput>>;
  OR?: InputMaybe<Array<UserWhereInput>>;
  accounts?: InputMaybe<AccountListRelationFilter>;
  banExpires?: InputMaybe<DateTimeNullableFilter>;
  banReason?: InputMaybe<StringNullableFilter>;
  banned?: InputMaybe<BoolNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailVerified?: InputMaybe<BoolFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<StringNullableFilter>;
  name?: InputMaybe<StringFilter>;
  role?: InputMaybe<StringNullableFilter>;
  sessions?: InputMaybe<SessionListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type Verification = {
  __typename?: 'Verification';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  expiresAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  identifier: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  value: Scalars['String']['output'];
};

export type VerificationCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identifier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type VerificationCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  expiresAt: Scalars['DateTime']['input'];
  id: Scalars['String']['input'];
  identifier: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  value: Scalars['String']['input'];
};

export type VerificationCreateManyInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  expiresAt: Scalars['DateTime']['input'];
  id: Scalars['String']['input'];
  identifier: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  value: Scalars['String']['input'];
};

export type VerificationMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identifier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type VerificationMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identifier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum VerificationOrderByRelevanceFieldEnum {
  Id = 'id',
  Identifier = 'identifier',
  Value = 'value'
}

export type VerificationOrderByRelevanceInput = {
  fields: Array<VerificationOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type VerificationOrderByWithAggregationInput = {
  _count?: InputMaybe<VerificationCountOrderByAggregateInput>;
  _max?: InputMaybe<VerificationMaxOrderByAggregateInput>;
  _min?: InputMaybe<VerificationMinOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identifier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export type VerificationOrderByWithRelationInput = {
  _relevance?: InputMaybe<VerificationOrderByRelevanceInput>;
  createdAt?: InputMaybe<SortOrder>;
  expiresAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  identifier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  value?: InputMaybe<SortOrder>;
};

export enum VerificationScalarFieldEnum {
  CreatedAt = 'createdAt',
  ExpiresAt = 'expiresAt',
  Id = 'id',
  Identifier = 'identifier',
  UpdatedAt = 'updatedAt',
  Value = 'value'
}

export type VerificationScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<VerificationScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<VerificationScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<VerificationScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  expiresAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  identifier?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  value?: InputMaybe<StringWithAggregatesFilter>;
};

export type VerificationUpdateInput = {
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  expiresAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  identifier?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type VerificationUpdateManyMutationInput = {
  createdAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  expiresAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  identifier?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type VerificationWhereInput = {
  AND?: InputMaybe<Array<VerificationWhereInput>>;
  NOT?: InputMaybe<Array<VerificationWhereInput>>;
  OR?: InputMaybe<Array<VerificationWhereInput>>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  expiresAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  identifier?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeNullableFilter>;
  value?: InputMaybe<StringFilter>;
};

export type VerificationWhereUniqueInput = {
  AND?: InputMaybe<Array<VerificationWhereInput>>;
  NOT?: InputMaybe<Array<VerificationWhereInput>>;
  OR?: InputMaybe<Array<VerificationWhereInput>>;
  createdAt?: InputMaybe<DateTimeNullableFilter>;
  expiresAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<DateTimeNullableFilter>;
  value?: InputMaybe<StringFilter>;
};

export type Weapon = {
  __typename?: 'Weapon';
  code: Scalars['String']['output'];
  game: Scalars['String']['output'];
  headshots: Scalars['Int']['output'];
  kills: Scalars['Int']['output'];
  modifier: Scalars['Float']['output'];
  name: Scalars['String']['output'];
  weaponId: Scalars['ID']['output'];
};

export type WeaponAvgOrderByAggregateInput = {
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  modifier?: InputMaybe<SortOrder>;
  weaponId?: InputMaybe<SortOrder>;
};

export type WeaponCountOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  modifier?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  weaponId?: InputMaybe<SortOrder>;
};

export type WeaponCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  modifier?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type WeaponCreateManyInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  game?: InputMaybe<Scalars['String']['input']>;
  headshots?: InputMaybe<Scalars['Int']['input']>;
  kills?: InputMaybe<Scalars['Int']['input']>;
  modifier?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  weaponId?: InputMaybe<Scalars['Int']['input']>;
};

export type WeaponGamecodeCompoundUniqueInput = {
  code: Scalars['String']['input'];
  game: Scalars['String']['input'];
};

export type WeaponMaxOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  modifier?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  weaponId?: InputMaybe<SortOrder>;
};

export type WeaponMinOrderByAggregateInput = {
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  modifier?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  weaponId?: InputMaybe<SortOrder>;
};

export enum WeaponOrderByRelevanceFieldEnum {
  Code = 'code',
  Game = 'game',
  Name = 'name'
}

export type WeaponOrderByRelevanceInput = {
  fields: Array<WeaponOrderByRelevanceFieldEnum>;
  search: Scalars['String']['input'];
  sort: SortOrder;
};

export type WeaponOrderByWithAggregationInput = {
  _avg?: InputMaybe<WeaponAvgOrderByAggregateInput>;
  _count?: InputMaybe<WeaponCountOrderByAggregateInput>;
  _max?: InputMaybe<WeaponMaxOrderByAggregateInput>;
  _min?: InputMaybe<WeaponMinOrderByAggregateInput>;
  _sum?: InputMaybe<WeaponSumOrderByAggregateInput>;
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  modifier?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  weaponId?: InputMaybe<SortOrder>;
};

export type WeaponOrderByWithRelationInput = {
  _relevance?: InputMaybe<WeaponOrderByRelevanceInput>;
  code?: InputMaybe<SortOrder>;
  game?: InputMaybe<SortOrder>;
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  modifier?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  weaponId?: InputMaybe<SortOrder>;
};

export enum WeaponScalarFieldEnum {
  Code = 'code',
  Game = 'game',
  Headshots = 'headshots',
  Kills = 'kills',
  Modifier = 'modifier',
  Name = 'name',
  WeaponId = 'weaponId'
}

export type WeaponScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<WeaponScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<WeaponScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<WeaponScalarWhereWithAggregatesInput>>;
  code?: InputMaybe<StringWithAggregatesFilter>;
  game?: InputMaybe<StringWithAggregatesFilter>;
  headshots?: InputMaybe<IntWithAggregatesFilter>;
  kills?: InputMaybe<IntWithAggregatesFilter>;
  modifier?: InputMaybe<FloatWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  weaponId?: InputMaybe<IntWithAggregatesFilter>;
};

export type WeaponSumOrderByAggregateInput = {
  headshots?: InputMaybe<SortOrder>;
  kills?: InputMaybe<SortOrder>;
  modifier?: InputMaybe<SortOrder>;
  weaponId?: InputMaybe<SortOrder>;
};

export type WeaponUpdateInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  modifier?: InputMaybe<FloatFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type WeaponUpdateManyMutationInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  game?: InputMaybe<StringFieldUpdateOperationsInput>;
  headshots?: InputMaybe<IntFieldUpdateOperationsInput>;
  kills?: InputMaybe<IntFieldUpdateOperationsInput>;
  modifier?: InputMaybe<FloatFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type WeaponWhereInput = {
  AND?: InputMaybe<Array<WeaponWhereInput>>;
  NOT?: InputMaybe<Array<WeaponWhereInput>>;
  OR?: InputMaybe<Array<WeaponWhereInput>>;
  code?: InputMaybe<StringFilter>;
  game?: InputMaybe<StringFilter>;
  headshots?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  modifier?: InputMaybe<FloatFilter>;
  name?: InputMaybe<StringFilter>;
  weaponId?: InputMaybe<IntFilter>;
};

export type WeaponWhereUniqueInput = {
  AND?: InputMaybe<Array<WeaponWhereInput>>;
  NOT?: InputMaybe<Array<WeaponWhereInput>>;
  OR?: InputMaybe<Array<WeaponWhereInput>>;
  code?: InputMaybe<StringFilter>;
  game?: InputMaybe<StringFilter>;
  gamecode?: InputMaybe<WeaponGamecodeCompoundUniqueInput>;
  headshots?: InputMaybe<IntFilter>;
  kills?: InputMaybe<IntFilter>;
  modifier?: InputMaybe<FloatFilter>;
  name?: InputMaybe<StringFilter>;
  weaponId?: InputMaybe<Scalars['Int']['input']>;
};

export type GetGamesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGamesQuery = { __typename?: 'Query', findManyGame: Array<{ __typename?: 'Game', code: string, name: string, hidden: string, realgame: string }> };

export type GetGamesWithPaginationQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GameOrderByWithRelationInput> | GameOrderByWithRelationInput>;
  where?: InputMaybe<GameWhereInput>;
}>;


export type GetGamesWithPaginationQuery = { __typename?: 'Query', findManyGame: Array<{ __typename?: 'Game', code: string, name: string, hidden: string, realgame: string }> };

export type GetGameCountQueryVariables = Exact<{
  where?: InputMaybe<GameWhereInput>;
}>;


export type GetGameCountQuery = { __typename?: 'Query', countGame: number };

export type GetPlayersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPlayersQuery = { __typename?: 'Query', findManyPlayer: Array<{ __typename?: 'Player', playerId: string, lastName: string, email?: string | null, skill: number, kills: number, deaths: number, lastEvent?: any | null, lastSkillChange?: any | null }> };

export type GetPlayersWithPaginationQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlayerOrderByWithRelationInput> | PlayerOrderByWithRelationInput>;
  where?: InputMaybe<PlayerWhereInput>;
}>;


export type GetPlayersWithPaginationQuery = { __typename?: 'Query', findManyPlayer: Array<{ __typename?: 'Player', playerId: string, lastName: string, email?: string | null, skill: number, kills: number, deaths: number, lastEvent?: any | null, lastSkillChange?: any | null }> };

export type GetPlayerCountQueryVariables = Exact<{
  where?: InputMaybe<PlayerWhereInput>;
}>;


export type GetPlayerCountQuery = { __typename?: 'Query', countPlayer: number };

export type GetGamesForSelectQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGamesForSelectQuery = { __typename?: 'Query', findManyGame: Array<{ __typename?: 'Game', code: string, name: string }> };

export type GetModsForSelectQueryVariables = Exact<{ [key: string]: never; }>;


export type GetModsForSelectQuery = { __typename?: 'Query', findManyModSupported: Array<{ __typename?: 'ModSupported', code: string, name: string }> };

export type CreateServerWithConfigMutationVariables = Exact<{
  data: CreateServerInput;
}>;


export type CreateServerWithConfigMutation = { __typename?: 'Mutation', createServerWithConfig?: { __typename?: 'ServerOperationResult', success?: boolean | null, message?: string | null, configsCount?: number | null, server?: { __typename?: 'SafeServer', serverId?: number | null, name?: string | null, address?: string | null, port?: number | null, game?: string | null, publicAddress?: string | null, statusUrl?: string | null, connectionType?: string | null, dockerHost?: string | null, sortOrder?: number | null } | null } | null };

export type UpdateServerWithConfigMutationVariables = Exact<{
  serverId: Scalars['Int']['input'];
  data: UpdateServerInput;
}>;


export type UpdateServerWithConfigMutation = { __typename?: 'Mutation', updateServerWithConfig?: { __typename?: 'ServerOperationResult', success?: boolean | null, message?: string | null, configsCount?: number | null, server?: { __typename?: 'SafeServer', serverId?: number | null, name?: string | null, address?: string | null, port?: number | null, game?: string | null, publicAddress?: string | null, statusUrl?: string | null, connectionType?: string | null, dockerHost?: string | null, sortOrder?: number | null } | null } | null };

export type GetServersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetServersQuery = { __typename?: 'Query', findManyServer: Array<{ __typename?: 'Server', serverId: string, name: string, address: string, port: number, game: string, activePlayers: number, maxPlayers: number, activeMap: string, lastEvent?: any | null, city: string, country: string }> };

export type GetServersWithPaginationQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServerOrderByWithRelationInput> | ServerOrderByWithRelationInput>;
  where?: InputMaybe<ServerWhereInput>;
}>;


export type GetServersWithPaginationQuery = { __typename?: 'Query', findManyServer: Array<{ __typename?: 'Server', serverId: string, name: string, address: string, port: number, game: string, activePlayers: number, maxPlayers: number, activeMap: string, lastEvent?: any | null, city: string, country: string }> };

export type GetServerCountQueryVariables = Exact<{
  where?: InputMaybe<ServerWhereInput>;
}>;


export type GetServerCountQuery = { __typename?: 'Query', countServer: number };

export type GetServerByIdWithConfigsQueryVariables = Exact<{
  serverId: Scalars['Int']['input'];
}>;


export type GetServerByIdWithConfigsQuery = { __typename?: 'Query', findUniqueServer?: { __typename?: 'Server', serverId: string, name: string, address: string, port: number, game: string, publicAddress: string, statusUrl?: string | null, rconPassword: string, connectionType: string, dockerHost?: string | null, sortOrder: number, configs: Array<{ __typename?: 'ServerConfig', parameter: string, value: string }> } | null };

export type GetUsersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUsersQuery = { __typename?: 'Query', findManyUser: Array<{ __typename?: 'User', id: string, name: string, email: string, emailVerified: boolean, role?: string | null, banned?: boolean | null, createdAt: any, updatedAt: any }> };

export type GetUsersWithPaginationQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput> | UserOrderByWithRelationInput>;
  where?: InputMaybe<UserWhereInput>;
}>;


export type GetUsersWithPaginationQuery = { __typename?: 'Query', findManyUser: Array<{ __typename?: 'User', id: string, name: string, email: string, emailVerified: boolean, role?: string | null, banned?: boolean | null, createdAt: any, updatedAt: any }> };

export type GetUserCountQueryVariables = Exact<{
  where?: InputMaybe<UserWhereInput>;
}>;


export type GetUserCountQuery = { __typename?: 'Query', countUser: number };

export type GetGamesListQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGamesListQuery = { __typename?: 'Query', findManyGame: Array<{ __typename?: 'Game', code: string, name: string, hidden: string }> };

export type GetServerByIdQueryVariables = Exact<{
  serverId: Scalars['Int']['input'];
}>;


export type GetServerByIdQuery = { __typename?: 'Query', findUniqueServer?: { __typename?: 'Server', serverId: string, name: string, address: string, port: number, game: string, publicAddress: string, statusUrl?: string | null, rconPassword: string, connectionType: string, dockerHost?: string | null, sortOrder: number } | null };


export const GetGamesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetGames"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyGame"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"hidden"}},{"kind":"Field","name":{"kind":"Name","value":"realgame"}}]}}]}}]} as unknown as DocumentNode<GetGamesQuery, GetGamesQueryVariables>;
export const GetGamesWithPaginationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetGamesWithPagination"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"take"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"skip"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"GameOrderByWithRelationInput"}}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"GameWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyGame"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"take"},"value":{"kind":"Variable","name":{"kind":"Name","value":"take"}}},{"kind":"Argument","name":{"kind":"Name","value":"skip"},"value":{"kind":"Variable","name":{"kind":"Name","value":"skip"}}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}}},{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"hidden"}},{"kind":"Field","name":{"kind":"Name","value":"realgame"}}]}}]}}]} as unknown as DocumentNode<GetGamesWithPaginationQuery, GetGamesWithPaginationQueryVariables>;
export const GetGameCountDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetGameCount"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"GameWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"countGame"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}]}]}}]} as unknown as DocumentNode<GetGameCountQuery, GetGameCountQueryVariables>;
export const GetPlayersDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetPlayers"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyPlayer"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"playerId"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"skill"}},{"kind":"Field","name":{"kind":"Name","value":"kills"}},{"kind":"Field","name":{"kind":"Name","value":"deaths"}},{"kind":"Field","name":{"kind":"Name","value":"lastEvent"}},{"kind":"Field","name":{"kind":"Name","value":"lastSkillChange"}}]}}]}}]} as unknown as DocumentNode<GetPlayersQuery, GetPlayersQueryVariables>;
export const GetPlayersWithPaginationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetPlayersWithPagination"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"take"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"skip"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"PlayerOrderByWithRelationInput"}}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"PlayerWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyPlayer"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"take"},"value":{"kind":"Variable","name":{"kind":"Name","value":"take"}}},{"kind":"Argument","name":{"kind":"Name","value":"skip"},"value":{"kind":"Variable","name":{"kind":"Name","value":"skip"}}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}}},{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"playerId"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"skill"}},{"kind":"Field","name":{"kind":"Name","value":"kills"}},{"kind":"Field","name":{"kind":"Name","value":"deaths"}},{"kind":"Field","name":{"kind":"Name","value":"lastEvent"}},{"kind":"Field","name":{"kind":"Name","value":"lastSkillChange"}}]}}]}}]} as unknown as DocumentNode<GetPlayersWithPaginationQuery, GetPlayersWithPaginationQueryVariables>;
export const GetPlayerCountDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetPlayerCount"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"PlayerWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"countPlayer"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}]}]}}]} as unknown as DocumentNode<GetPlayerCountQuery, GetPlayerCountQueryVariables>;
export const GetGamesForSelectDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetGamesForSelect"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyGame"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]} as unknown as DocumentNode<GetGamesForSelectQuery, GetGamesForSelectQueryVariables>;
export const GetModsForSelectDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetModsForSelect"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyModSupported"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]} as unknown as DocumentNode<GetModsForSelectQuery, GetModsForSelectQueryVariables>;
export const CreateServerWithConfigDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateServerWithConfig"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"data"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateServerInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createServerWithConfig"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"data"},"value":{"kind":"Variable","name":{"kind":"Name","value":"data"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"success"}},{"kind":"Field","name":{"kind":"Name","value":"message"}},{"kind":"Field","name":{"kind":"Name","value":"configsCount"}},{"kind":"Field","name":{"kind":"Name","value":"server"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"serverId"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"address"}},{"kind":"Field","name":{"kind":"Name","value":"port"}},{"kind":"Field","name":{"kind":"Name","value":"game"}},{"kind":"Field","name":{"kind":"Name","value":"publicAddress"}},{"kind":"Field","name":{"kind":"Name","value":"statusUrl"}},{"kind":"Field","name":{"kind":"Name","value":"connectionType"}},{"kind":"Field","name":{"kind":"Name","value":"dockerHost"}},{"kind":"Field","name":{"kind":"Name","value":"sortOrder"}}]}}]}}]}}]} as unknown as DocumentNode<CreateServerWithConfigMutation, CreateServerWithConfigMutationVariables>;
export const UpdateServerWithConfigDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateServerWithConfig"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"serverId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"data"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"UpdateServerInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateServerWithConfig"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"serverId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"serverId"}}},{"kind":"Argument","name":{"kind":"Name","value":"data"},"value":{"kind":"Variable","name":{"kind":"Name","value":"data"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"success"}},{"kind":"Field","name":{"kind":"Name","value":"message"}},{"kind":"Field","name":{"kind":"Name","value":"configsCount"}},{"kind":"Field","name":{"kind":"Name","value":"server"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"serverId"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"address"}},{"kind":"Field","name":{"kind":"Name","value":"port"}},{"kind":"Field","name":{"kind":"Name","value":"game"}},{"kind":"Field","name":{"kind":"Name","value":"publicAddress"}},{"kind":"Field","name":{"kind":"Name","value":"statusUrl"}},{"kind":"Field","name":{"kind":"Name","value":"connectionType"}},{"kind":"Field","name":{"kind":"Name","value":"dockerHost"}},{"kind":"Field","name":{"kind":"Name","value":"sortOrder"}}]}}]}}]}}]} as unknown as DocumentNode<UpdateServerWithConfigMutation, UpdateServerWithConfigMutationVariables>;
export const GetServersDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetServers"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyServer"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"serverId"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"address"}},{"kind":"Field","name":{"kind":"Name","value":"port"}},{"kind":"Field","name":{"kind":"Name","value":"game"}},{"kind":"Field","name":{"kind":"Name","value":"activePlayers"}},{"kind":"Field","name":{"kind":"Name","value":"maxPlayers"}},{"kind":"Field","name":{"kind":"Name","value":"activeMap"}},{"kind":"Field","name":{"kind":"Name","value":"lastEvent"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"country"}}]}}]}}]} as unknown as DocumentNode<GetServersQuery, GetServersQueryVariables>;
export const GetServersWithPaginationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetServersWithPagination"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"take"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"skip"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ServerOrderByWithRelationInput"}}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"ServerWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyServer"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"take"},"value":{"kind":"Variable","name":{"kind":"Name","value":"take"}}},{"kind":"Argument","name":{"kind":"Name","value":"skip"},"value":{"kind":"Variable","name":{"kind":"Name","value":"skip"}}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}}},{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"serverId"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"address"}},{"kind":"Field","name":{"kind":"Name","value":"port"}},{"kind":"Field","name":{"kind":"Name","value":"game"}},{"kind":"Field","name":{"kind":"Name","value":"activePlayers"}},{"kind":"Field","name":{"kind":"Name","value":"maxPlayers"}},{"kind":"Field","name":{"kind":"Name","value":"activeMap"}},{"kind":"Field","name":{"kind":"Name","value":"lastEvent"}},{"kind":"Field","name":{"kind":"Name","value":"city"}},{"kind":"Field","name":{"kind":"Name","value":"country"}}]}}]}}]} as unknown as DocumentNode<GetServersWithPaginationQuery, GetServersWithPaginationQueryVariables>;
export const GetServerCountDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetServerCount"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"ServerWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"countServer"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}]}]}}]} as unknown as DocumentNode<GetServerCountQuery, GetServerCountQueryVariables>;
export const GetServerByIdWithConfigsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetServerByIdWithConfigs"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"serverId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findUniqueServer"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"serverId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"serverId"}}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"serverId"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"address"}},{"kind":"Field","name":{"kind":"Name","value":"port"}},{"kind":"Field","name":{"kind":"Name","value":"game"}},{"kind":"Field","name":{"kind":"Name","value":"publicAddress"}},{"kind":"Field","name":{"kind":"Name","value":"statusUrl"}},{"kind":"Field","name":{"kind":"Name","value":"rconPassword"}},{"kind":"Field","name":{"kind":"Name","value":"connectionType"}},{"kind":"Field","name":{"kind":"Name","value":"dockerHost"}},{"kind":"Field","name":{"kind":"Name","value":"sortOrder"}},{"kind":"Field","name":{"kind":"Name","value":"configs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"parameter"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}}]} as unknown as DocumentNode<GetServerByIdWithConfigsQuery, GetServerByIdWithConfigsQueryVariables>;
export const GetUsersDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetUsers"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyUser"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"emailVerified"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"banned"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}}]}}]} as unknown as DocumentNode<GetUsersQuery, GetUsersQueryVariables>;
export const GetUsersWithPaginationDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetUsersWithPagination"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"take"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"skip"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"UserOrderByWithRelationInput"}}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"UserWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyUser"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"take"},"value":{"kind":"Variable","name":{"kind":"Name","value":"take"}}},{"kind":"Argument","name":{"kind":"Name","value":"skip"},"value":{"kind":"Variable","name":{"kind":"Name","value":"skip"}}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}}},{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"emailVerified"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"banned"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}}]}}]} as unknown as DocumentNode<GetUsersWithPaginationQuery, GetUsersWithPaginationQueryVariables>;
export const GetUserCountDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetUserCount"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"UserWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"countUser"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}]}]}}]} as unknown as DocumentNode<GetUserCountQuery, GetUserCountQueryVariables>;
export const GetGamesListDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetGamesList"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findManyGame"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"hidden"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"equals"},"value":{"kind":"StringValue","value":"0","block":false}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"code"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"hidden"}}]}}]}}]} as unknown as DocumentNode<GetGamesListQuery, GetGamesListQueryVariables>;
export const GetServerByIdDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetServerById"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"serverId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"findUniqueServer"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"serverId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"serverId"}}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"serverId"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"address"}},{"kind":"Field","name":{"kind":"Name","value":"port"}},{"kind":"Field","name":{"kind":"Name","value":"game"}},{"kind":"Field","name":{"kind":"Name","value":"publicAddress"}},{"kind":"Field","name":{"kind":"Name","value":"statusUrl"}},{"kind":"Field","name":{"kind":"Name","value":"rconPassword"}},{"kind":"Field","name":{"kind":"Name","value":"connectionType"}},{"kind":"Field","name":{"kind":"Name","value":"dockerHost"}},{"kind":"Field","name":{"kind":"Name","value":"sortOrder"}}]}}]}}]} as unknown as DocumentNode<GetServerByIdQuery, GetServerByIdQueryVariables>;